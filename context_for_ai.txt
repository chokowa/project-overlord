あなたはプログラミングのエキスパートです。
以下に提供されるのは、私の開発プロジェクトの全ソースコードです。
ファイルパスはプロジェクトルートからの相対パスで示されています。

これからのコード修正・出力においては、以下の【出力ルール】および【コーディング規約】を厳守してください。

**【重要：AI開発者向け憲法 (厳守事項)】**
以下のルールは、バグの再発防止と品質維持のために設定されたプロジェクトの「憲法」です。
いかなる理由があっても、これを無視したコードを生成しないでください。


【DEVELOPER NOTE: AIへの重要なお知らせ (厳守事項)】
このコードを修正・リファクタリングする際は、過去のバグ再発を防ぐため以下のルールを絶対に守ってください。

1. **ASTとRegexの併用**: PythonのAST解析だけに頼らないでください。構文エラーを含むファイルも扱うため、必ずRegexによるフォールバック実装が必要です。
2. **インデントの保持**: スニペットのインデントを正規化する際、タブとスペースの混在を考慮し、`expandtabs`を使用してください。
3. **多言語対応**: エラーメッセージをハードコーディングせず、必ず `constants.TRANSLATIONS` を使用してください。
4. **変数名の可読性**: `s`, `e`, `c`, `l` などの1文字変数は使用禁止です。`start_idx`, `app_colors` など意味のある名前を使ってください。
5. **型ヒントの維持**: 引数や戻り値には可能な限りType Hinting (typingモジュール) を記述してください。
6. **構造の維持**: import文は「標準ライブラリ」「サードパーティ」「ローカル」に分け、1行に詰め込むような記述（ワンライナーif等）は避けてください。


**【重要：AIへのコード生成指示】**
このプロジェクトでは、あなたの出力を Smart Patch が機械的に適用します。
適用方式は次の3つから、変更の性質に合わせて1つだけ選んでください。

共通ルール（必須）
- 省略禁止: ... や // existing code などの省略表現は禁止。置換対象は変更がなくても全文を出力してください。
- 構文維持: Pythonのインデント、JS/TSの括弧、JSONの構文を壊さないでください。
- 複数のファイルの更新が必要な場合はファイルの数に合わせて回答も複数回に分けてください。1回答=1ファイル: 1つの対象ファイルだけを更新する出力をしてください。
- **【表示崩れ防止】コードを出力する際は、必ず ``` (トリプルバッククォート) で囲んでコードブロック化してください。生のテキストとして出力すると改行が消える原因になります。**

**モード1: 検索置換（Search & Replace）**
使う場面: 既存コードの一部をピンポイントに修正したいとき（最優先）
出力形式:
<<<<<<< SEARCH
（対象ファイルからコピーした連続コード。推奨 5〜40行。最低2行。）
=======
（変更後コード。SEARCHと同じ範囲を、完全な形で出力。省略禁止。）
>>>>>>>

必須ルール（失敗回避）
- SEARCHブロックを作る際は、コメントや空白、改行位置を含めて1文字も変えずにコピーすること
- 可読性のための整形（Lint的な修正）をSEARCHブロック内では絶対に行わないこと」
- SEARCHは作る際は、内容・空白・改行・インデント・コメントを一切変更しないでください（不可視文字の混入も禁止）。
- SEARCHは対象ファイル内で必ず1箇所だけ一致するように長めに取ってください。
- **【重要：開始行のユニーク性】SEARCHブロックの「開始行（1行目）」は、ファイル内で一意（ユニーク）な行を選んでください。**
  - Smart Patchは「1行目」をアンカーとして検索します。ここが `container.innerHTML = '';` や `return;`, `}` のような汎用的な行だと「Multiple Targets」エラーになり適用できません。
  - 開始行が汎用的な場合、必ず「その直前の特徴的な行（関数定義や変数宣言など）」をSEARCHに含めてください。
- 【重要】短いブロック（50文字未満）はあいまい検索の閾値が厳しく設定されています。確実にマッチさせるため、前後の文脈を含めて十分な長さ（3行以上推奨）を確保してください。
- ブロックを複数出す場合:
  - 置換範囲が重ならないこと（重複はエラーになります）
  - 近接している変更は1つの大きなブロックにまとめること（重複事故を防ぐ）

**モード2: 定義ブロック置換（Definition Patch）**
使う場面: 関数/メソッド/クラスの追加・丸ごと差し替え。SEARCHで一意性が作れないとき。
出力: 変更したい定義を、定義行（def/class/function...）から終了までを丸ごと出力してください（省略禁止）。
注意:
- Python: AST解析を使用するため、クラス内メソッドも正確に特定可能です。
- JS/TS: ステートマシン解析を使用するため、テンプレートリテラルやネスト構造も堅牢に認識されます。ただし、正規表現リテラル(`/.../`)内に`{}`を含む場合のみパースに失敗する可能性があるため、その場合はモード1を使用するか `new RegExp` を使用してください。

**モード3: 全文更新（Full Update）**
使う場面: 変更が大きい/広い（目安50行以上、複数箇所にまたがる、import整理や大規模リファクタ）
出力: 対象ファイルの全コードを出力してください。

**【回答フォーマット】**
コードを出力する前に、必ず以下を明記し、私の許可（「OK」など）を待ってください。
1. **対象ファイル名**: (相対パスで記述)
2. **適用モード**: （スマートパッチ or 全文更新 or 検索置換）
3. **変更内容の要約**:

---
以下、プロジェクトのソースコードです。


▼▼▼ FILE START: blocks.js ▼▼▼
/**
 * @fileoverview Blocklyのカスタムブロック定義、コード生成、およびワークスペース管理
 * 憲法準拠: 1文字変数禁止、型ヒント必須、定数管理徹底。
 */

/** * 内部で使用する定数定義
 * @type {Object}
 */
const BLOCK_CONSTANTS = {
    CRITERIA: {
        MIN_DIST: "MIN_DIST",
        MAX_HP: "MAX_HP",
        MIN_HP: "MIN_HP"
    }
};

// --- 1. カスタムブロックの定義 (見た目と接続ルール) ---

Blockly.Blocks['get_enemies'] = {
    init: function() {
        this.appendDummyInput().appendField("射程内の敵リストを取得");
        this.setOutput(true, "Array");
        this.setColour(160);
        this.setTooltip("現在タレットの射程内にいる敵全員をリストとして返します。");
    }
};

Blockly.Blocks['select_enemy'] = {
    init: function() {
        this.appendValueInput("LIST").setCheck("Array").appendField("リストから");
        this.appendDummyInput()
            .appendField("が")
            .appendField(new Blockly.FieldDropdown([
                ["最短距離", BLOCK_CONSTANTS.CRITERIA.MIN_DIST],
                ["最大HP", BLOCK_CONSTANTS.CRITERIA.MAX_HP],
                ["最小HP", BLOCK_CONSTANTS.CRITERIA.MIN_HP]
            ]), "CRITERIA")
            .appendField("の敵を選択");
        this.setOutput(true, "Enemy");
        this.setColour(160);
        this.setTooltip("条件に一致する敵を1体選び出します。");
    }
};

Blockly.Blocks['set_target'] = {
    init: function() {
        this.appendValueInput("ENEMY").setCheck("Enemy").appendField("ターゲットを");
        this.appendDummyInput().appendField("に設定する");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(20);
        this.setTooltip("選んだ敵を、タレットが狙う対象として確定させます。");
    }
};

// --- 2. JavaScriptコード生成ロジック ---

const javascriptGenerator = Blockly.JavaScript;

javascriptGenerator.forBlock['get_enemies'] = function(blockInstance, generator) {
    const generatedCode = 'enemyList';
    return [generatedCode, generator.ORDER_ATOMIC];
};

javascriptGenerator.forBlock['select_enemy'] = function(blockInstance, generator) {
    const listCode = generator.valueToCode(blockInstance, 'LIST', generator.ORDER_ATOMIC) || '[]';
    const criteriaValue = blockInstance.getFieldValue('CRITERIA');
    const generatedCode = `selectEnemyHelper(${listCode}, "${criteriaValue}")`;
    return [generatedCode, generator.ORDER_FUNCTION_CALL];
};

javascriptGenerator.forBlock['set_target'] = function(blockInstance, generator) {
    const enemyInstanceCode = generator.valueToCode(blockInstance, 'ENEMY', generator.ORDER_ATOMIC) || 'null';
    return `this.targetEnemy = ${enemyInstanceCode};\n`;
};

// --- 3. ワークスペースの初期化と管理 ---

const TOOLBOX_DEFINITION = `
<xml xmlns="https://developers.google.com/blockly/xml">
    <category name="索敵ロジック" colour="160">
        <block type="get_enemies"></block>
        <block type="select_enemy"></block>
        <block type="set_target"></block>
    </category>
</xml>`;

const mainWorkspace = Blockly.inject('blockly-div', {
    toolbox: TOOLBOX_DEFINITION,
    scrollbars: true,
    trashcan: true,
    zoom: { controls: true, wheel: true }
});

window.applyAiLogic = function() {
    // @ts-ignore
    const generatedCode = javascriptGenerator.workspaceToCode(mainWorkspace);
    
    try {
        if (window.updateCustomAi) {
            window.updateCustomAi(generatedCode);
            console.log("AI Applied successfully.");
        }
    } catch (errorInstance) {
        console.error("Critical AI implementation error:", errorInstance);
    }
};

// --- 4. 初期配置ロジック ---

window.addEventListener('load', () => {
    const initialXml = `
    <xml xmlns="https://developers.google.com/blockly/xml">
        <block type="set_target" x="20" y="20">
            <value name="ENEMY">
                <block type="select_enemy">
                    <field name="CRITERIA">MIN_DIST</field>
                    <value name="LIST">
                        <block type="get_enemies"></block>
                    </value>
                </block>
            </value>
        </block>
    </xml>`;
    
    try {
        // Fix for modern Blockly versions
        const xmlDom = Blockly.utils.xml.textToDom(initialXml);
        Blockly.Xml.domToWorkspace(xmlDom, mainWorkspace);
    } catch (xmlError) {
        console.warn("Failed to load initial XML:", xmlError);
    }
});
▲▲▲ FILE END: blocks.js ▲▲▲

▼▼▼ FILE START: constants.js ▼▼▼
/**
 * @fileoverview ゲームバランス、GEM、スキルツリー、敵ティアの定義
 * 憲法準拠: 1文字変数禁止、型ヒント必須、定数管理徹底。
 * [Patch] Re-Balance: Casual Early Game & Power Fantasy Restoration + Ultimate Fixes
 */

export const GAME_SETTINGS = {
    SCREEN_WIDTH: 600,
    SCREEN_HEIGHT: 900,
    BASE_MAX_HP: 800,       // 500 -> 800
    XP_PER_LEVEL_BASE: 500, // 800 -> 500: 初期テンポ改善（約30秒でLvUP）
    XP_SCALING: 1.35,       // 1.25 -> 1.35: 後半の必要XP上昇率を微増
    DROP_CHANCE: 0.25,      // 0.3 -> 0.25: 全体のドロップ頻度を抑制

    CASTLE_Y: 720,          // 800 -> 720: UI被り防止のため砲台位置を上げる
    CASTLE_DAMAGE: 30,      // 50 -> 30
    INVENTORY_CAPACITY: 40,
    FUSION_COST: 3,
    SALVAGE_XP_BASE: 35,    // 25 -> 35: 売却XP微増
    SELL_PRICE_BASE: 50,    // アイテム売却価格の基準

    SPAWN_RATE_BASE: 70,    // 60 -> 70: 敵の湧きを少しマイルドに
    SPAWN_RATE_MIN: 15,

    // Economy & Shop
    GOLD_DROP_CHANCE: 0.35,
    GOLD_VALUE_BASE: 20,    // 15 -> 20
    REPAIR_COST: 150,
    REPAIR_AMOUNT: 150,
    MYSTERY_BOX_COST: 500,  // 600 -> 500

    FORMATION_CHANCE: 0.30, // 0.40 -> 0.30

    TREE_WIDTH: 2000,
    TREE_HEIGHT: 1500,

    // [Patch] Additional Settings
    ROCK_SPIKES_BASE: 3,
    ROCK_SPIKES_VAR: 3,
    LEECH_RATIO: 0.02,
    ENEMY_BASE_HP: 60,
    ENEMY_PROJECTILE_DAMAGE: 15
};

export const BOSS_WAVES = {
    // Wave 1-3: Casual (HP Nerf)
    1: { name: "SLIME KING", color: "#2ecc71", scale: 2.5, hp: 15.0, speed: 0.4, count: 1 }, 
    2: { name: "SHADOW STALKER", color: "#34495e", scale: 1.5, hp: 12.0, speed: 1.5, count: 1 }, 
    3: { name: "IRON GOLEM", color: "#95a5a6", scale: 3.0, hp: 30.0, speed: 0.3, count: 1 }, 
    
    // Wave 4+: Challenge begins
    4: { name: "TWIN FANGS", color: "#e67e22", scale: 1.8, hp: 20.0, speed: 1.3, count: 2 },
    5: { name: "HIVE MOTHER", color: "#9b59b6", scale: 3.5, hp: 60.0, speed: 0.2, count: 1 },
    6: { name: "CRIMSON & AZURE", color: "#e74c3c", scale: 2.0, hp: 35.0, speed: 0.9, count: 2 },
    7: { name: "CHAOS KNIGHT", color: "#f1c40f", scale: 2.2, hp: 80.0, speed: 1.0, count: 1 },
    8: { name: "THE TRIAD", color: "#bdc3c7", scale: 1.6, hp: 30.0, speed: 1.2, count: 3 },
    9: { name: "VOID DRAGON", color: "#8e44ad", scale: 4.0, hp: 200.0, speed: 0.7, count: 1 },
    10: { name: "OVERLORD", color: "#c0392b", scale: 5.0, hp: 10000.0, speed: 0.5, count: 1 }
};

export const GEM_TYPES = {
    ACTIVE: 'ACTIVE',
    SUPPORT: 'SUPPORT'
};

export const ARTIFACT_TYPES = {
    RING: 'RING',
    AMULET: 'AMULET',
    BOSS: 'BOSS_ARTIFACT' // New type
};

export const BOSS_ARTIFACTS = {
    // A. Standard Stats
    BERSERKER_HELM: { id: 'berserker_helm', name: '狂戦士の兜', icon: '⛑️', desc: 'HP減少率に応じて攻撃力UP (最大+50%)', type: 'BOSS_ARTIFACT', color: '#c0392b', config: { max_bonus: 0.5 } },
    ANCIENT_COIN:   { id: 'ancient_coin',   name: '古代のコイン', icon: '🪙', desc: '敵撃破時 5%でGold獲得', type: 'BOSS_ARTIFACT', color: '#f1c40f', config: { chance: 0.05, amount: 10 } },
    VAMPIRE_CUP:    { id: 'vampire_cup',    name: '吸血鬼の杯', icon: '🍷', desc: '撃破時HP1%回復', type: 'BOSS_ARTIFACT', color: '#8e44ad', config: { heal_pct: 0.01 } },
    SNIPER_SCOPE:   { id: 'sniper_scope',   name: 'スナイパースコープ', icon: '🔭', desc: '遠距離(Y<400)の敵へダメ+30%', type: 'BOSS_ARTIFACT', color: '#2ecc71', config: { range_y: 400, multiplier: 1.3 } },
    INF_BATTERY:    { id: 'inf_battery',    name: '無限電池', icon: '🔋', desc: 'MP回復速度 +50%', type: 'BOSS_ARTIFACT', color: '#66fcf1', stats: { mp_regen_pct: 0.5 } },

    // B. Defense / Shield
    SPIKE_SHIELD:   { id: 'spike_shield',   name: 'スパイクシールド', icon: '🛡️', desc: 'シールドバッシュ威力+100%', type: 'BOSS_ARTIFACT', color: '#95a5a6', stats: { shield_bash_mul: 1.0 } },
    MANA_CONV:      { id: 'mana_conv',      name: 'マナ変換器', icon: '♻️', desc: 'ジャストガード時 HP20回復', type: 'BOSS_ARTIFACT', color: '#3498db', config: { heal_amount: 20 } },
    EMERGENCY_CORE: { id: 'emergency_core', name: '緊急コア', icon: '🚨', desc: 'HP30%以下で自動シールド(60秒CT)', type: 'BOSS_ARTIFACT', color: '#e74c3c' },
    REFLECT_PRISM:  { id: 'reflect_prism',  name: '反射プリズム', icon: '💎', desc: 'ジャストガード時 爆発発生', type: 'BOSS_ARTIFACT', color: '#a29bfe' },
    GRAVITY_ANCHOR: { id: 'gravity_anchor', name: '重力アンカー', icon: '⚓', desc: 'シールド中、敵速度激減', type: 'BOSS_ARTIFACT', color: '#2c3e50' },

    // C. Offense Modifier
    PHANTOM_BARREL: { id: 'phantom_barrel', name: '幻影バレル', icon: '👻', desc: '20%で弾丸追加発射', type: 'BOSS_ARTIFACT', color: '#bdc3c7', config: { chance: 0.20, extra_shots: 1 } },
    BOUND_ORB:      { id: 'bound_orb',      name: 'バウンドオーブ', icon: '🥎', desc: '画面端で1回跳ね返る', type: 'BOSS_ARTIFACT', color: '#e67e22' },
    HOMING_BEACON:  { id: 'homing_beacon',  name: '誘導ビーコン', icon: '📡', desc: '弾に弱い追尾性能付与', type: 'BOSS_ARTIFACT', color: '#1abc9c' },
    GIANT_KILLER:   { id: 'giant_killer',   name: 'ジャイアントキラー', icon: '🗡️', desc: 'Boss/Tankへダメ+40%', type: 'BOSS_ARTIFACT', color: '#d35400', config: { multiplier: 1.4 } },
    CHAOS_DICE:     { id: 'chaos_dice',     name: 'カオスダイス', icon: '🎲', desc: 'ダメージが50%~200%で変動', type: 'BOSS_ARTIFACT', color: '#9b59b6' },

    // D. Elemental
    OIL_FLASK:      { id: 'oil_flask',      name: 'オイル瓶', icon: '🛢️', desc: '火属性Hitで炎上ダメージ倍増', type: 'BOSS_ARTIFACT', color: '#e67e22', config: { multiplier: 1.5 } },
    TESLA_COIL:     { id: 'tesla_coil',     name: 'テスラコイル', icon: '⚡', desc: '連鎖数 +2', type: 'BOSS_ARTIFACT', color: '#f1c40f', stats: { chain_count: 2 } },
    ZERO_CRYSTAL:   { id: 'zero_crystal',   name: '絶対零度', icon: '❄️', desc: '氷結敵への攻撃時 10%で即死', type: 'BOSS_ARTIFACT', color: '#74b9ff' },
    CORROSIVE_CROWN:{ id: 'corrosive_crown',name: '腐食の王冠', icon: '👑', desc: '毒敵死亡時 毒拡散', type: 'BOSS_ARTIFACT', color: '#2ecc71' },
    ELEM_MIXER:     { id: 'elem_mixer',     name: '属性ミキサー', icon: '⚗️', desc: '状態異常2種以上でダメ+50%', type: 'BOSS_ARTIFACT', color: '#ff7675' },

    // E. Unique
    GLASS_CANNON:   { id: 'glass_cannon',   name: 'ガラスのキャノン', icon: '💣', desc: 'ダメ+100% / 被ダメ+100%', type: 'BOSS_ARTIFACT', color: '#fff', stats: { final_damage_mul: 2.0, damage_taken_mul: 1.0 } },
    MERCHANT_SOUL:  { id: 'merchant_soul',  name: '商人の魂', icon: '⚖️', desc: '所持金100G毎にダメ+1%', type: 'BOSS_ARTIFACT', color: '#f39c12' },
    TIME_STOPPER:   { id: 'time_stopper',   name: '懐中時計', icon: '⏱️', desc: 'ボス出現時 5秒時間停止', type: 'BOSS_ARTIFACT', color: '#34495e' },

    // --- New Artifacts: Variety & Niche ---
    LUCKY_CAT:      { id: 'lucky_cat',      name: '招き猫', icon: '🐱', desc: '命中時、極稀に777G獲得', type: 'BOSS_ARTIFACT', color: '#ff7675' },
    BIG_MUSHROOM:   { id: 'big_mushroom',   name: '巨大キノコ', icon: '🍄', desc: '弾丸が巨大化 / 弾速低下', type: 'BOSS_ARTIFACT', color: '#e17055', stats: { proj_speed_pct: -0.4, aoe_pct: 0.5 } },
    PHOENIX_CORE:   { id: 'phoenix_core',   name: 'フェニックス', icon: '🔥', desc: '一度だけ力尽きても復活', type: 'BOSS_ARTIFACT', color: '#fab1a0' },

    // --- Skill Specific Buffs ---
    PSY_AMPLIFIER:  { id: 'psy_amplifier',  name: '念動増幅器', icon: '🧠', desc: '混乱中の敵死亡時に爆発', type: 'BOSS_ARTIFACT', color: '#a29bfe' },
    CHLORO_ARMOR:   { id: 'chloro_armor',   name: '光合成装甲', icon: '🌿', desc: '茨回復中 被ダメ-30%', type: 'BOSS_ARTIFACT', color: '#55efc4' },
    BOILING_POINT:  { id: 'boiling_point',  name: '沸騰点', icon: '♨️', desc: '炎上中の敵への激流ダメ2倍', type: 'BOSS_ARTIFACT', color: '#74b9ff' },

    // --- Crew Exclusive Artifacts (2 per Crew) ---
    // 1. Wolf
    WOLF_INSIGNIA:  { id: 'wolf_insignia',  name: '司令官の誇り', icon: '🎖️', desc: 'ドローン/分身威力+50%', type: 'BOSS_ARTIFACT', color: '#d63031', requiredCrewId: 1 },
    WOLF_RADIO:     { id: 'wolf_radio',     name: '戦術無線機', icon: '📻', desc: 'スキル持続時間 +50%', type: 'BOSS_ARTIFACT', color: '#ff7675', requiredCrewId: 1 },

    // 2. Luna
    LUNA_WING:      { id: 'luna_wing',      name: '月白の翼', icon: '🕊️', desc: '弾速の20%分 ダメージUP', type: 'BOSS_ARTIFACT', color: '#81ecec', requiredCrewId: 2 },
    LUNA_TURBO:     { id: 'luna_turbo',     name: '加速チップ', icon: '⚡', desc: 'シールド中 連射速度1.5倍', type: 'BOSS_ARTIFACT', color: '#55efc4', requiredCrewId: 2 },

    // 3. R-22
    R22_WRENCH:     { id: 'r22_wrench',     name: '黄金のレンチ', icon: '🔧', desc: 'MP回復速度 +100%', type: 'BOSS_ARTIFACT', color: '#ffeaa7', requiredCrewId: 3, stats: { mp_regen_pct: 1.0 } },
    R22_EYE:        { id: 'r22_eye',        name: '精密解析眼', icon: '👁️', desc: 'サポートGEM効果 +40%', type: 'BOSS_ARTIFACT', color: '#fab1a0', requiredCrewId: 3, stats: { support_effect: 0.4 } },

    // 4. Dr. Xeno
    XENO_FLASK:     { id: 'xeno_flask',     name: '禁断の試薬', icon: '🧪', desc: '状態異常(DoT)威力 +50%', type: 'BOSS_ARTIFACT', color: '#a29bfe', requiredCrewId: 4, stats: { dot_power_pct: 0.5 } },
    XENO_CELL:      { id: 'xeno_cell',      name: '変異細胞', icon: '🧬', desc: '毒/燃焼の毎秒10%分 HP回復', type: 'BOSS_ARTIFACT', color: '#55efc4', requiredCrewId: 4 },

    // 5. Mida
    MIDAS_COIN:     { id: 'midas_coin',     name: 'ミダスの金貨', icon: '🟡', desc: '被弾時 10G失いダメージ無効', type: 'BOSS_ARTIFACT', color: '#fdcb6e', requiredCrewId: 5 },
    MIDAS_BAG:      { id: 'midas_bag',      name: '強欲の袋', icon: '💰', desc: 'アイテム売却価格 2倍', type: 'BOSS_ARTIFACT', color: '#e17055', requiredCrewId: 5 }
};

export const MISC_ITEMS = {
    GOLD: { id: 'gold', name: 'Gold', type: 'GOLD', color: '#f1c40f' }
};

export const UNIQUES = {
    VAMPIRE_FANG: {
        id: 'vampire_fang', name: '吸血の牙', type: ARTIFACT_TYPES.AMULET,
        color: '#8e44ad', description: "攻撃命中時 HP回復 +1 (確率)",
        stats: { life_on_hit: 0.8 } 
    },
    MIDAS_RING: {
        id: 'midas_ring', name: 'ミダスの指輪', type: ARTIFACT_TYPES.RING,
        color: '#f1c40f', description: "Gold獲得量 +40%",
        stats: { gold_gain: 0.4 } 
    },
    OMEGA_PRISM: {
        id: 'omega_prism', name: 'Ωプリズム', type: GEM_TYPES.SUPPORT,
        color: '#ecf0f1', description: "全性能強化 (x1.15)",
        damage_mod: 1.15, speed_mod: 1.15, rate_mod: 1.15 
    }
};

export const SHOP_ITEMS = {
    REPAIR: { id: 'repair', name: '緊急修理', cost: 150, type: 'INSTANT', icon: '🔧', desc: "HP 150回復" },
    // MYSTERY: { id: 'mystery', name: '闇市ガチャ', cost: 500, type: 'INSTANT', icon: '🎲', desc: "ランダム装備" }, // Temporarily removed
    DRONE_ATK: { id: 'drone_atk', name: '攻撃ドローン', cost: 400, type: 'UNIT', duration: 1800, icon: '🛸', desc: "30秒間 自動攻撃" },
    DRONE_COL: { id: 'drone_col', name: '回収ドローン', cost: 300, type: 'UNIT', duration: 3600, icon: '🧹', desc: "60秒間 アイテム回収" },
    CLONE: { id: 'clone', name: '影分身', cost: 800, type: 'UNIT', duration: 900, icon: '👥', desc: "15秒間 火力倍増" }
};

export const ENEMY_TIERS = {
    NORMAL: { id: 'NORMAL', name: 'Normal', color: '#e74c3c', scale: 1.0, hpMod: 1.0, xpMod: 1.0, speedMod: 1.0, chance: 0.0 },
    TANK:   { id: 'TANK',   name: 'Tank',   color: '#95a5a6', scale: 1.4, hpMod: 3.0, xpMod: 2.5, speedMod: 0.5, chance: 0.15 }, 
    ROGUE:  { id: 'ROGUE',  name: 'Rogue',  color: '#34495e', scale: 0.8, hpMod: 0.6, xpMod: 1.5, speedMod: 1.4, chance: 0.30 }, 
    SWARM:  { id: 'SWARM',  name: 'Swarm',  color: '#d35400', scale: 0.6, hpMod: 0.3, xpMod: 0.5, speedMod: 1.1, chance: 0.45 },
    MAGIC:  { id: 'MAGIC',  name: 'Magic',  color: '#3498db', scale: 1.2, hpMod: 2.0, xpMod: 3.0, speedMod: 0.9, chance: 0.60 },
    RARE:   { id: 'RARE',   name: 'Rare',   color: '#f1c40f', scale: 1.5, hpMod: 5.0, xpMod: 8.0, speedMod: 1.1, chance: 0.70 },
    BOSS:   { id: 'BOSS',   name: 'Boss',   color: '#8e44ad', scale: 2.5, hpMod: 50.0,xpMod: 50.0,speedMod: 0.6, chance: 0.98 }
};

export const GEMS = {
    FIREBALL: {
        id: 'fireball', name: '火球', type: GEM_TYPES.ACTIVE,
        color: '#ff4d4d', damage: 50, speed: 7, rate: 45, level: 1 
    },
    ARROW: {
        id: 'arrow', name: '連射矢', type: GEM_TYPES.ACTIVE,
        color: '#f1c40f', damage: 20, speed: 14, rate: 12, level: 1 
    },
    NOVA: {
        id: 'nova', name: '氷結ノヴァ', type: GEM_TYPES.ACTIVE,
        color: '#3498db', damage: 30, speed: 4, rate: 90, level: 1 
    },
    // [Updated] Additional Elements (Integrated from game.js injection)
    POISON: {
        id: 'poison', name: '毒弾', type: GEM_TYPES.ACTIVE,
        color: '#8e44ad', damage: 15, rate: 100, speed: 3.5, level: 1 
    },
    PSYCHIC: {
        id: 'psychic', name: '念動力', type: GEM_TYPES.ACTIVE,
        color: '#e056fd', damage: 10, rate: 45, speed: 7, level: 1 
    },
    WATER: {
        id: 'water', name: '激流', type: GEM_TYPES.ACTIVE,
        color: '#3498db', damage: 20, rate: 30, speed: 9, level: 1 
    },
    ELECTRIC: {
        id: 'electric', name: '電撃', type: GEM_TYPES.ACTIVE,
        color: '#f1c40f', damage: 12, rate: 29, speed: 20, level: 1, chain_count: 3, chain_range: 250 
    },
    ROCK: {
        id: 'rock', name: '隕石', type: GEM_TYPES.ACTIVE,
        color: '#7f8c8d', damage: 90, rate: 70, speed: 8, level: 1 // Buffed: Dmg 60->90, Rate 120->70
    },
    PLANT: {
        id: 'plant', name: '茨', type: GEM_TYPES.ACTIVE,
        color: '#2ecc71', damage: 18, rate: 40, speed: 8, level: 1, pierce_count: 2 
    },

    // Supports
    MULTISHOT: {
        id: 'multishot', name: '拡散', type: GEM_TYPES.SUPPORT,
        color: '#2ecc71', projectiles: 1, damage_mod: 0.7 
    },
    POWER: {
        id: 'power', name: '威力', type: GEM_TYPES.SUPPORT,
        color: '#9b59b6', damage_mod: 1.4 
    },
    SPEED: {
        id: 'speed', name: '高速', type: GEM_TYPES.SUPPORT,
        color: '#1abc9c', speed_mod: 1.4, rate_mod: 0.75 
    },
    PIERCE: {
        id: 'pierce', name: '貫通', type: GEM_TYPES.SUPPORT,
        color: '#e056fd', pierce_count: 1, damage_mod: 0.75
    },
    CHAIN: {
        id: 'chain', name: '連鎖', type: GEM_TYPES.SUPPORT,
        color: '#f39c12', chain_count: 2, damage_mod: 0.75, range: 200
    }
};

export const ARTIFACTS = {
    RUBY_RING: {
        id: 'ruby_ring', name: '赤の指輪', type: ARTIFACT_TYPES.RING,
        color: '#c0392b', description: "ダメージ +15%",
        stats: { damage_pct: 0.15 } 
    },
    EMERALD_RING: {
        id: 'emerald_ring', name: '緑の指輪', type: ARTIFACT_TYPES.RING,
        color: '#27ae60', description: "発射速度 +15%",
        stats: { rate_pct: 0.15 } 
    },
    SAPPHIRE_AMULET: {
        id: 'sapphire_amulet', name: '青のアミュレット', type: ARTIFACT_TYPES.AMULET,
        color: '#2980b9', description: "クリティカル率 +8%",
        stats: { crit_chance: 0.08 } 
    },
    GOLD_AMULET: {
        id: 'gold_amulet', name: '黄金の首飾り', type: ARTIFACT_TYPES.AMULET,
        color: '#f39c12', description: "XP獲得量 +20%",
        stats: { xp_gain: 0.20 } 
    }
};

export const SKILL_TREE_NODES = {
    // --- CENTER: ORIGIN ---
    0: { id: 0, name: "Core System", label: "コア", type: "START", x: 1000, y: 750, maxRank: 1, stats: {}, connections: [1, 2, 3, 4] },

    // --- NORTH: POWER (Red) ---
    1: { id: 1, name: "Brute Force", label: "威力UP", type: "SMALL", x: 1000, y: 650, maxRank: 5, description: "ダメージ +5%/Lv", stats: { damage_pct: 0.05 }, connections: [11, 12] },
    11: { id: 11, name: "Deadly Aim", label: "会心率", type: "SMALL", x: 920, y: 550, maxRank: 5, description: "クリティカル率 +3%/Lv", stats: { crit_chance: 0.03 }, connections: [13] },
    12: { id: 12, name: "Heavy Impact", label: "会心ダメ", type: "SMALL", x: 1080, y: 550, maxRank: 5, description: "クリティカル倍率 +15%/Lv", stats: { crit_damage: 0.15 }, connections: [13] },
    13: { id: 13, name: "Executioner", label: "処刑人", type: "MEDIUM", x: 1000, y: 450, maxRank: 3, description: "ダメージ +8%, クリティカル率 +2%", stats: { damage_pct: 0.08, crit_chance: 0.02 }, connections: [100] },
    
    // KEYSTONE: SYSTEM HACKER
    100: { id: 100, name: "System Hacker", label: "システムハッカー", type: "KEYSTONE", x: 1000, y: 350, maxRank: 1,
           description: "HITダメージ -30% / 状態異常(DoT)威力 +80%（合計DPS目安 +50%）",
           stats: { hit_damage_mul_pct: -0.30, dot_power_pct: 0.80 }, connections: [] },

    // --- SOUTH: SURVIVAL & ECONOMY (Yellow) ---
    2: { id: 2, name: "Reinforced Hull", label: "HP強化", type: "SMALL", x: 1000, y: 850, maxRank: 5, description: "最大HP +150/Lv", stats: { hp_max: 150 }, connections: [21, 22] },
    21: { id: 21, name: "Scavenger", label: "金策", type: "SMALL", x: 920, y: 950, maxRank: 5, description: "Gold/XP獲得 +6%/Lv", stats: { xp_gain: 0.06, gold_gain: 0.06 }, connections: [23] },
    22: { id: 22, name: "Nano Repair", label: "自己修復", type: "SMALL", x: 1080, y: 950, maxRank: 3, description: "Hit時HP回復 +2/Lv", stats: { life_on_hit: 2 }, connections: [23] },
    23: { id: 23, name: "Fortify", label: "装甲化", type: "MEDIUM", x: 1000, y: 1050, maxRank: 3, description: "被ダメージ -4%/Lv", stats: { damage_reduction: 0.04 }, connections: [200] },

    // KEYSTONE: FORTRESS PROTOCOL
    200: { id: 200, name: "Fortress Protocol", label: "フォートレス・プロトコル", type: "KEYSTONE", x: 1000, y: 1150, maxRank: 1,
           description: "最大HP +2200 / 被ダメージ -25% / Hit時HP回復 +3",
           stats: { hp_max: 2200, damage_reduction: 0.25, life_on_hit: 3 }, connections: [] },

    // --- EAST: TECH & SPEED (Green) ---
    3: { id: 3, name: "Rapid Fire", label: "連射", type: "SMALL", x: 1100, y: 750, maxRank: 5, description: "攻撃速度 +5%/Lv", stats: { rate_pct: 0.05 }, connections: [31, 32] },
    31: { id: 31, name: "Ballistics", label: "弾速", type: "SMALL", x: 1200, y: 680, maxRank: 5, description: "弾速 +10%/Lv", stats: { proj_speed_pct: 0.10 }, connections: [33] },
    32: { id: 32, name: "Multitask", label: "並列処理", type: "SMALL", x: 1200, y: 820, maxRank: 3, description: "サポート効果 +5%/Lv", stats: { support_effect: 0.05 }, connections: [33] },
    33: { id: 33, name: "Network", label: "ネットワーク", type: "MEDIUM", x: 1300, y: 750, maxRank: 3, description: "連鎖範囲 +20%, 攻撃速度 +3%", stats: { chain_range_pct: 0.2, rate_pct: 0.03 }, connections: [300] },

    // KEYSTONE: DRONE ORCHESTRATOR
    300: { id: 300, name: "Drone Orchestrator", label: "ドローン統制", type: "KEYSTONE", x: 1400, y: 750, maxRank: 1,
           description: "サポート効果 +25% / サポートGEMレベル +2 / 攻撃速度 +10%",
           stats: { support_effect: 0.25, support_level_bonus: 2, rate_pct: 0.10 }, connections: [] },

    // --- WEST: MAGIC & AOE (Blue) ---
    4: { id: 4, name: "Expansion", label: "範囲拡大", type: "SMALL", x: 900, y: 750, maxRank: 5, description: "範囲サイズ +8%/Lv", stats: { aoe_pct: 0.08 }, connections: [41, 42] },
    41: { id: 41, name: "Elemental Focus", label: "属性強化", type: "SMALL", x: 800, y: 680, maxRank: 5, description: "ダメージ +6%, 範囲 +2%", stats: { damage_pct: 0.06, aoe_pct: 0.02 }, connections: [43] },
    42: { id: 42, name: "Overclock", label: "OC", type: "SMALL", x: 800, y: 820, maxRank: 3, description: "攻撃速度 +4%, 弾速 +5%", stats: { rate_pct: 0.04, proj_speed_pct: 0.05 }, connections: [43] },
    43: { id: 43, name: "Cataclysm", label: "カタクリズム", type: "MEDIUM", x: 700, y: 750, maxRank: 3, description: "範囲サイズ +15%, ダメージ +5%", stats: { aoe_pct: 0.15, damage_pct: 0.05 }, connections: [400] },

    // KEYSTONE: ARC REACTOR (Buffed: x1.2 -> x1.5)
    400: { id: 400, name: "Arc Reactor", label: "アーク炉心", type: "KEYSTONE", x: 600, y: 750, maxRank: 1,
           description: "クリティカル率が0になる代わりに、範囲 +30% / 連鎖範囲 +30% / 最終ダメージ x1.5",
           stats: { crit_chance: -10.0, aoe_pct: 0.30, chain_range_pct: 0.30, final_damage_mul: 1.5 }, connections: [] }
};

export const STAGE_CONFIG = [
    { level: 1, name: "SURVIVAL OPS", waveCount: 10, enemyScale: 1.0 }
];

export const CREW_DATA = {
    1: { 
        id: 1, name: "Cmdr. Wolf", job: "司令官", imgBase: "Character/1",
        desc: "全ダメージ +20%", stats: { damage_pct: 0.20 },
        ability: { id: 'alpha_command', name: 'Alpha Command', desc: '12秒間 ダメージ+50% / 会心+20%', duration: 720, cd: 3600 }
    },
    2: { 
        id: 2, name: "Pilot Luna", job: "操縦士", imgBase: "Character/2",
        desc: "攻撃速度 +20%", stats: { rate_pct: 0.20 },
        ability: { id: 'hyper_thruster', name: 'Hyper Thruster', desc: '8秒間 攻撃速度+100%', duration: 480, cd: 2700 }
    },
    3: { 
        id: 3, name: "Eng. R-22", job: "技師ロボ", imgBase: "Character/3",
        desc: "クリティカル率 +10% / 範囲 +15%", stats: { crit_chance: 0.10, aoe_pct: 0.15 },
        ability: { id: 'emp_blast', name: 'EMP Blast', desc: '全画面攻撃 + スタン付与', duration: 0, cd: 2400 }
    },
    4: { 
        id: 4, name: "Dr. Xeno", job: "科学者", imgBase: "Character/4",
        desc: "被ダメージ -15% / HP自然回復", stats: { damage_reduction: 0.15, hp_regen: 2 },
        ability: { id: 'meltdown_rain', name: 'Meltdown Rain', desc: '全敵を溶解(被ダメ2倍) + 猛毒', duration: 600, cd: 3600 }
    },
    5: { 
        id: 5, name: "Trader Mida", job: "闇商人", imgBase: "Character/5",
        desc: "Gold/XP獲得 +30%", stats: { gold_gain: 0.30, xp_gain: 0.30 },
        ability: { id: 'bribe', name: 'Bribe (賄賂)', desc: '敵を消滅させGoldに変換', duration: 0, cd: 3000 }
    }
};

export const UI_STRINGS = {
    LEVEL_UP: "SYSTEM UPGRADE",
    GAME_OVER: "SIGNAL LOST",
    STAGE_CLEAR: "SECTOR SECURED",
    EMPTY_SLOT: "EMPTY"
};

/** 演出・スキル効果用定数 (Moved from game.js) */
/** シナジー図鑑用メタデータ */
export const SYNERGY_METADATA = {
    'steam': { name: "蒸発", combo: ["BURN", "SOAKED"], desc: "最大HP15%の固定ダメージを与える。" },
    'toxic_detonation': { name: "毒爆", combo: ["BURN", "POISON"], desc: "毒スタックに応じた大爆発を起こす。" },
    'electro_charged': { name: "感電", combo: ["SHOCK", "SOAKED"], desc: "周囲の敵に強力な連鎖電撃を放つ。" },
    'meltdown': { name: "融解", combo: ["BURN", "FREEZE"], desc: "防御を貫通し、最大HP25%の超ダメージ。" },
    'overload': { name: "過負荷", combo: ["BURN", "SHOCK"], desc: "範囲爆発と共に敵を大きくノックバックさせる。" },
    'superconduct': { name: "超電導", combo: ["FREEZE", "SHOCK"], desc: "広範囲ダメージと共に氷の破片を飛散させる。" },
    'corrosion': { name: "腐食", combo: ["POISON", "SOAKED"], desc: "持続的な酸のエリアを生成し、防御力を下げる。" },
    'plague': { name: "伝染", combo: ["POISON", "SHOCK"], desc: "電撃を媒介にして毒スタックを周囲に拡散する。" },
    'glacier': { name: "氷河", combo: ["FREEZE", "SOAKED"], desc: "凍結時間を大幅に延長し、砕氷ダメージを与える。" },
    'chaos_flare': { name: "カオスフレア", combo: ["CONFUSION", "BURN"], desc: "混乱した敵が通った跡に炎の海を生成する。" },
    'chaos_miasma': { name: "カオスマイズマ", combo: ["CONFUSION", "POISON"], desc: "混乱した敵が周囲に猛毒の霧を撒き散らす。" },
    'chaos_storm': { name: "カオスストーム", combo: ["CONFUSION", "SHOCK"], desc: "混乱した敵の周囲に継続的な放電エリアを生成。" },
    'chaos_frost': { name: "カオスフロスト", combo: ["CONFUSION", "FREEZE"], desc: "混乱した敵が周囲を凍りつかせる冷気を放つ。" }
};

export const EFFECT_CONSTANTS = {
    PARTICLE_COUNT: 8,
    BASE_CRIT_CHANCE: 0.05,
    BASE_CRIT_MULTIPLIER: 1.5,

    BURN_DURATION: 180,
    BURN_TICK_RATE: 30,
    BURN_DAMAGE_RATIO: 0.2,

    NOVA_RADIUS: 120,
    FIREBALL_RADIUS: 100, 
    FREEZE_CHANCE: 0.4,
    FREEZE_DURATION: 120,
    SHATTER_PROJECTILE_COUNT: 12,
    SHATTER_SPEED: 12,
    MULTISHOT_SPREAD_ANGLE: 0.26, 

    COLOR_CRIT: "#f1c40f",
    COLOR_NORMAL: "#ffffff",
    COLOR_BURN: "#e67e22",
    COLOR_FREEZE: "#74b9ff",
    COLOR_LEVELUP: "#00d2d3",
    COLOR_TARGET: "#ff0000",
    COLOR_CHAIN: "#f39c12"
};
▲▲▲ FILE END: constants.js ▲▲▲

▼▼▼ FILE START: effects.js ▼▼▼
/**
 * @fileoverview 演出エフェクト定義 (FloatingText, ParticleEffect)
 * 憲法準拠: 1文字変数禁止、型ヒント必須。
 */

/** エフェクト用ローカル定数 */
const EFFECT_DEFAULTS = {
    TEXT_LIFE_DECAY: 0.02,
    PARTICLE_LIFE_DECAY: 0.05
};

/**
 * ダメージポップアップなどの浮遊テキスト (物理挙動版)
 */
export class FloatingText {
    /**
     * @param {number} x - X座標
     * @param {number} y - Y座標
     * @param {string} text - 表示テキスト
     * @param {string} color - 色コード
     * @param {number} fontSize - フォントサイズ
     */
    constructor(x, y, text, color, fontSize = 20) {
        this.positionX = x;
        this.positionY = y;
        this.text = text;
        this.color = color;
        this.fontSize = fontSize;
        this.life = 1.0;

        // 物理パラメータ: 左右にランダムに跳ね、上に飛び出す
        this.velocityX = (Math.random() - 0.5) * 6; 
        this.velocityY = -Math.random() * 5 - 3;   
        this.gravity = 0.25; // 下方向に引っ張る力
    }

    update() {
        this.positionX += this.velocityX;
        this.positionY += this.velocityY;
        this.velocityY += this.gravity; // 重力を加算

        this.life -= EFFECT_DEFAULTS.TEXT_LIFE_DECAY;
    }

    /**
     * @param {CanvasRenderingContext2D} context 
     */
    draw(context) {
        if (this.life <= 0) return;
        context.save();
        context.globalAlpha = Math.max(0, this.life);
        context.fillStyle = this.color;
        context.font = `bold ${this.fontSize}px 'Segoe UI', sans-serif`;

        // 文字の縁取り（読みやすさ向上）
        context.strokeStyle = "#000";
        context.lineWidth = 3;
        context.textAlign = "center";
        context.strokeText(this.text, this.positionX, this.positionY);
        context.fillText(this.text, this.positionX, this.positionY);
        context.restore();
    }
}

/**
 * 汎用パーティクルエフェクト
 */
export class ParticleEffect {
    /**
     * @param {number} x - X座標
     * @param {number} y - Y座標
     * @param {string} color - 色コード
     * @param {number} speed - 拡散速度
     */
    constructor(x, y, color, speed = 8) {
        this.positionX = x;
        this.positionY = y;
        this.color = color;
        this.size = Math.random() * 5 + 3;
        
        const angle = Math.random() * Math.PI * 2;
        const velocity = Math.random() * speed;
        this.velocityX = Math.cos(angle) * velocity;
        this.velocityY = Math.sin(angle) * velocity;
        this.life = 1.0;
    }

    update() {
        this.positionX += this.velocityX;
        this.positionY += this.velocityY;
        this.life -= EFFECT_DEFAULTS.PARTICLE_LIFE_DECAY;
        this.size *= 0.95;
    }

    /**
     * @param {CanvasRenderingContext2D} context 
     */
    draw(context) {
        context.save();
        context.globalAlpha = Math.max(0, this.life);
        context.fillStyle = this.color;
        context.beginPath();
        context.rect(this.positionX, this.positionY, this.size, this.size);
        context.fill();
        context.restore();
    }
}

/**
 * アーケード風の広がる衝撃波エフェクト
 */
export class ShockwaveEffect {
    /**
     * @param {number} positionX - X座標
     * @param {number} positionY - Y座標
     * @param {string} colorCode - 色コード
     * @param {number} limitRadius - 最大半径
     */
    constructor(positionX, positionY, colorCode, limitRadius) {
        this.positionX = positionX;
        this.positionY = positionY;
        this.colorCode = colorCode;
        this.currentRadius = 0;
        this.limitRadius = limitRadius;
        this.currentLife = 1.0;
        this.fadeSpeed = 0.04;
    }

    update() {
        this.currentLife -= this.fadeSpeed;
        // 最初は速く、徐々にゆっくり広がるイージング
        this.currentRadius += (this.limitRadius - this.currentRadius) * 0.25;
    }

    /**
     * @param {CanvasRenderingContext2D} context 
     */
    draw(context) {
        if (this.currentLife <= 0) return;
        context.save();
        context.beginPath();
        context.arc(this.positionX, this.positionY, this.currentRadius, 0, Math.PI * 2);
        context.strokeStyle = this.colorCode;
        // 半径が広がるにつれて線が細くなる
        context.lineWidth = 5 * this.currentLife;
        context.globalAlpha = this.currentLife;
        context.shadowBlur = 15;
        context.shadowColor = this.colorCode;
        context.stroke();
        context.restore();
    }
}

/**
 * 宇宙背景と星空の描画管理クラス
 */
export class StarField {
    /**
     * @param {number} width - 画面幅
     * @param {number} height - 画面高さ
     */
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.stars = [];
        this.numStars = 100;
        this.nebulaOffset = 0;

        // 星の初期化
        for (let i = 0; i < this.numStars; i++) {
            this.stars.push(this.createStar());
        }
    }

    createStar() {
        return {
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            size: Math.random() * 1.5 + 0.5,
            speed: Math.random() * 0.8 + 0.2, // 個別の移動速度係数
            brightness: Math.random(),
            twinkleSpeed: Math.random() * 0.05 + 0.01
        };
    }

    /**
     * @param {number} waveNumber - 現在のWave数（速度調整用）
     */
    update(waveNumber) {
        // Waveが進むほど全体の流れる速度が上がる
        const baseSpeed = 0.5 + (waveNumber * 0.15); 
        this.nebulaOffset += 0.2;

        this.stars.forEach(star => {
            star.y += star.speed * baseSpeed;
            // 瞬きアニメーション
            star.brightness += star.twinkleSpeed;
            if (star.brightness > 1 || star.brightness < 0.3) {
                star.twinkleSpeed *= -1;
            }

            // 画面外に出たら上に戻す
            if (star.y > this.height) {
                star.y = 0;
                star.x = Math.random() * this.width;
            }
        });
    }

    /**
     * @param {CanvasRenderingContext2D} context
     * @param {number} waveNumber - 現在のWave数（背景色変更用）
     */
    draw(context, waveNumber) {
        // 背景グラデーション (Waveごとのテーマカラー)
        let topColor = "#050608";
        let bottomColor = "#1f2833";

        if (waveNumber >= 4 && waveNumber <= 6) {
            // 中盤: 不穏な赤紫
            topColor = "#1a0b10"; 
            bottomColor = "#2c1e20";
        } else if (waveNumber >= 7 && waveNumber <= 9) {
            // 終盤: 神秘的な紫紺
            topColor = "#100b1a"; 
            bottomColor = "#201e2c";
        } else if (waveNumber >= 10) {
            // ラスト: 激しい赤黒
            topColor = "#2c0505"; 
            bottomColor = "#000000";
        }

        const grad = context.createLinearGradient(0, 0, 0, this.height);
        grad.addColorStop(0, topColor);
        grad.addColorStop(1, bottomColor);

        context.fillStyle = grad;
        context.fillRect(0, 0, this.width, this.height);

        // 星雲っぽい演出 (簡易的なノイズレイヤーの代わりに円形グラデーションを合成)
        context.save();
        context.globalCompositeOperation = "screen";
        context.globalAlpha = 0.1;

        // ゆっくり動く光のモヤ
        const nebulaX = (Math.sin(this.nebulaOffset * 0.01) * this.width * 0.5) + this.width/2;
        const nebulaY = (this.nebulaOffset % this.height);
        const nebulaGrad = context.createRadialGradient(nebulaX, nebulaY, 50, nebulaX, nebulaY, 400);
        nebulaGrad.addColorStop(0, waveNumber >= 10 ? "#e74c3c" : "#3498db");
        nebulaGrad.addColorStop(1, "transparent");

        context.fillStyle = nebulaGrad;
        context.fillRect(0, 0, this.width, this.height);
        context.restore();

        // 星の描画
        context.fillStyle = "#ffffff";
        this.stars.forEach(star => {
            context.globalAlpha = Math.max(0, Math.min(1, star.brightness));
            context.beginPath();
            context.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            context.fill();
        });
        context.globalAlpha = 1.0;
    }
}
▲▲▲ FILE END: effects.js ▲▲▲

▼▼▼ FILE START: game.js ▼▼▼
/**
 * @fileoverview 究極の防衛ゲーム: Project OVERLORD Core Logic
 * 変更点: モジュール分割によるリファクタリング (Utils, Effects, UI分離)
 * 憲法準拠: 1文字変数禁止、型ヒント必須、定数管理徹底。
 */
import { GAME_SETTINGS, GEMS, GEM_TYPES, ARTIFACTS, ARTIFACT_TYPES, BOSS_ARTIFACTS, MISC_ITEMS, UNIQUES, SHOP_ITEMS, ENEMY_TIERS, STAGE_CONFIG, BOSS_WAVES, UI_STRINGS, CREW_DATA, EFFECT_CONSTANTS } from './constants.js';
import { generateUuid, createItemInstance, loadGameAssets, GAME_ASSETS } from './utils.js';
import { FloatingText, ParticleEffect, ShockwaveEffect, StarField } from './effects.js';
import { audioManager } from './audio-manager.js';
import { refreshInventoryInterface, updateMainScreenLoadout, updateHudDisplay, refreshShopInterface } from './ui.js';

/** ゲーム内描画・計算用定数 */
const RENDER_CONSTANTS = {
    PROJECTILE_SIZE: 10,
    ENEMY_HITBOX_SIZE: 30,
    TURRET_POS_X: GAME_SETTINGS.SCREEN_WIDTH / 2, 
    TURRET_POS_Y: GAME_SETTINGS.CASTLE_Y,         
    EFFECT_SHADOW_BLUR: 20,
    DROP_SIZE: 24,          
    DROP_FLOAT_SPEED: 0.05, 
    DROP_FLOAT_RANGE: 5     
};

/** 内部ロジック用定数 */
const SELECTION_CRITERIA = {
    MIN_DIST: "MIN_DIST",
    MAX_HP: "MAX_HP",
    MIN_HP: "MIN_HP"
};

/** フィールド上に落ちているアイテムクラス */
class DropItem {
    constructor(x, y, itemTemplate) {
        this.uuid = generateUuid();
        this.x = x;
        this.y = y;
        this.baseY = y;
        this.itemTemplate = itemTemplate;
        this.floatTimer = Math.random() * Math.PI * 2;
        this.creationTime = Date.now();
    }

    update() {
        this.floatTimer += RENDER_CONSTANTS.DROP_FLOAT_SPEED;
        this.y = this.baseY + Math.sin(this.floatTimer) * RENDER_CONSTANTS.DROP_FLOAT_RANGE;
    }

    draw(context) {
        context.save();
        context.translate(this.x, this.y);
        context.shadowBlur = 10;
        context.shadowColor = this.itemTemplate.color;
        
        context.fillStyle = "rgba(20, 20, 30, 0.8)";
        context.strokeStyle = this.itemTemplate.color;
        context.lineWidth = 2;
        const size = RENDER_CONSTANTS.DROP_SIZE;
        const halfSize = size / 2;
        context.beginPath();
        context.roundRect(-halfSize, -halfSize, size, size, 4);
        context.fill();
        context.stroke();

        context.shadowBlur = 0;
        context.fillStyle = "#fff";
        context.font = "14px sans-serif";
        context.textAlign = "center";
        context.textBaseline = "middle";
        
        let icon = "?";
        if (this.itemTemplate.type === GEM_TYPES.ACTIVE) icon = "⚔️";
        else if (this.itemTemplate.type === GEM_TYPES.SUPPORT) icon = "💠";
        else if (this.itemTemplate.type === ARTIFACT_TYPES.RING) icon = "💍";
        else if (this.itemTemplate.type === ARTIFACT_TYPES.AMULET) icon = "🧿";
        else if (this.itemTemplate.type === 'GOLD') icon = "💰";

        context.fillText(icon, 0, 1);
        context.restore();
    }
}

/** ゲームエンジンクラス: 全体の状態とロジックを統括 */
class GameEngine {
    constructor() {
        this.baseIntegrity = GAME_SETTINGS.BASE_MAX_HP;
        this.experiencePoints = 0;
        this.currentLevel = 1;
        this.skillPoints = 0; 
        this.allocatedNodes = { 0: 1 };

        this.isPaused = false;
        this.isGameOver = false;
        this.currentStageIndex = 0;
        this.currentWaveNumber = 1;
        this.waveProgress = 0;      
        this.waveQuota = 40; // 10 -> 40: Wave 1のプレイ時間を約1分半に延長
        this.isBossWave = false;
        this.gold = 0;

        /** @type {(Object|null)[]} */
        this.equippedGems = [null, null, null];
        this.altGems = [null, null, null]; 
        this.currentLoadoutId = 1;
        /** @type {Object} */
        this.equippedArtifacts = {
            [ARTIFACT_TYPES.RING]: null,
            [ARTIFACT_TYPES.AMULET]: null
        };
        this.inventory = [];
        this.activeDrops = [];
        this.activeSupportUnits = []; 
        this.manualTargetId = null;
        this.inventoryDirty = false; 
        this.purchasedShopItems = [];
        this.artifacts = []; // Obtained Boss Artifacts

        this.stats = {
            damage_pct: 0, rate_pct: 0, crit_chance: 0, xp_gain: 0,
            hp_max: 0, speed_pct: 0, proj_speed_pct: 0, support_effect: 0, self_damage: 0
        };
        
        this.energy = 100;
        this.maxEnergy = 100;
        this.isShieldActive = false;
        this.shieldTimer = 0;
        this.shieldImpactTimer = 0; 
        this.emergencyCooldown = 0; // For Emergency Core
        this.timeStopTimer = 0; // Artifact: Time Stopper

        // Crew System
        this.selectedCrew = []; // Array of Crew IDs (e.g. [1, 2])
        this.crewStatusSuffix = 'a'; // 'a'=Normal, 'b'=Damage, 'c'=Pinch
        this.crewDamageTimer = 0;
        this._lastIntegrity = this.baseIntegrity;

        this.crewCooldowns = {};   // { crewId: framesRemaining }
        this.crewActiveBuffs = {}; // { crewId: framesRemaining }
        this.bonusStats = {};      // Permanent stats from Level Up choices

        // [Patch] Game Speed Control
        this.timeScale = 0.7; // Default 0.7 (Slow)
        this.speedLevel = 0;  // 0: x0.7, 1: x1.0, 2: x2.0
        this.accumulator = 0;

        // [Stats for Results]
        this.startTime = Date.now();
        this.damageLog = {}; // { sourceId: totalDamage }
        this.waveLog = [{ wave: 1, time: 0 }]; // { wave, time }
        this.hitStopFrames = 0; // ヒットストップ用カウンタ
    }

    recordDamage(sourceId, amount) {
        if (!sourceId) return;
        if (!this.damageLog[sourceId]) this.damageLog[sourceId] = 0;
        this.damageLog[sourceId] += amount;
    }

    toggleGameSpeed() {
        this.speedLevel = (this.speedLevel + 1) % 3;
        if (this.speedLevel === 0) this.timeScale = 0.7;
        else if (this.speedLevel === 1) this.timeScale = 1.0;
        else if (this.speedLevel === 2) this.timeScale = 2.0;

        const btn = document.getElementById('speed-btn');
        if (btn) {
            // Internal 0.7 -> Display x1.0 (Base)
            // Internal 1.0 -> Display x1.5
            // Internal 2.0 -> Display x3.0
            btn.innerHTML = this.speedLevel === 0 ? "▶️ x1.0" : (this.speedLevel === 1 ? "⏩️ x1.5" : "⏩️⏩️ x3.0");
        }
    }

    reset() {
        this.baseIntegrity = GAME_SETTINGS.BASE_MAX_HP;
        this.experiencePoints = 0;
        this.currentLevel = 1;
        this.skillPoints = 0;
        this.allocatedNodes = { 0: 1 };
        this.bonusStats = {}; 
        this.recalcStats();

        this.isPaused = false;
        this.isGameOver = false;
        this.currentStageIndex = 0;
        this.currentWaveNumber = 1;
        this.waveProgress = 0;
        this.waveQuota = 40;
        this.isBossWave = false;
        this.gold = 0;
        
        this.energy = 100;
        this.maxEnergy = 100;
        this.isShieldActive = false;
        this.shieldTimer = 0;
        this.shieldImpactTimer = 0;
        this.timeStopTimer = 0;

        this.equippedGems = [null, null, null];
        this.altGems = [null, null, null];
        this.currentLoadoutId = 1;
        this.equippedArtifacts = {
            [ARTIFACT_TYPES.RING]: null,
            [ARTIFACT_TYPES.AMULET]: null
        };
        this.inventory = [];
        this.activeDrops = [];
        this.activeSupportUnits = [];
        activeZoneEffects = [];
        activeShockwaves = [];
        this.manualTargetId = null;

        // Reset speed logic (keep setting or reset? defaulting to reset for safety)
        this.timeScale = 0.7;
        this.speedLevel = 0;
        this.accumulator = 0;
        const btn = document.getElementById('speed-btn');
        if (btn) btn.innerHTML = "▶️ x1.0";
    }

    /** スキルツリーのステータス再計算 (Rank System対応) */
    recalcStats() {
        this.stats = {
            damage_pct: 0, rate_pct: 0, crit_chance: 0, xp_gain: 0,
            hp_max: 0, speed_pct: 0, proj_speed_pct: 0, support_effect: 0, self_damage: 0,
            life_on_hit: 0, gold_gain: 0, aoe_pct: 0, crit_damage: 0, damage_reduction: 0,
            chain_range_pct: 0, support_level_bonus: 0,
            final_damage_mul: 0, self_damage_pct: 0,
            hit_damage_mul_pct: 0, dot_power_pct: 0
        };

        // Tree Stats (Rank Multiplier)
        Object.entries(this.allocatedNodes).forEach(([nodeId, rank]) => {
            const node = SKILL_TREE_NODES[nodeId];
            if (node && node.stats) {
                Object.entries(node.stats).forEach(([key, val]) => {
                    if (this.stats[key] !== undefined) this.stats[key] += (val * rank);
                });
            }
        });

        // Artifact Stats
        Object.values(this.equippedArtifacts).forEach(art => {
            if (art && art.stats) {
                Object.entries(art.stats).forEach(([key, val]) => {
                    if (this.stats[key] !== undefined) this.stats[key] += val;
                });
            }
        });

        // HP Update
        const finalMaxHP = GAME_SETTINGS.BASE_MAX_HP + this.stats.hp_max;
        if (this.baseIntegrity > finalMaxHP) this.baseIntegrity = finalMaxHP;
    }
}
// 補足: GameEngineは大きく、全メソッド書き直しはトークン消費が激しいため、
// クラスメソッドは元のロジックを維持しつつ、UI呼び出し部分を修正します。

// --- 修正版 GameEngine ---
import { SKILL_TREE_NODES } from './constants.js'; // Ensure this is available

Object.assign(GameEngine.prototype, {
    recalcStats() {
        this.stats = {
            damage_pct: 0, rate_pct: 0, crit_chance: 0, xp_gain: 0,
            hp_max: 0, speed_pct: 0, proj_speed_pct: 0, support_effect: 0, self_damage: 0,
            life_on_hit: 0, gold_gain: 0, aoe_pct: 0, crit_damage: 0, damage_reduction: 0,
            chain_range_pct: 0, support_level_bonus: 0,
            final_damage_mul: 0, self_damage_pct: 0,
            hit_damage_mul_pct: 0, dot_power_pct: 0,
            chain_count: 0, shield_bash_mul: 0, mp_regen_pct: 0, // Artifact stats
            hp_regen: 0, // Crew stats
            damage_taken_mul: 0
        };

        // Bonus Stats (Level Up Fillers)
        Object.entries(this.bonusStats).forEach(([key, val]) => {
            if (this.stats[key] !== undefined) this.stats[key] += val;
        });

        // Crew Stats & Ability Buffs
        this.selectedCrew.forEach(crewId => {
            const crew = CREW_DATA[crewId];
            if (crew) {
                // Passive Stats
                if (crew.stats) {
                    Object.entries(crew.stats).forEach(([key, val]) => {
                        if (this.stats[key] !== undefined) this.stats[key] += val;
                    });
                }

                // Active Buffs (Wolf / Luna)
                if (this.crewActiveBuffs[crewId] > 0) {
                    if (crew.id === 1) { // Wolf: Alpha Command
                        this.stats.damage_pct += 0.50;
                        this.stats.crit_chance += 0.20;
                    } else if (crew.id === 2) { // Luna: Hyper Thruster
                        this.stats.rate_pct += 1.00;
                    }
                }
            }
        });

        Object.entries(this.allocatedNodes).forEach(([nodeId, rank]) => {
            const node = SKILL_TREE_NODES[nodeId];
            if (node && node.stats) {
                Object.entries(node.stats).forEach(([key, val]) => {
                    if (this.stats[key] !== undefined) this.stats[key] += (val * rank);
                });
            }
        });

        Object.values(this.equippedArtifacts).forEach(art => {
            if (art && art.stats) {
                Object.entries(art.stats).forEach(([key, val]) => {
                    if (this.stats[key] !== undefined) this.stats[key] += val;
                });
            }
        });

        // Boss Artifacts Stats
        this.artifacts.forEach(art => {
            if (art && art.stats) {
                Object.entries(art.stats).forEach(([key, val]) => {
                    if (this.stats[key] !== undefined) this.stats[key] += val;
                });
            }
            // Dynamic Stats: Merchant Soul (1% dmg per 100G)
            if (art.id === 'merchant_soul') {
                this.stats.damage_pct += Math.floor(this.gold / 100) * 0.01;
            }
        });

        const finalMaxHP = GAME_SETTINGS.BASE_MAX_HP + this.stats.hp_max;
        if (this.baseIntegrity > finalMaxHP) this.baseIntegrity = finalMaxHP;
    },

    allocateNode(nodeId) {
        const node = SKILL_TREE_NODES[nodeId];
        if (!node) return false;

        if (this.skillPoints <= 0) {
            if (window.showToast) window.showToast("SPが不足しています", "#e74c3c");
            return false;
        }

        const currentRank = this.allocatedNodes[nodeId] || 0;
        const maxRank = node.maxRank || 1;

        if (currentRank >= maxRank) {
            if (window.showToast) window.showToast("これ以上強化できません", "#f1c40f");
            return false;
        }

        let connected = false;
        if (currentRank > 0) {
            connected = true;
        } else {
            Object.keys(this.allocatedNodes).forEach(ownedId => {
                const oid = parseInt(ownedId);
                if (this.allocatedNodes[oid] > 0) {
                     if (SKILL_TREE_NODES[oid].connections.includes(nodeId)) connected = true;
                     if (node.connections.includes(oid)) connected = true;
                }
            });
        }

        if (connected) {
            this.allocatedNodes[nodeId] = currentRank + 1;
            this.skillPoints--;
            this.recalcStats();
            if (window.showToast) window.showToast(`${node.label || node.name} 強化完了 (Lv.${currentRank + 1})`, "#2ecc71");
            return true;
        } else {
            if (window.showToast) window.showToast("隣接するノードを取得してください", "#e74c3c");
            return false;
        }
    },

    addItemToInventory(templateItem, level = 1) {
        const actualLevel = templateItem.forcedLevel || level;

        // [Patch] Smart Fuse Check: Allow pickup if inventory is full but fusion is possible
        // 既存のインベントリ＋装備品をスキャンして、今回拾うアイテムを含めれば3つになるか確認
        let canFuse = false;
        if (this.inventory.length >= GAME_SETTINGS.INVENTORY_CAPACITY) {
            const sameItems = this.inventory.filter(i => i.id === templateItem.id && i.level === actualLevel).length;
            const equippedSame = [...this.equippedGems, ...this.altGems].filter(i => i && i.id === templateItem.id && i.level === actualLevel).length;
            const artifactSame = Object.values(this.equippedArtifacts).filter(i => i && i.id === templateItem.id && i.level === actualLevel).length;

            if ((sameItems + equippedSame + artifactSame) >= 2) {
                canFuse = true; // 合成可能なら満杯でも許可
            } else {
                activeFloatingTexts.push(new FloatingText(RENDER_CONSTANTS.TURRET_POS_X, GAME_SETTINGS.CASTLE_Y - 100, "INVENTORY FULL", "#e74c3c", 20));
                return;
            }
        }

        const cleanTemplate = { ...templateItem };
        delete cleanTemplate.forcedLevel; 

        const newItem = createItemInstance(cleanTemplate, actualLevel);
        this.inventory.push(newItem);

        // Always try to fuse immediately
        this.fuseItems();
        refreshInventoryInterface();
    },

    swapLoadout() {
        // [Patch] Prevent swap if target loadout has no active weapon (slot 0)
        // altGems is the "next" loadout because we are about to swap
        const nextMainGem = this.altGems[0];

        if (!nextMainGem) {
            activeFloatingTexts.push(new FloatingText(RENDER_CONSTANTS.TURRET_POS_X, GAME_SETTINGS.CASTLE_Y - 80, "NO WEAPON!", "#e74c3c", 20));
            return;
        }

        const temp = this.equippedGems;
        this.equippedGems = this.altGems;
        this.altGems = temp;
        this.currentLoadoutId = (this.currentLoadoutId === 1) ? 2 : 1;
        this.recalcStats();
        updateMainScreenLoadout();
        refreshInventoryInterface();
        const color = this.currentLoadoutId === 1 ? "#00d2d3" : "#ff9f43";
        activeFloatingTexts.push(new FloatingText(RENDER_CONSTANTS.TURRET_POS_X, GAME_SETTINGS.CASTLE_Y - 80, `LOADOUT ${this.currentLoadoutId}`, color, 20));
    },

    selectLoadout(targetId) {
        if (this.currentLoadoutId !== targetId) {
            this.swapLoadout();
        }
    },

    equipItem(uuid, slotIndex) {
            const invIndex = this.inventory.findIndex(i => i.uuid === uuid);
            if (invIndex === -1) return;
            const item = this.inventory[invIndex];

            let targetArray = null;
            let targetKey = null;
            let targetSlotRef = null;

            // slotIndexが文字列の場合 (MAIN_0, SUB_1, RING, AMULET)
            if (typeof slotIndex === 'string') {
                if (slotIndex.startsWith('MAIN_')) {
                    const idx = parseInt(slotIndex.split('_')[1]);
                    if (idx === 0 && item.type !== GEM_TYPES.ACTIVE) return;
                    if (idx > 0 && item.type !== GEM_TYPES.SUPPORT) return;
                    targetArray = this.equippedGems;
                    targetKey = idx;
                } 
                else if (slotIndex.startsWith('SUB_')) {
                    const idx = parseInt(slotIndex.split('_')[1]);
                    if (idx === 0 && item.type !== GEM_TYPES.ACTIVE) return;
                    if (idx > 0 && item.type !== GEM_TYPES.SUPPORT) return;
                    targetArray = this.altGems;
                    targetKey = idx;
                } 
                else if (slotIndex === 'RING' || slotIndex === 'AMULET') {
                    const typeCheck = slotIndex === 'RING' ? ARTIFACT_TYPES.RING : ARTIFACT_TYPES.AMULET;
                    if (item.type !== typeCheck) return;
                    targetSlotRef = this.equippedArtifacts;
                    targetKey = slotIndex;
                }
            }
            // 数値の場合（レガシー互換/簡易指定）: 現在のメイン装備を対象とする
            else if (typeof slotIndex === 'number') {
                if (slotIndex === 0 && item.type === GEM_TYPES.ACTIVE) {
                    targetArray = this.equippedGems; targetKey = 0;
                } else if ((slotIndex === 1 || slotIndex === 2) && item.type === GEM_TYPES.SUPPORT) {
                    targetArray = this.equippedGems; targetKey = slotIndex;
                }
            }

            // 装備実行処理
            if (targetArray || targetSlotRef) {
                const existing = targetArray ? targetArray[targetKey] : targetSlotRef[targetKey];
                if (existing) {
                    this.inventory.push(existing);
                }

                if (targetArray) targetArray[targetKey] = item;
                else targetSlotRef[targetKey] = item;

                this.inventory.splice(invIndex, 1);
            }

            this.recalcStats(); 
            refreshInventoryInterface();
            updateMainScreenLoadout();
        },

    unequipByUuid(uuid) {
        if (!uuid) return;
        let unequippedItem = null;

        for (let i = 0; i < 3; i++) {
            if (this.equippedGems[i] && this.equippedGems[i].uuid === uuid) {
                unequippedItem = this.equippedGems[i];
                this.equippedGems[i] = null;
            }
        }
        // altGems は swapLoadout で中身が入れ替わるだけなので、実体は equippedGems と共有しない運用であればここもチェック
        for (let i = 0; i < 3; i++) {
            if (this.altGems[i] && this.altGems[i].uuid === uuid) {
                unequippedItem = this.altGems[i];
                this.altGems[i] = null;
            }
        }
        if (this.equippedArtifacts.RING && this.equippedArtifacts.RING.uuid === uuid) {
            unequippedItem = this.equippedArtifacts.RING;
            this.equippedArtifacts.RING = null;
        }
        if (this.equippedArtifacts.AMULET && this.equippedArtifacts.AMULET.uuid === uuid) {
            unequippedItem = this.equippedArtifacts.AMULET;
            this.equippedArtifacts.AMULET = null;
        }

        if (unequippedItem) {
            this.inventory.push(unequippedItem);
        }

        this.recalcStats();
        refreshInventoryInterface();
        updateMainScreenLoadout();
    },

    salvageItem(uuid) {
        const index = this.inventory.findIndex(i => i.uuid === uuid);
        if (index === -1) return;
        const item = this.inventory[index];
        this.unequipByUuid(uuid);
        this.inventory.splice(index, 1);
        const xpGain = (GAME_SETTINGS.SALVAGE_XP_BASE || 50) * item.level;
        addExperience(xpGain);

        // Floating Text (In-game)
        activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, `XP +${xpGain}`, "#2ecc71", 24));
        // Toast (UI Overlay)
        if (window.showToast) window.showToast(`XP変換: +${xpGain} XP`, "#2ecc71");

        refreshInventoryInterface();
    },

    sellItem(uuid) {
        const index = this.inventory.findIndex(i => i.uuid === uuid);
        if (index === -1) return;
        const item = this.inventory[index];
        this.unequipByUuid(uuid);
        this.inventory.splice(index, 1);

        const base = GAME_SETTINGS.SELL_PRICE_BASE || 50;
        let price = base * item.level;

        // Artifact: Midas Bag (Sell price x2)
        if (this.artifacts.some(a => a.id === 'midas_bag')) price *= 2;

        this.gold += price;

        // Floating Text (In-game)
        activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, `SOLD: +${price} G`, "#f1c40f", 24));
        // Toast (UI Overlay)
        if (window.showToast) window.showToast(`売却完了: +${price} G`, "#f1c40f");

        refreshInventoryInterface();
    },

    togglePause() {
        if (!this.isGameOver) this.isPaused = !this.isPaused;
    },

    fuseItems() {
        let fusionOccurred = false;
        let loopSafety = 0;
        do {
            fusionOccurred = false;
            loopSafety++;
            if (loopSafety > 10) break;

            const groups = {};
            const allItems = [];
            this.inventory.forEach(i => allItems.push({ item: i, source: { type: 'INV', index: this.inventory.indexOf(i) } }));
            this.equippedGems.forEach((i, idx) => { if(i) allItems.push({ item: i, source: { type: 'MAIN', index: idx } }); });
            this.altGems.forEach((i, idx) => { if(i) allItems.push({ item: i, source: { type: 'SUB', index: idx } }); });
            if(this.equippedArtifacts.RING) allItems.push({ item: this.equippedArtifacts.RING, source: { type: 'ART', index: 'RING' } });
            if(this.equippedArtifacts.AMULET) allItems.push({ item: this.equippedArtifacts.AMULET, source: { type: 'ART', index: 'AMULET' } });
            
            allItems.forEach(entry => {
                const key = `${entry.item.id}_${entry.item.level}`;
                if (!groups[key]) groups[key] = [];
                groups[key].push(entry);
            });

            for (const key in groups) {
                const entries = groups[key];
                if (entries.length >= 3) {
                    const materials = entries.slice(0, 3);
                    const baseItem = materials[0].item;
                    const nextLevel = baseItem.level + 1;
                    
                    let targetSlot = null;
                    const equippedMat = materials.find(m => m.source.type !== 'INV');
                    if (equippedMat) targetSlot = equippedMat.source;

                    materials.forEach(m => {
                        if (m.source.type === 'INV') {
                            const idx = this.inventory.findIndex(x => x.uuid === m.item.uuid);
                            if (idx > -1) this.inventory.splice(idx, 1);
                        } else if (m.source.type === 'MAIN') {
                            this.equippedGems[m.source.index] = null;
                        } else if (m.source.type === 'SUB') {
                            this.altGems[m.source.index] = null;
                        } else if (m.source.type === 'ART') {
                             this.equippedArtifacts[m.source.index] = null;
                        }
                    });

                    const newItem = createItemInstance(baseItem, nextLevel);
                    if (targetSlot) {
                        if (targetSlot.type === 'MAIN') this.equippedGems[targetSlot.index] = newItem;
                        else if (targetSlot.type === 'SUB') this.altGems[targetSlot.index] = newItem;
                        else if (targetSlot.type === 'ART') this.equippedArtifacts[targetSlot.index] = newItem;
                    } else {
                        this.inventory.push(newItem);
                    }

                    fusionOccurred = true;
                    // バナー演出の呼び出し
                    if (window.showFuseEffect) window.showFuseEffect(newItem);
                    // レベルアップ音を鳴らす（控えめなSEにするのが理想ですが、現状の流用）
                    audioManager.play('LEVELUP');

                    break;
                }
            }
            if (fusionOccurred) this.recalcStats();
        } while (fusionOccurred);
        refreshInventoryInterface();
        updateMainScreenLoadout();
    },

    calculateNextLevelXp() {
        return Math.floor(GAME_SETTINGS.XP_PER_LEVEL_BASE * Math.pow(this.currentLevel, GAME_SETTINGS.XP_SCALING));
    },

    repairCastle() {
        const cost = GAME_SETTINGS.REPAIR_COST || 100;
        const healAmount = GAME_SETTINGS.REPAIR_AMOUNT || 200;
        const maxHP = GAME_SETTINGS.BASE_MAX_HP + this.stats.hp_max;
        if (this.baseIntegrity >= maxHP) {
            activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, "HP FULL", "#e74c3c", 20));
            return;
        }
        if (this.gold < cost) {
            activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, "NO FUNDS", "#e74c3c", 20));
            return;
        }
        this.gold -= cost;
        this.baseIntegrity = Math.min(this.baseIntegrity + healAmount, maxHP);
        activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.CASTLE_Y, `REPAIRED! +${healAmount}`, "#2ecc71", 24));
        refreshInventoryInterface();
    },

    buyMysteryBox() {
        const cost = GAME_SETTINGS.MYSTERY_BOX_COST || 500;
        const shopMsg = document.getElementById('shop-message');
        if (this.gold < cost) {
            activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, "NEED MORE GOLD", "#e74c3c", 20));
            if (shopMsg) { shopMsg.style.color = "#e74c3c"; shopMsg.innerText = "INSUFFICIENT FUNDS"; }
            return;
        }
        if (this.inventory.length >= GAME_SETTINGS.INVENTORY_CAPACITY) {
            activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, "INVENTORY FULL", "#e74c3c", 20));
            if (shopMsg) { shopMsg.style.color = "#e74c3c"; shopMsg.innerText = "INVENTORY FULL"; }
            return;
        }

        this.gold -= cost;
        const pool = [ ...Object.values(GEMS), ...Object.values(ARTIFACTS), ...Object.values(UNIQUES) ];
        const template = pool[Math.floor(Math.random() * pool.length)];

        const roll = Math.random();
        let level = 1;
        if (roll > 0.95) level = 4;
        else if (roll > 0.80) level = 3;
        else if (roll > 0.50) level = 2;

        const newItem = createItemInstance(template, level);
        this.inventory.push(newItem);
        const isUnique = Object.values(UNIQUES).some(u => u.id === template.id);
        const color = isUnique ? "#e056fd" : "#9b59b6";

        activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, `OBTAINED: ${template.name} Lv.${level}`, color, 28));
        if (shopMsg) {
            shopMsg.style.color = color;
            shopMsg.innerHTML = `OBTAINED: <span style="font-size:14px; font-weight:bold;">${template.name}</span> Lv.${level}`;
        }
        refreshInventoryInterface();
        refreshShopInterface();
    },

    checkProgression(killedEnemy) {
        if (this.isBossWave) {
            if (killedEnemy.tier.id === 'BOSS') {
                // 修正点: isActive かつ 「死亡演出中(isDying)ではない」ボスをカウントする
                const remainingBosses = activeEnemies.filter(e => e.isActive && !e.isDying && e.tier.id === 'BOSS' && e.id !== killedEnemy.id);
                if (remainingBosses.length === 0) {
                    this.completeWaveOrGame();
                }
            }
            return;
        }
        this.waveProgress++;
        if (this.waveProgress >= this.waveQuota) {
            this.advanceWave();
        }
    },

    advanceWave() {
        this.isBossWave = true;
        this.spawnStageBoss();
        activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, 250, `⚠ WAVE ${this.currentWaveNumber} BOSS ⚠`, "#e74c3c", 30));
        triggerScreenShake(30, 10);
    },

    spawnStageBoss() {
        const waveConfig = BOSS_WAVES[this.currentWaveNumber] || BOSS_WAVES[1];
        const count = waveConfig.count || 1;
        const spacing = 100;
        const startX = (GAME_SETTINGS.SCREEN_WIDTH - ((count - 1) * spacing)) / 2;
        for (let i = 0; i < count; i++) {
            const bossTier = { ...ENEMY_TIERS.BOSS };
            bossTier.name = waveConfig.name;
            bossTier.color = waveConfig.color;
            bossTier.scale = (waveConfig.scale || 2.0);
            bossTier.hpMod = (waveConfig.hp || 10.0);
            bossTier.speedMod = (waveConfig.speed || 1.0);
            const x = startX + (i * spacing);
            const boss = new EnemyUnit(bossTier, x, -150);
            activeEnemies.push(boss);
        }

        // Artifact: Time Stopper
        if (this.artifacts.some(a => a.id === 'time_stopper')) {
            this.timeStopTimer = 300; // 5 seconds
            activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, "TIME STOP!", "#34495e", 40));
        }
    },

    completeWaveOrGame() {
        activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, "エリア確保！", "#f1c40f", 40));
        this.gold += 300 + (this.currentWaveNumber * 50);

        if (this.currentWaveNumber >= 10) {
            this.isGameOver = true;
            // Record final timestamp
            this.waveLog.push({ wave: "CLEAR", time: (Date.now() - this.startTime) / 1000 });

            // Show Result Screen instead of Game Over
            if (window.showGameClearScreen) {
                setTimeout(() => window.showGameClearScreen(), 2000);
            } else {
                activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2 + 60, "全ミッション完了！", "#2ecc71", 50));
            }
            return;
        }

        // Trigger Artifact Selection
        if (window.showArtifactSelection) setTimeout(() => window.showArtifactSelection(), 1500);

        this.currentWaveNumber++;

        // BGM Change at Wave 8
        if (this.currentWaveNumber === 8) {
            audioManager.playBgm('BGM_LATE');
            activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, 200, "♫ BGM CHANGED ♫", "#f1c40f", 20));
        }

        // Log Wave time
        this.waveLog.push({ wave: this.currentWaveNumber, time: (Date.now() - this.startTime) / 1000 });

        this.waveProgress = 0;
        // 増加量を調整 (3 -> 12): 後半に向けてWaveが徐々に長く重厚になるように
        this.waveQuota = Math.floor(30 + (this.currentWaveNumber * 12));
        this.isBossWave = false;
        this.baseIntegrity = Math.min(this.baseIntegrity + 200, GAME_SETTINGS.BASE_MAX_HP + this.stats.hp_max);
        refreshInventoryInterface();
    },

    buyShopItem(itemId) {
        let item = Object.values(SHOP_ITEMS).find(i => i.id === itemId);
        let isGem = false;
        let cost = 0;

        if (item) {
            cost = item.cost;
        } else {
            const gem = Object.values(GEMS).find(g => g.id === itemId);
            if (gem && !this.purchasedShopItems.includes(gem.id)) {
                item = gem;
                isGem = true;
                cost = 300; 
            }
        }

        if (!item) return;
        const shopMsg = document.getElementById('shop-message');

        if (this.gold < cost) {
            activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, "NO FUNDS", "#e74c3c", 20));
            if (shopMsg) { shopMsg.style.color = "#e74c3c"; shopMsg.innerText = "INSUFFICIENT FUNDS"; }
            return;
        }

        if (isGem) {
            if (this.inventory.length >= GAME_SETTINGS.INVENTORY_CAPACITY) {
                activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, "INVENTORY FULL", "#e74c3c", 20));
                return;
            }
            this.gold -= cost;
            this.addItemToInventory(item, 1);
            this.purchasedShopItems.push(item.id);
            activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, `${item.name} PURCHASED`, "#2ecc71", 24));
            if (shopMsg) { shopMsg.style.color = "#2ecc71"; shopMsg.innerText = `${item.name} ACQUIRED`; }
            audioManager.play('CLICK');
        }
        else if (item.id === 'repair') {
            this.repairCastle(); 
            if (shopMsg) { shopMsg.style.color = "#2ecc71"; shopMsg.innerText = "SYSTEM REPAIRED"; }
        } 
        else if (item.type === 'UNIT') {
            this.gold -= cost;
            this.activeSupportUnits.push(new SupportUnit(item.type === 'UNIT' ? (item.id === 'clone' ? 'CLONE' : (item.id === 'drone_atk' ? 'DRONE_ATK' : 'DRONE_COL')) : 'UNKNOWN', item.duration));
            activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.CASTLE_Y - 50, `${item.name} DEPLOYED`, "#00d2d3", 24));
            if (shopMsg) { shopMsg.style.color = "#00d2d3"; shopMsg.innerText = `${item.name} ACTIVE`; }
        }

        refreshInventoryInterface();
        refreshShopInterface();
    },

    getCurrentStageData() {
        return STAGE_CONFIG[this.currentStageIndex] || STAGE_CONFIG[0];
    },

    updateEnergy() {
        // --- Crew & Status Logic ---
        // 1. Damage Detection (Trigger 'b' face)
        if (this.baseIntegrity < this._lastIntegrity) {
            this.crewDamageTimer = 30; // 0.5 sec shock
        }
        this._lastIntegrity = this.baseIntegrity;

        // 2. Determine Face Suffix
        if (this.crewDamageTimer > 0) {
            this.crewDamageTimer--;
            this.crewStatusSuffix = 'b';
        } else {
            const maxHP = GAME_SETTINGS.BASE_MAX_HP + this.stats.hp_max;
            const ratio = this.baseIntegrity / maxHP;
            this.crewStatusSuffix = ratio < 0.3 ? 'c' : 'a';
        }

        // 3. HP Regeneration (Dr. Xeno etc)
        if (this.stats.hp_regen > 0 && this.baseIntegrity > 0 && !this.isGameOver) {
            const maxHP = GAME_SETTINGS.BASE_MAX_HP + this.stats.hp_max;
            if (this.baseIntegrity < maxHP) {
                // Apply regen (approx per frame, assuming 60FPS, stats.hp_regen is per second)
                this.baseIntegrity = Math.min(maxHP, this.baseIntegrity + (this.stats.hp_regen / 60));
                this._lastIntegrity = this.baseIntegrity; // Prevent self-healing from triggering damage check
            }
        }

        // Artifact: Emergency Core logic
        if (this.emergencyCooldown > 0) this.emergencyCooldown--;

        const hpRatio = this.baseIntegrity / (GAME_SETTINGS.BASE_MAX_HP + this.stats.hp_max);
        if (hpRatio <= 0.3 && this.emergencyCooldown <= 0 && this.artifacts.some(a => a.id === 'emergency_core')) {
            if (!this.isShieldActive) {
                this.setShieldState(true);
                this.energy = Math.max(this.energy, 50); // Free energy boost
                this.emergencyCooldown = 3600; // 60 sec cooldown
                activeFloatingTexts.push(new FloatingText(RENDER_CONSTANTS.TURRET_POS_X, GAME_SETTINGS.CASTLE_Y - 80, "EMERGENCY SHIELD!", "#e74c3c", 24));
            }
        }

        if (this.isShieldActive) {
            this.energy -= 1.5;
            this.shieldTimer++;
            if (this.energy <= 0) {
                this.energy = 0;
                this.isShieldActive = false;
                activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.CASTLE_Y - 50, "SHIELD BROKEN", "#e74c3c", 20));
            }
        } else {
            if (this.energy < this.maxEnergy) {
                // Artifact: Infinity Battery (mp_regen_pct)
                const regenMult = 1 + (this.stats.mp_regen_pct || 0);
                this.energy += 0.5 * regenMult;
            }
        }
    },

    setShieldState(isActive) {
        if (isActive && this.energy > 10) {
            if (!this.isShieldActive) {
                this.isShieldActive = true;
                this.shieldTimer = 0;
            }
        } else {
            this.isShieldActive = false;
        }
        const btn = document.getElementById('btn-shield-orb');
        if (btn) {
            btn.style.borderColor = this.isShieldActive ? "#66fcf1" : "#333";
            btn.style.boxShadow = this.isShieldActive ? "0 0 15px #66fcf1" : "0 0 20px rgba(0,0,0,0.8)";
        }
    },

    updateCrewAbilities() {
        let statsChanged = false;
        // Update Cooldowns
        Object.keys(this.crewCooldowns).forEach(id => {
            if (this.crewCooldowns[id] > 0) this.crewCooldowns[id]--;
        });

        // Update Active Buffs
        Object.keys(this.crewActiveBuffs).forEach(id => {
            if (this.crewActiveBuffs[id] > 0) {
                this.crewActiveBuffs[id]--;
                if (this.crewActiveBuffs[id] <= 0) statsChanged = true; // Buff expired
            }
        });

        if (statsChanged) this.recalcStats();
    },

    activateCrewAbility(crewId) {
        if (this.crewCooldowns[crewId] > 0) return; // CD中

        const crew = CREW_DATA[crewId];
        if (!crew || !crew.ability) return;

        // Artifact: Wolf Radio (Ability Duration +50%)
        let durationBonus = 1.0;
        if (this.artifacts.some(a => a.id === 'wolf_radio')) durationBonus = 1.5;

        // アーケード演出: カットインの呼び出し
        if (!crew || !crew.ability) return;

        // アーケード演出: カットインの呼び出し
        if (window.showAbilityCutIn) {
            window.showAbilityCutIn(crewId);
        }

        const ability = crew.ability;
        this.crewCooldowns[crewId] = ability.cd;

        // Visual & Sound Effect
        activeFloatingTexts.push(new FloatingText(RENDER_CONSTANTS.TURRET_POS_X, GAME_SETTINGS.CASTLE_Y - 120, ability.name.toUpperCase() + "!", "#fff", 30));
        triggerScreenShake(15, 8);

        // Apply Effect
        if (crew.id === 1 || crew.id === 2) {
            // Buff type (Wolf, Luna)
            this.crewActiveBuffs[crewId] = Math.floor(ability.duration * durationBonus);
            this.recalcStats();
            // Particle Aura
            const color = crew.id === 1 ? "#e74c3c" : "#f1c40f";
            for(let i=0; i<20; i++) activeParticles.push(new ParticleEffect(RENDER_CONSTANTS.TURRET_POS_X, GAME_SETTINGS.CASTLE_Y, color, 10));
        }
        else if (crew.id === 3) {
            // R-22: EMP Blast
            applyAreaDamage(RENDER_CONSTANTS.TURRET_POS_X, 400, 800, 200 + (this.currentLevel * 10), 'electric');
            activeEnemies.forEach(e => { if(e.isActive) e.applyStatus('STUN'); });
            activeZoneEffects.push(new ZoneEffect(RENDER_CONSTANTS.TURRET_POS_X, 450, 'STATIC_FIELD', { damage: 10 }));
        }
        else if (crew.id === 4) {
            // Xeno: Meltdown Rain
            // Apply Acid (x2 Damage) & Poison to ALL enemies
            // [Patch] Scaling Poison: Based on Level & Damage%
            const poisonPower = (30 + (this.currentLevel * 5)) * (1 + this.stats.damage_pct);

            activeEnemies.forEach(e => {
                if (!e.isActive) return;
                e.acidTimer = 600; // 10 seconds vulnerability
                e.poisonStacks += 5;
                e.poisonTimer = 300;
                // Update poison damage to the new powerful value
                e.poisonDamage = Math.max(e.poisonDamage || 0, poisonPower * 0.2); 

                activeFloatingTexts.push(new FloatingText(e.positionX, e.positionY, "MELTDOWN!", "#2ecc71", 20));
            });
            // Visual Overlay
            activeZoneEffects.push(new ZoneEffect(RENDER_CONSTANTS.TURRET_POS_X, 450, 'POISON_CLOUD', { damage: 0 })); // Visuals
            activeFloatingTexts.push(new FloatingText(RENDER_CONSTANTS.TURRET_POS_X, GAME_SETTINGS.CASTLE_Y - 100, "ACID RAIN!!", "#2ecc71", 40));
        }
        else if (crew.id === 5) {
            // Mida: Bribe
            let count = 0;
            // [Patch] Scaling Gold: Apply gold_gain stat
            const goldMult = 1.0 + (this.stats.gold_gain || 0);

            activeEnemies.forEach(e => {
                if (!e.isActive || e.tier.id === 'BOSS') return;
                if (count < 5) {
                    e.takeDamage(99999, true, 'bribe'); // Instant Kill

                    let goldVal = 50 + Math.floor(Math.random() * 50);
                    goldVal = Math.floor(goldVal * goldMult);

                    this.gold += goldVal;
                    activeFloatingTexts.push(new FloatingText(e.positionX, e.positionY, `+${goldVal}G`, "#f1c40f", 20));
                    count++;
                }
            });
        }

        // UI Refresh trigger
        if(window.updateCrewHud) window.updateCrewHud();
    }
});

const engineState = new GameEngine();
window.engineState = engineState; 

const gameCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById('game-canvas'));
const gameContext = gameCanvas.getContext('2d');

let activeEnemies = [];
let activeProjectiles = [];
let activeEnemyProjectiles = []; 
let activeParticles = [];
let activeShockwaves = [];
let activeFloatingTexts = [];
let activeZoneEffects = []; 
let starField = new StarField(GAME_SETTINGS.SCREEN_WIDTH, GAME_SETTINGS.SCREEN_HEIGHT);

// [Patch] Inject All Elemental Gems
if (!GEMS.POISON) {
    GEMS.POISON = { id: 'poison', name: '毒弾', type: 'ACTIVE', color: '#8e44ad', damage: 15, rate: 100, speed: 3.5, forcedLevel: 1 };
    GEMS.PSYCHIC = { id: 'psychic', name: '念動力', type: 'ACTIVE', color: '#e056fd', damage: 10, rate: 45, speed: 7, forcedLevel: 1 };
    GEMS.WATER   = { id: 'water',   name: '激流',   type: 'ACTIVE', color: '#3498db', damage: 20, rate: 30, speed: 9, forcedLevel: 1 };
    GEMS.ELECTRIC= { id: 'electric',name: '電撃',   type: 'ACTIVE', color: '#f1c40f', damage: 12, rate: 29, speed: 20, forcedLevel: 1, chain_count: 3, chain_range: 250 };
    GEMS.ROCK    = { id: 'rock',    name: '隕石',   type: 'ACTIVE', color: '#7f8c8d', damage: 90, rate: 70, speed: 8, forcedLevel: 1 };
    GEMS.PLANT   = { id: 'plant',   name: '茨',     type: 'ACTIVE', color: '#2ecc71', damage: 18, rate: 40, speed: 8, forcedLevel: 1, pierce_count: 2 };
}

let enemySpawnCounter = 0;
let attackCooldownCounter = 0; 
let attackCooldownSub = 0;
let shakeTime = 0;
let shakeIntensity = 0;
let customAiFunction = null;

// --- Input Handling (Unified Mouse & Touch) ---
// Pointer Eventsを使用してPC/スマホの入力を統合
gameCanvas.addEventListener('pointerdown', (e) => {
    // 右クリック(button 2)またはペン入力のバレルボタンでシールド
    if (e.button === 2) {
        engineState.setShieldState(true);
    } else {
        handleCanvasInput(e);
    }
    // タッチ時のスクロール等のデフォルト挙動を防止
    if (e.pointerType === 'touch') e.preventDefault();
}, { passive: false });

gameCanvas.addEventListener('pointerup', (e) => {
    if (e.button === 2) engineState.setShieldState(false);
});

// キーボード制御はPC用に維持
window.addEventListener('keydown', (e) => {
    if (['Space', 'ShiftLeft', 'ShiftRight'].includes(e.code)) {
        if (!engineState.isPaused && !engineState.isGameOver) engineState.setShieldState(true);
    }
});
window.addEventListener('keyup', (e) => {
    if (['Space', 'ShiftLeft', 'ShiftRight'].includes(e.code)) engineState.setShieldState(false);
});

// 右クリックメニューを禁止
gameCanvas.addEventListener('contextmenu', e => e.preventDefault());

/**
 * 座標変換と入力処理
 */
function handleCanvasInput(event) {
    const rect = gameCanvas.getBoundingClientRect();
    // キャンバスの論理サイズ(600x900)に合わせて座標をスケール
    const scaleX = gameCanvas.width / rect.width;
    const scaleY = gameCanvas.height / rect.height;
    const clickX = (event.clientX - rect.left) * scaleX;
    const clickY = (event.clientY - rect.top) * scaleY;
    
    // Pickup
    for (let i = engineState.activeDrops.length - 1; i >= 0; i--) {
        const drop = engineState.activeDrops[i];
        const dist = Math.hypot(drop.x - clickX, drop.y - clickY);
        if (dist < RENDER_CONSTANTS.DROP_SIZE * 1.5) { 
            if (drop.itemTemplate.type === 'GOLD') {
                let val = (GAME_SETTINGS.GOLD_VALUE_BASE || 25) + Math.floor(Math.random() * 10);
                if (engineState.stats.gold_gain > 0) val = Math.floor(val * (1 + engineState.stats.gold_gain));
                engineState.gold += val;
                activeFloatingTexts.push(new FloatingText(drop.x, drop.y, `+${val} G`, "#f1c40f", 20));
                refreshInventoryInterface();
            } else {
                engineState.addItemToInventory(drop.itemTemplate);
                activeFloatingTexts.push(new FloatingText(drop.x, drop.y, "GET!", "#f1c40f", 20));
            }
            engineState.activeDrops.splice(i, 1);
            return; 
        }
    }

    // Target
    let clickedEnemy = null;
    if (!engineState.isGameOver) {
        for (const enemy of activeEnemies) {
            const dist = Math.hypot(enemy.positionX - clickX, enemy.positionY - clickY);
            if (dist < enemy.size * 1.2) {
                clickedEnemy = enemy;
                break;
            }
        }
    }
    if (clickedEnemy) {
        engineState.manualTargetId = clickedEnemy.id;
        activeParticles.push(new ParticleEffect(clickedEnemy.positionX, clickedEnemy.positionY, EFFECT_CONSTANTS.COLOR_TARGET, 8));
        activeFloatingTexts.push(new FloatingText(clickedEnemy.positionX, clickedEnemy.positionY - 20, "TARGET!", EFFECT_CONSTANTS.COLOR_TARGET, 16));
    } else {
        engineState.manualTargetId = null;
    }
}

window.updateCustomAi = function(codeString) {
    try {
        customAiFunction = new Function('enemyList', 'selectEnemyHelper', `
            const context = { targetEnemy: null };
            (function(enemyList, selectEnemyHelper) {
                ${codeString}
            }).call(context, enemyList, selectEnemyHelper);
            return context.targetEnemy;
        `);
    } catch (errorInstance) {
        console.error("Failed to compile AI code:", errorInstance);
    }
};

function triggerScreenShake(duration, intensity) {
    shakeTime = duration;
    shakeIntensity = intensity;
}

// --- Entities ---
class MagicProjectile {
    constructor(startX, startY, target, config) {
        this.currentX = startX;
        this.currentY = startY;
        this.target = target; 

        let baseDmg = config.damage || 10;
        if (config.level > 1) baseDmg *= (1 + (config.level - 1) * 0.2); 

        // DoT (status) should be able to reference "pre-hit-multiplier" damage.
        // - rawDamageValue: status power baseline (defaults to baseDmg)
        // - hitDamageMultiplier: affects hit damage only (defaults to 1.0)
        const hitDamageMultiplier = (config.hitDamageMultiplier !== undefined) ? config.hitDamageMultiplier : 1.0;
        this.rawDamageValue = (config.rawDamageValue !== undefined) ? config.rawDamageValue : baseDmg;
        this.damageValue = baseDmg * hitDamageMultiplier;

        this.moveSpeed = config.speed || 5;
        this.glowColor = config.color || "#ffffff";
        this.effectType = config.id; 
        this.isAlive = true;
        this.isShatterShard = config.isShatter || false;
        this.isFallingRock = config.isFallingRock || false;
        this.targetY = config.targetY || 9999;
        this.pierceCount = config.pierce_count || 0;
        this.chainCount = config.chain_count || 0;
        this.chainRange = config.chain_range || 0;

        // Stats Tracking
        this.sourceGemId = config.sourceGemId || config.id; 

        // Artifact Flags
        this.isHoming = config.isHoming || false;
        this.isBound = config.isBound || false;

        if (this.isHoming) {
            this.damageValue *= 0.7; // -30% Hit Damage Penalty
            this.homingLifeTimer = 180; // 消滅タイマー: 3秒 (60fps * 3)
        }
        this.boundCount = 0;

        this.hitTargetIds = new Set();
        if (config.ignoreIds) config.ignoreIds.forEach(id => this.hitTargetIds.add(id));

        if (config.velocityX !== undefined && config.velocityY !== undefined) {
            this.velocityX = config.velocityX;
            this.velocityY = config.velocityY;
        } else if (target) {
            const deltaX = target.positionX - startX;
            const deltaY = target.positionY - startY;
            const dist = Math.hypot(deltaX, deltaY);
            this.velocityX = (deltaX / dist) * this.moveSpeed;
            this.velocityY = (deltaY / dist) * this.moveSpeed;
        } else {
            this.velocityX = 0;
            this.velocityY = -this.moveSpeed;
        }
    }

    update() {
        // Homing Logic (Artifact: Homing Beacon)
        if (this.isHoming && !this.isFallingRock) {
            // 時間経過による消滅
            this.homingLifeTimer--;
            if (this.homingLifeTimer <= 0) {
                this.isAlive = false;
                return;
            }

            if (!this.target || !this.target.isActive) {
                let minDist = 400;
                let newTarget = null;
                for (const enemy of activeEnemies) {
                    if (!enemy.isActive) continue;
                    const d = Math.hypot(enemy.positionX - this.currentX, enemy.positionY - this.currentY);
                    if (d < minDist) { minDist = d; newTarget = enemy; }
                }
                this.target = newTarget;
            }
            if (this.target && this.target.isActive) {
                const dx = this.target.positionX - this.currentX;
                const dy = this.target.positionY - this.currentY;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    const steerStrength = 0.05; 
                    const desiredVx = (dx / dist) * this.moveSpeed;
                    const desiredVy = (dy / dist) * this.moveSpeed;
                    this.velocityX = (this.velocityX * (1 - steerStrength)) + (desiredVx * steerStrength);
                    this.velocityY = (this.velocityY * (1 - steerStrength)) + (desiredVy * steerStrength);
                }
            }
        }

        if (this.effectType === 'psychic' && this.target && this.target.isActive) {
            const dx = this.target.positionX - this.currentX;
            const dy = this.target.positionY - this.currentY;
            const dist = Math.hypot(dx, dy);
            if (dist > 0) {
                this.velocityX = (this.velocityX * 0.9) + ((dx/dist) * this.moveSpeed * 0.1);
                this.velocityY = (this.velocityY * 0.9) + ((dy/dist) * this.moveSpeed * 0.1);
            }
        }

        if (this.isFallingRock) {
            this.currentY += this.velocityY;
            if (this.currentY >= this.targetY) {
                this.isAlive = false;
                applyAreaDamage(this.currentX, this.currentY, 100, this.damageValue, 'rock');
                activeFloatingTexts.push(new FloatingText(this.currentX, this.currentY, "CRASH!", "#7f8c8d", 28));
                triggerScreenShake(8, 8);
            }
            return;
        }

        this.currentX += this.velocityX;
        this.currentY += this.velocityY;

        // Bound Logic (Artifact: Bound Orb)
        if (this.isBound && this.boundCount < 1) {
            if (this.currentX <= 0 || this.currentX >= GAME_SETTINGS.SCREEN_WIDTH) {
                this.velocityX *= -1;
                this.boundCount++;
                this.currentX = Math.max(1, Math.min(GAME_SETTINGS.SCREEN_WIDTH - 1, this.currentX));
            }
        }

        if (this.currentX > gameCanvas.width + 100 || this.currentX < -100 || 
            this.currentY > gameCanvas.height + 100 || this.currentY < -100) {
            this.isAlive = false;
        }
    }

    draw(context) {
        context.save();

        // 1. Electric (Lightning Bolt)
        if (this.effectType === 'electric') {
            context.shadowBlur = 15;
            context.shadowColor = "#f1c40f";
            context.strokeStyle = "#fff";
            context.lineWidth = 3;
            context.beginPath();
            const tailLen = 40;
            const angle = Math.atan2(this.velocityY, this.velocityX);
            const tailX = this.currentX - Math.cos(angle) * tailLen;
            const tailY = this.currentY - Math.sin(angle) * tailLen;
            context.moveTo(tailX, tailY);
            // Jagged line
            const midX = (tailX + this.currentX) / 2 + (Math.random() - 0.5) * 15;
            const midY = (tailY + this.currentY) / 2 + (Math.random() - 0.5) * 15;
            context.lineTo(midX, midY);
            context.lineTo(this.currentX, this.currentY);
            context.stroke();
            context.restore();
            return;
        }

        // 2. Falling Rock (Meteor)
        if (this.isFallingRock) {
            context.save();
            // Warning Indicator on ground
            const pulse = (Date.now() % 500) / 500; 
            context.fillStyle = `rgba(231, 76, 60, ${0.1 + pulse * 0.2})`;
            context.strokeStyle = `rgba(231, 76, 60, ${0.4 + pulse * 0.4})`;
            context.lineWidth = 2;
            context.translate(this.currentX, this.targetY);
            context.beginPath();
            context.scale(1, 0.5);
            context.arc(0, 0, 100, 0, Math.PI * 2);
            context.fill();
            context.stroke();
            context.restore();

            // The Rock itself
            context.shadowBlur = 10;
            context.shadowColor = "#e67e22";
            context.fillStyle = "#596275"; // Darker rock color
            context.translate(this.currentX, this.currentY);

            // Rotating rock visual
            const rockRotation = (Date.now() / 200) + this.currentX; 
            context.rotate(rockRotation);
            context.beginPath();
            // Irregular jagged shape
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2) / 6;
                const r = 30 + (i % 2 === 0 ? 5 : -5);
                const rx = Math.cos(angle) * r;
                const ry = Math.sin(angle) * r;
                if (i === 0) context.moveTo(rx, ry);
                else context.lineTo(rx, ry);
            }
            context.closePath();
            context.fill();

            // Trail
            context.rotate(-rockRotation); // Reset rotation for trail
            context.fillStyle = "rgba(231, 76, 60, 0.6)";
            context.beginPath();
            context.moveTo(-25, 0);
            context.lineTo(25, 0);
            context.lineTo(0, -90); // Trail goes up
            context.fill();
        } 
        else {
            // 3. Standard Projectiles (Shape based on type)
            context.shadowBlur = RENDER_CONSTANTS.EFFECT_SHADOW_BLUR;
            context.shadowColor = this.glowColor;
            context.fillStyle = this.glowColor;

            // Rotate based on velocity
            const angle = Math.atan2(this.velocityY, this.velocityX);
            const size = RENDER_CONSTANTS.PROJECTILE_SIZE;

            context.translate(this.currentX, this.currentY);
            context.rotate(angle);

            context.beginPath();

            if (this.isShatterShard) {
                // Shard: Small Diamond
                context.moveTo(8, 0);
                context.lineTo(-4, 4);
                context.lineTo(-4, -4);
                context.closePath();
            }
            else if (this.effectType === 'arrow') {
                // Arrow: Sharp Triangle / Arrowhead
                // Tip at (size*1.5, 0), Tail at (-size, +/- size)
                context.moveTo(size * 1.5, 0);
                context.lineTo(-size, size * 0.8);
                context.lineTo(-size * 0.5, 0); // Indent at back
                context.lineTo(-size, -size * 0.8);
                context.closePath();
            }
            else if (this.effectType === 'fireball' || this.effectType === 'drone_shot') {
                // Fireball: Tear shape (Round front, pointy back)
                context.arc(0, 0, size, 0, Math.PI * 2);
                // Add a trail shape behind
                context.moveTo(0, size);
                context.lineTo(-size * 2.5, 0);
                context.lineTo(0, -size);
                context.fill(); // Fill the trail separately combined
            }
            else if (this.effectType === 'plant') {
                // Plant: Shuriken / Thorn (Spinning)
                const spin = (Date.now() / 100);
                context.rotate(spin); // Extra spin on top of directional
                for (let i = 0; i < 4; i++) {
                    const theta = (Math.PI / 2) * i;
                    const x = Math.cos(theta) * size * 1.5;
                    const y = Math.sin(theta) * size * 1.5;
                    context.lineTo(x, y);
                    // Curve inward
                    const thetaMid = theta + Math.PI / 4;
                    const xm = Math.cos(thetaMid) * size * 0.4;
                    const ym = Math.sin(thetaMid) * size * 0.4;
                    context.lineTo(xm, ym);
                }
                context.closePath();
            }
            else if (this.effectType === 'poison') {
                // Poison: Blob
                context.arc(0, 0, size, 0, Math.PI * 2);
                // Dripping effect (random small circles behind)
                if (Math.random() < 0.3) {
                     context.arc(-size * 2, (Math.random()-0.5)*size, size/2, 0, Math.PI*2);
                }
            }
            else if (this.effectType === 'water') {
                 // Water: Streamlined Drop
                 context.moveTo(size, 0);
                 context.bezierCurveTo(-size, size, -size*2, 0, -size, -size);
                 context.closePath();
            }
            else if (this.effectType === 'psychic') {
                 // Psychic: Ring / Hollow Circle
                 context.arc(0, 0, size * 1.2, 0, Math.PI * 2);
                 context.fill(); // Outer glow
                 context.globalCompositeOperation = 'destination-out';
                 context.beginPath();
                 context.arc(0, 0, size * 0.6, 0, Math.PI * 2);
                 context.fill(); // Hole in middle
                 context.globalCompositeOperation = 'source-over';
            }
            else if (this.effectType === 'nova') {
                // Nova: Diamond / Crystal
                context.moveTo(size, 0);
                context.lineTo(0, size);
                context.lineTo(-size, 0);
                context.lineTo(0, -size);
                context.closePath();
            }
            else {
                // Default: Circle
                context.arc(0, 0, size, 0, Math.PI * 2);
            }

            context.fill();
        }
        context.restore();
    }
}

class SupportUnit {
    constructor(type, duration) {
        this.id = generateUuid();
        this.type = type; 
        this.life = duration;
        this.maxLife = duration;
        this.x = RENDER_CONSTANTS.TURRET_POS_X + (Math.random() - 0.5) * 120;
        this.y = RENDER_CONSTANTS.TURRET_POS_Y + (Math.random() - 0.5) * 60 - 50;
        this.attackCooldown = 0;
        this.targetDrop = null;
        this.floatOffset = Math.random() * Math.PI * 2;
    }

    update() {
        this.life--;
        this.floatOffset += 0.1;
        if (this.type !== 'DRONE_COL') {
            this.y += Math.sin(this.floatOffset) * 0.5;
        }

        if (this.type === 'DRONE_ATK') {
            this.attackCooldown++;
            if (this.attackCooldown >= 60) { 
                const target = getTarget();
                if (target) {
                    // [Patch] Drone Scaling: Apply Damage% and Support Effect
                    let dmg = 20 + (engineState.currentLevel * 3); // Base scaling buffed (2->3)
                    dmg *= (1.0 + engineState.stats.damage_pct);
                    dmg *= (1.0 + engineState.stats.support_effect);

                    activeProjectiles.push(new MagicProjectile(this.x, this.y, target, {
                        id: 'drone_shot', damage: dmg, speed: 8, color: '#00d2d3'
                    }));
                    this.attackCooldown = 0;
                }
            }
        } else if (this.type === 'DRONE_COL') {
            if (!this.targetDrop || !engineState.activeDrops.includes(this.targetDrop)) {
                let minD = Infinity;
                this.targetDrop = null;
                engineState.activeDrops.forEach(drop => {
                    const d = Math.hypot(drop.x - this.x, drop.y - this.y);
                    if (d < minD) { minD = d; this.targetDrop = drop; }
                });
            }

            if (this.targetDrop) {
                const dx = this.targetDrop.x - this.x;
                const dy = this.targetDrop.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 5) {
                    this.x += (dx / dist) * 4;
                    this.y += (dy / dist) * 4;
                } else {
                    const drop = this.targetDrop;
                    if (drop.itemTemplate.type === 'GOLD') {
                        let val = (GAME_SETTINGS.GOLD_VALUE_BASE || 25) + Math.floor(Math.random() * 10);
                        if (engineState.stats.gold_gain > 0) val = Math.floor(val * (1 + engineState.stats.gold_gain));
                        engineState.gold += val;
                        activeFloatingTexts.push(new FloatingText(drop.x, drop.y, `+${val} G`, "#f1c40f", 20));
                    } else {
                        engineState.addItemToInventory(drop.itemTemplate);
                        activeFloatingTexts.push(new FloatingText(drop.x, drop.y, "GET!", "#f1c40f", 20));
                    }
                    const idx = engineState.activeDrops.indexOf(drop);
                    if (idx > -1) engineState.activeDrops.splice(idx, 1);
                    this.targetDrop = null;
                    engineState.inventoryDirty = true;
                }
            } else {
                const homeX = RENDER_CONSTANTS.TURRET_POS_X - 100;
                const homeY = RENDER_CONSTANTS.TURRET_POS_Y;
                const dx = homeX - this.x;
                const dy = homeY - this.y;
                if (Math.hypot(dx, dy) > 10) {
                    this.x += dx * 0.05;
                    this.y += dy * 0.05;
                }
            }
        }
    }

    draw(context) {
        context.save();
        context.translate(this.x, this.y);

        const lifeRatio = this.life / this.maxLife;
        context.fillStyle = "#555";
        context.fillRect(-10, -20, 20, 4);
        context.fillStyle = "#fff";
        context.fillRect(-10, -20, 20 * lifeRatio, 4);

        if (this.type === 'DRONE_ATK') {
            context.fillStyle = "#e74c3c";
            context.beginPath(); context.moveTo(0, -10); context.lineTo(10, 5); context.lineTo(-10, 5); context.fill();
            context.shadowBlur = 10; context.shadowColor = "#e74c3c";
        } else if (this.type === 'DRONE_COL') {
            context.fillStyle = "#f1c40f";
            context.beginPath(); context.arc(0, 0, 8, 0, Math.PI*2); context.fill();
            context.strokeStyle = "#fff"; context.stroke();
        } else if (this.type === 'CLONE') {
            context.fillStyle = "rgba(100, 255, 218, 0.7)";
            context.beginPath(); context.moveTo(0, -15); context.lineTo(-10, 10); context.lineTo(10, 10); context.fill();
            context.shadowBlur = 15; context.shadowColor = "#64ffda";
        }

        context.restore();
    }
}

class EnemyUnit {
    constructor(tier = ENEMY_TIERS.NORMAL, xOverride = null, yOverride = null) {
        this.id = generateUuid();
        this.tier = tier;
        const stage = engineState.getCurrentStageData();
        
        if (xOverride !== null) this.positionX = xOverride;
        else this.positionX = Math.random() * (GAME_SETTINGS.SCREEN_WIDTH - 60) + 30;
        
        if (yOverride !== null) this.positionY = yOverride;
        else this.positionY = -50;

        let waveMultiplier = 1.0;
        if (tier.id !== 'BOSS') {
            waveMultiplier = Math.pow(1.20, Math.max(0, engineState.currentWaveNumber - 1));
        }

        // [Patch] Configurable Base HP
        const baseHp = GAME_SETTINGS.ENEMY_BASE_HP !== undefined ? GAME_SETTINGS.ENEMY_BASE_HP : 60;
        this.maxHealth = baseHp * tier.hpMod * waveMultiplier;
        this.health = this.maxHealth;

        const baseSpd = (1.2 + Math.random() * 0.8);
        this.baseSpeed = baseSpd * (0.9 + (engineState.currentWaveNumber * 0.1)) * tier.speedMod;
        
        this.isActive = true;
        this.flashTime = 0;
        this.burnTimer = 0;
        this.burnDamagePerTick = 0;
        this.freezeTimer = 0;
        this.poisonTimer = 0;
        this.poisonStacks = 0;
        this.confusionTimer = 0;
        this.soakedTimer = 0;
        this.shockTimer = 0;
        this.shockMultiplier = 1.0;
        this.stunTimer = 0;
        this.acidTimer = 0; // New: Dr. Xeno's Meltdown

        // [Patch] Leech Status
        this.leechTimer = 0;
        this.leechPower = 0; 
        this.leechRatio = GAME_SETTINGS.LEECH_RATIO || 0.02; // Configurable ratio

        // [Patch] Chaos Synergy Cooldown
        this.chaosCooldown = 0;

        this.size = 30 * tier.scale;
        this.bossState = 'ENTER'; 
        this.attackTimer = 0;
        this.moveAngle = 0;

        // 撃破演出用
        this.isDying = false;
        this.deathProgress = 0;

        // ボス専用：召喚タイマー (約6〜8秒周期)
        this.summonTimer = 240 + Math.random() * 120;
    }

    // ボス専用：周囲に雑魚を召喚
    performSummon() {
        const count = 3 + Math.floor(engineState.currentWaveNumber / 3); // 後半ほど増える
        const radius = this.size + 40;

        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 / count) * i;
            const spawnX = this.positionX + Math.cos(angle) * radius;
            const spawnY = this.positionY + Math.sin(angle) * radius;

            // 召喚されるのは機動力の高い SWARM 
            const minion = new EnemyUnit(ENEMY_TIERS.SWARM, spawnX, spawnY);
            activeEnemies.push(minion);

            // 召喚エフェクト
            for (let p = 0; p < 5; p++) {
                activeParticles.push(new ParticleEffect(spawnX, spawnY, this.tier.color, 4));
            }
        }

        activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 50, "SUMMON!", this.tier.color, 24));
        triggerScreenShake(5, 3);
    }

    applyStatus(type, power, level = 1) {
        if (type === 'BURN') {
            this.burnTimer = EFFECT_CONSTANTS.BURN_DURATION;
            this.burnDamagePerTick = power * EFFECT_CONSTANTS.BURN_DAMAGE_RATIO;
        }
        if (type === 'FREEZE') {
            this.freezeTimer = EFFECT_CONSTANTS.FREEZE_DURATION;
        }
        // [Patch] Poison Rework: 20% of damage, 5 sec duration
        if (type === 'POISON') {
            this.poisonTimer = 300;
            this.poisonStacks++;
            this.poisonDamage = power * 0.2; 
        }
        if (type === 'CONFUSION') {
            const chance = 0.1 * level;
            if (this.tier.id === 'NORMAL' && Math.random() < chance) {
                this.confusionTimer = 300;
                activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY-30, "CONFUSED!", "#e056fd", 20));
            } else if (this.tier.id === 'NORMAL') {
                 activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY-30, "RESIST", "#ccc", 12));
            }
        }
        if (type === 'SOAKED') {
            this.soakedTimer = 180;
        }
        if (type === 'SHOCK') { 
            // [Patch] Shock Rebalance: Base 1.15x, scales better with damage but has better floor
            const damageRatio = power / this.maxHealth;
            let mult = 1.15 + (damageRatio * 50.0); // Ratio weight increased significantly

            // Soft caps
            if (mult > 2.5) mult = 2.5;
            if (this.tier.id === 'BOSS' && mult > 1.4) mult = 1.4; // Boss cap

            if (mult > this.shockMultiplier) {
                this.shockMultiplier = mult;
                this.shockTimer = 300; 
                const percent = Math.floor((this.shockMultiplier - 1.0) * 100);
                activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 40, `SHOCK +${percent}%`, "#f1c40f", 20));
            } else {
                this.shockTimer = 300;
            }
        }
        if (type === 'STUN') { 
            this.stunTimer = 60;
            if (this.tier.id !== 'BOSS') this.positionY -= 10;
        }

        // [Patch] Leech Seed
        if (type === 'LEECH') {
            this.leechTimer = 180; // 3 seconds
            this.leechPower = power; 
        }

        // Trigger Synergy Check
        this.checkSynergy();
    }

    checkSynergy() {
        // --- EXISTING SYNERGIES (1-6) ---

        // 1. STEAM ERUPTION: Burn + Soaked -> "蒸発"
        if (this.burnTimer > 0 && this.soakedTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('steam');
            this.burnTimer = 0;
            this.soakedTimer = 0;
            const steamDmg = (this.maxHealth * 0.15) + 150; 

            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 60, "蒸発", "#dff9fb", 40)); 
            for(let i=0; i<35; i++) {
                const color = Math.random() > 0.7 ? "#c7ecee" : "#ffffff"; 
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, color, 8 + Math.random() * 4));
            }
            triggerScreenShake(12, 8); 
            applyAreaDamage(this.positionX, this.positionY, 160, steamDmg, 'steam');
        }

        // 2. TOXIC DETONATION: Burn + Poison -> "毒爆"
        if (this.burnTimer > 0 && this.poisonStacks > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('toxic_detonation');
            this.burnTimer = 0;
            const stacks = this.poisonStacks;
            this.poisonStacks = 0;
            this.poisonTimer = 0;

            const blastDmg = (stacks * 80) + (this.maxHealth * 0.05) + 100;

            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 60, "毒爆", "#be2edd", 40));
            for(let i=0; i<40; i++) {
                const color = Math.random() > 0.5 ? "#8e44ad" : "#2ecc71"; 
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, color, 10 + Math.random() * 5));
            }
            triggerScreenShake(15, 10);
            applyAreaDamage(this.positionX, this.positionY, 140, blastDmg, 'poison_blast');
        }

        // 3. ELECTRO-CHARGED: Shock + Soaked -> "感電"
        if (this.shockTimer > 0 && this.soakedTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('electro_charged');
            let chains = 0;
            const range = 250;

            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 50, "感電", "#f6e58d", 36));
            for(let i=0; i<25; i++) {
                const color = Math.random() > 0.5 ? "#f1c40f" : "#66fcf1"; 
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, color, 12));
            }

            activeEnemies.forEach(other => {
                if (chains >= 4) return;
                if (other === this || !other.isActive) return;

                const d = Math.hypot(other.positionX - this.positionX, other.positionY - this.positionY);
                if (d < range) {
                    activeProjectiles.push(new MagicProjectile(this.positionX, this.positionY, other, {
                        id: 'electric', 
                        damage: 50 + (engineState.currentLevel * 10), 
                        speed: 25, 
                        color: '#66fcf1', 
                        chain_count: 0
                    }));
                    chains++;
                }
            });
        }

        // 4. MELTDOWN: Burn + Freeze -> "融解"
        if (this.burnTimer > 0 && this.freezeTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('meltdown');
            this.burnTimer = 0;
            this.freezeTimer = 0;
            const meltDmg = (this.maxHealth * 0.25) + 300;

            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 70, "融解", "#fab1a0", 45));
            for(let i=0; i<30; i++) {
                const color = Math.random() > 0.5 ? "#ff7675" : "#74b9ff"; 
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, color, 6));
            }
            triggerScreenShake(8, 6);
            this.takeDamage(meltDmg, true, 'meltdown');
        }

        // 5. OVERLOAD: Burn + Shock -> "過負荷"
        if (this.burnTimer > 0 && this.shockTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('overload');
            this.burnTimer = 0;
            this.shockTimer = 0;
            // 威力調整: 割合ダメージ 10% -> 5%, 固定値 200 -> 100
            const overloadDmg = (this.maxHealth * 0.05) + 100;

            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 60, "過負荷", "#ff5252", 32));
            for(let i=0; i<30; i++) {
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, "#ff5252", 8));
            }
            triggerScreenShake(8, 6); // 揺れも少し抑えめに

            // 半径調整: 180 -> 130
            const range = 130;
            applyAreaDamage(this.positionX, this.positionY, range, overloadDmg, 'overload');

            activeEnemies.forEach(e => {
                if(!e.isActive) return;
                const d = Math.hypot(e.positionX - this.positionX, e.positionY - this.positionY);
                if(d < range && e.tier.id !== 'BOSS') {
                    const angle = Math.atan2(e.positionY - this.positionY, e.positionX - this.positionX);
                    // ノックバック調整: 60 -> 30
                    e.positionX += Math.cos(angle) * 30;
                    e.positionY += Math.sin(angle) * 30;
                }
            });
        }

        // 6. SUPERCONDUCT: Freeze + Shock -> "超電導"
        if (this.freezeTimer > 0 && this.shockTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('superconduct');
            this.freezeTimer = 0;
            this.shockTimer = 0;
            const superDmg = (this.maxHealth * 0.1) + 150;

            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 60, "超電導", "#a29bfe", 38));
            for(let i=0; i<30; i++) {
                const color = Math.random() > 0.5 ? "#dfe6e9" : "#6c5ce7"; 
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, color, 8));
            }
            triggerScreenShake(10, 5);
            applyAreaDamage(this.positionX, this.positionY, 200, superDmg, 'superconduct');
            createIceShatter(this.positionX, this.positionY, superDmg);
        }

        // --- NEW SYNERGIES (7-9) ---

        // 7. CORROSION: Poison + Soaked -> "腐食"
        // Effect: Acid cloud, high damage tick
        if (this.poisonStacks > 0 && this.soakedTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('corrosion');
            const stacks = this.poisonStacks;
            this.poisonStacks = 0; 
            this.soakedTimer = 0;
            // High base damage + stacks
            const acidDmg = 50 + (stacks * 30);

            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 60, "腐食", "#7fff00", 38));
            for(let i=0; i<25; i++) {
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, "#2ecc71", 6)); // Toxic Green
            }

            // Create a persistent acid zone
            activeZoneEffects.push(new ZoneEffect(this.positionX, this.positionY, 'POISON_CLOUD', { damage: acidDmg }));
            this.takeDamage(acidDmg * 2, true, 'corrosion');
        }

        // 8. PLAGUE: Poison + Shock -> "伝染"
        // Effect: Spreads poison to neighbors via lightning
        if (this.poisonStacks > 0 && this.shockTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('plague');
            // Keep poison stacks, spread them!
            const stacksToSpread = Math.max(1, this.poisonStacks);
            this.shockTimer = 0; // Consume shock

            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 60, "伝染", "#9b59b6", 36));
            for(let i=0; i<20; i++) {
                const color = Math.random() > 0.5 ? "#8e44ad" : "#f1c40f";
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, color, 8));
            }

            // Chain to neighbors
            const range = 250;
            let count = 0;
            activeEnemies.forEach(other => {
                if (count > 5) return;
                if (other === this || !other.isActive) return;
                const d = Math.hypot(other.positionX - this.positionX, other.positionY - this.positionY);
                if (d < range) {
                    // Spread poison
                    other.poisonStacks += stacksToSpread;
                    other.poisonTimer = 300;
                    other.takeDamage(stacksToSpread * 20, false, 'plague');

                    // Visual beam
                    activeProjectiles.push(new MagicProjectile(this.positionX, this.positionY, other, {
                        id: 'electric', 
                        damage: 10, 
                        speed: 30, 
                        color: '#9b59b6', // Purple lightning
                        chain_count: 0
                    }));
                    count++;
                }
            });
        }

        // 9. GLACIER: Freeze + Soaked -> "氷河"
        // Effect: Long freeze + Crushing damage
        if (this.freezeTimer > 0 && this.soakedTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('glacier');
            // Consume soaked, Extend freeze massively
            this.soakedTimer = 0;
            this.freezeTimer = 300; // 5 seconds freeze
            const crushDmg = (this.maxHealth * 0.2) + 100;

            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 70, "氷河", "#74b9ff", 42));
            for(let i=0; i<40; i++) {
                const color = Math.random() > 0.5 ? "#74b9ff" : "#ffffff";
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, color, 10)); // Big ice chunks
            }
            triggerScreenShake(10, 5);
            this.takeDamage(crushDmg, true, 'glacier');
        }

        // --- CHAOS SYNERGIES (Confusion + Elements) ---
        // Confused enemies act as conduits, creating zones on the ground

        // [Patch] Cooldown check to prevent lag spike / infinite loop
        if (this.chaosCooldown > 0) return;

        let chaosTriggered = false;

        // 10. CHAOS FLARE: Confusion + Burn
        if (this.confusionTimer > 0 && this.burnTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('chaos_flare');
            this.burnTimer = 0; 
            const dmg = 40 + (engineState.currentLevel * 5);
            activeZoneEffects.push(new ZoneEffect(this.positionX, this.positionY, 'FIRE_ZONE', { damage: dmg }));
            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 50, "カオスフレア", "#e74c3c", 24));
            chaosTriggered = true;
        }

        // 11. CHAOS MIASMA: Confusion + Poison
        if (this.confusionTimer > 0 && this.poisonStacks > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('chaos_miasma');
            this.poisonStacks = 0;
            const dmg = 30 + (engineState.currentLevel * 4);
            activeZoneEffects.push(new ZoneEffect(this.positionX, this.positionY, 'POISON_CLOUD', { damage: dmg }));
            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 50, "カオスマイズマ", "#8e44ad", 24));
            chaosTriggered = true;
        }

        // 12. CHAOS STORM: Confusion + Shock
        if (this.confusionTimer > 0 && this.shockTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('chaos_storm');
            this.shockTimer = 0;
            const dmg = 50 + (engineState.currentLevel * 6);
            activeZoneEffects.push(new ZoneEffect(this.positionX, this.positionY, 'STATIC_FIELD', { damage: dmg }));
            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 50, "カオスストーム", "#f1c40f", 24));
            chaosTriggered = true;
        }

        // 13. CHAOS FROST: Confusion + Freeze
        if (this.confusionTimer > 0 && this.freezeTimer > 0) {
            if (window.recordSynergyDiscovery) window.recordSynergyDiscovery('chaos_frost');
            this.freezeTimer = 0;
            const dmg = 20 + (engineState.currentLevel * 3);
            activeZoneEffects.push(new ZoneEffect(this.positionX, this.positionY, 'FREEZE_ZONE', { damage: dmg }));
            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 50, "カオスフロスト", "#74b9ff", 24));
            chaosTriggered = true;
        }

        if (chaosTriggered) {
            this.chaosCooldown = 60; // 1 second cooldown
        }
    }

    update() {
        // 死亡演出（ボスの沈下）
        if (this.isDying) {
            this.deathProgress += 0.015; // アニメーション速度
            this.positionY += 1.5;      // 下に沈む
            if (this.deathProgress >= 1.0) {
                this.isActive = false;
            }
            return;
        }

        // Time Stop Check
        if (engineState.timeStopTimer > 0) return;

        // [Patch] Chaos Synergy Cooldown Tick
        if (this.chaosCooldown > 0) this.chaosCooldown--;

        // [Patch] Leech Effect
        if (this.leechTimer > 0) {
            this.leechTimer--;
            if (this.leechTimer % 30 === 0) {
                const amount = this.leechPower;
                const maxHP = GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max;
                if (engineState.baseIntegrity < maxHP) {
                    engineState.baseIntegrity = Math.min(engineState.baseIntegrity + amount, maxHP);
                    activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY, `+${Math.floor(amount)}`, "#2ecc71", 14));
                }
                this.takeDamage(amount, false, 'leech_dot');
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, "#2ecc71", 2));
            }
        }

        if (this.confusionTimer > 0) {
            this.confusionTimer--;
            let target = null;
            let minD = Infinity;
            for (const other of activeEnemies) {
                if (other !== this && other.isActive && other.confusionTimer <= 0) {
                    const d = Math.hypot(other.positionX - this.positionX, other.positionY - this.positionY);
                    if (d < minD) { minD = d; target = other; }
                }
            }

            if (target) {
                const dx = target.positionX - this.positionX;
                const dy = target.positionY - this.positionY;
                const dist = Math.hypot(dx, dy);
                if (dist > 5) {
                    this.positionX += (dx/dist) * this.baseSpeed * 2;
                    this.positionY += (dy/dist) * this.baseSpeed * 2;
                }
                if (dist < (this.size + target.size) * 0.8) {
                    target.takeDamage(this.maxHealth * 0.05, true, 'betrayal');
                    activeParticles.push(new ParticleEffect(target.positionX, target.positionY, "#e056fd", 3));
                    if (this.confusionTimer % 30 === 0) activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY, "ATTACK!", "#e056fd", 14));
                }
            }
        } 
        else if (this.freezeTimer > 0 || this.stunTimer > 0) {
            if (this.freezeTimer > 0) this.freezeTimer--;
            if (this.stunTimer > 0) this.stunTimer--;
        }
        else {
            let moveSpeed = this.baseSpeed;
            let canMove = true;

            if (this.soakedTimer > 0) {
                this.soakedTimer--;
                moveSpeed *= 0.5; 
                if (this.soakedTimer % 30 === 0) activeParticles.push(new ParticleEffect(this.positionX, this.positionY + this.size/2, "#3498db", 1));
            }

            // Artifact: Gravity Anchor
            if (engineState.isShieldActive && engineState.artifacts.some(a => a.id === 'gravity_anchor')) {
                moveSpeed *= 0.2; // 80% Slow
                if (engineState.shieldTimer % 10 === 0) activeParticles.push(new ParticleEffect(this.positionX, this.positionY, "#2c3e50", 4));
            }

            if (this.shockTimer > 0) {
                this.shockTimer--;
                if (this.shockTimer <= 0) this.shockMultiplier = 1.0; 
                if (this.shockTimer % 15 === 0) {
                    activeParticles.push(new ParticleEffect(this.positionX + (Math.random()-0.5)*this.size, this.positionY + (Math.random()-0.5)*this.size, "#f1c40f", 2));
                }
            }

            if (this.acidTimer > 0) {
                this.acidTimer--;
                // Acid dripping effect
                if (this.acidTimer % 10 === 0) {
                    activeParticles.push(new ParticleEffect(this.positionX + (Math.random()-0.5)*this.size, this.positionY, "#2ecc71", 3));
                }
            }

            if (canMove) {
                if (this.tier.id === 'BOSS') {
                    if (this.bossState === 'ENTER') {
                        // [Patch] Boss Enter Speed Up
                        this.positionY += Math.max(moveSpeed * 3.0, 2.5);
                        if (this.positionY >= 120) this.bossState = 'FIGHT';
                    } else {
                        // [Patch] Boss Anchor Logic (Prevent knockback OOB)
                        // 強制的にY=120付近に戻す力を働かせ、画面外への逸脱を防ぐ
                        const targetY = 120;
                        const drift = targetY - this.positionY;
                        this.positionY += drift * 0.1; 

                        this.moveAngle += 0.02;
                        this.positionX += Math.sin(this.moveAngle) * 0.5;

                        // 召喚ロジック (Wave 4 以降のボス)
                        if (engineState.currentWaveNumber >= 4) {
                            this.summonTimer--;
                            if (this.summonTimer <= 0) {
                                this.performSummon();
                                this.summonTimer = 400 + Math.random() * 200; // 次の召喚まで
                            }
                        }

                        this.attackTimer++;
                        if (this.attackTimer > 60) { 
                            const bullet = new EnemyProjectile(this.positionX, this.positionY + 40);
                            activeEnemyProjectiles.push(bullet);
                            this.attackTimer = 0;
                            activeParticles.push(new ParticleEffect(this.positionX, this.positionY + 40, "#e74c3c", 4));
                        }
                    }
                } else {
                    // [Patch] Unique Enemy Behaviors
                    if (this.tier.id === 'ROGUE') {
                        // Zig-Zag Movement
                        this.moveAngle += 0.15;
                        this.positionX += Math.sin(this.moveAngle) * 2.5;
                        // Keep within bounds
                        if (this.positionX < 30) this.positionX = 30;
                        if (this.positionX > GAME_SETTINGS.SCREEN_WIDTH - 30) this.positionX = GAME_SETTINGS.SCREEN_WIDTH - 30;

                        this.positionY += moveSpeed;
                    } 
                    else if (this.tier.id === 'SWARM') {
                        // Rush when close
                        const distToCastle = GAME_SETTINGS.CASTLE_Y - this.positionY;
                        const swarmMod = distToCastle < 300 ? 1.8 : 1.0;
                        this.positionY += moveSpeed * swarmMod;
                    }
                    else {
                        // TANK, NORMAL, MAGIC, RARE
                        this.positionY += moveSpeed;
                    }
                }
            }
        }

        if (this.burnTimer > 0) {
            this.burnTimer--;
            if (this.burnTimer % EFFECT_CONSTANTS.BURN_TICK_RATE === 0) {
                const dmg = this.burnDamagePerTick;
                this.takeDamage(dmg, false, 'burn_dot');
                // Artifact: Xeno Cell (Heal 10% of DoT)
                if (engineState.artifacts.some(a => a.id === 'xeno_cell')) {
                    engineState.baseIntegrity = Math.min(GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max, engineState.baseIntegrity + (dmg * 0.1));
                }
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, EFFECT_CONSTANTS.COLOR_BURN, 2));
            }
        }
        if (this.poisonTimer > 0) {
            this.poisonTimer--;
            if (this.poisonTimer % 30 === 0) { 
                const dmg = (this.poisonDamage || 5) * this.poisonStacks;
                this.takeDamage(dmg, false, 'poison_dot');
                // Artifact: Xeno Cell (Heal 10% of DoT)
                if (engineState.artifacts.some(a => a.id === 'xeno_cell')) {
                    engineState.baseIntegrity = Math.min(GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max, engineState.baseIntegrity + (dmg * 0.1));
                }
                activeParticles.push(new ParticleEffect(this.positionX, this.positionY, "#8e44ad", 2));
            }
        }

        if (this.health <= 0 && this.isActive) handleEnemyDeath(this, false);
        if (this.flashTime > 0) this.flashTime--;

        // [Patch] Improved Shield Collision (Hitbox Extended Upwards)
        // シールド有効時は、ドーム状のシールド判定を行う
        if (engineState.isShieldActive && engineState.energy > 15) {
            // ドームの高さに合わせて判定ラインを調整
            if (this.positionY + (this.size / 2) > GAME_SETTINGS.CASTLE_Y - 60) {
                // Shield Bash Logic
                // Artifact: Spike Shield (shield_bash_mul)
                const bashMult = 1 + (engineState.stats.shield_bash_mul || 0);
                const bashDamage = (50 + (engineState.currentLevel * 10)) * bashMult;

                this.takeDamage(bashDamage, false, 'shield_bash');

                engineState.energy -= 15; // Consume MP
                engineState.shieldImpactTimer = 10; // Trigger shield flash
                triggerScreenShake(8, 5);

                // Massive Impact Effect
                for(let i=0; i<10; i++) {
                    activeParticles.push(new ParticleEffect(this.positionX, this.positionY + (this.size/2), "#ffffff", 12));
                    activeParticles.push(new ParticleEffect(this.positionX, this.positionY + (this.size/2), "#66fcf1", 8));
                }

                activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 40, "SHIELD BASH!", "#fff", 30));

                if (this.health <= 0) {
                    this.isActive = false;
                    handleEnemyDeath(this, false); 
                } else {
                    // Knockback to safe distance (Prevent getting stuck)
                    this.positionY = GAME_SETTINGS.CASTLE_Y - 100; 
                    this.stunTimer = 30;
                }
                return; // Prevent falling through to castle damage
            }
        }

        // Castle Damage Logic (If passed shield or shield inactive)
        if (this.positionY > GAME_SETTINGS.CASTLE_Y) {
            // Artifact: Midas Coin (Spend gold to negate damage)
            if (engineState.gold >= 10 && engineState.artifacts.some(a => a.id === 'midas_coin')) {
                engineState.gold -= 10;
                activeFloatingTexts.push(new FloatingText(this.positionX, GAME_SETTINGS.CASTLE_Y, "-10G GUARD", "#fdcb6e", 16));
                this.isActive = false;
                return;
            }

            let dmg = GAME_SETTINGS.CASTLE_DAMAGE;
            // Apply Damage Taken Multiplier (e.g. Glass Cannon)
            dmg *= (1.0 + (engineState.stats.damage_taken_mul || 0));

            engineState.baseIntegrity -= dmg;
            triggerScreenShake(10, 5); 
            audioManager.play('WARNING');
            this.isActive = false;
        }
    }

    takeDamage(damage, isCritical, sourceId) {
            let finalDamage = damage;
            const artifacts = engineState.artifacts;

            // Artifact: Giant Killer
            const giantKiller = artifacts.find(a => a.id === 'giant_killer');
            if ((this.tier.id === 'BOSS' || this.tier.id === 'TANK') && giantKiller) {
                finalDamage *= (giantKiller.config ? giantKiller.config.multiplier : 1.4);
            }

            // Artifact: Sniper Scope (Distance Bonus: Top half of screen)
            const sniperScope = artifacts.find(a => a.id === 'sniper_scope');
            if (sniperScope) {
                const rangeY = sniperScope.config ? sniperScope.config.range_y : 400;
                if (this.positionY < rangeY) {
                    finalDamage *= (sniperScope.config ? sniperScope.config.multiplier : 1.3);
                }
            }

            // Artifact: Elemental Mixer (2+ Statuses)
            if (artifacts.some(a => a.id === 'elem_mixer')) {
                let statusCount = 0;
                if (this.burnTimer > 0) statusCount++;
                if (this.poisonStacks > 0) statusCount++;
                if (this.freezeTimer > 0) statusCount++;
                if (this.shockTimer > 0) statusCount++;
                if (this.soakedTimer > 0) statusCount++;
                if (this.confusionTimer > 0) statusCount++;

                if (statusCount >= 2) finalDamage *= 1.5;
            }

            // Artifact: Oil Flask (Direct hit boost for fireball)
            const oilFlask = artifacts.find(a => a.id === 'oil_flask');
            if (sourceId === 'fireball' && oilFlask) {
                finalDamage *= (oilFlask.config ? oilFlask.config.multiplier : 1.5); 
            }

            // Artifact: Zero Crystal (Instant Kill Check)
            if (this.freezeTimer > 0 && artifacts.some(a => a.id === 'zero_crystal')) {
                // No instant kill on Bosses
                if (this.tier.id !== 'BOSS' && Math.random() < 0.1) {
                    finalDamage = this.health + 9999; 
                    activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY, "INSTANT KILL", "#74b9ff", 24));
                }
            }

            // Shock Multiplier
            if (this.shockTimer > 0) {
                finalDamage *= this.shockMultiplier;
            }

            // Dr. Xeno: Acid Multiplier (Vulnerability)
            if (this.acidTimer > 0) {
                finalDamage *= 2.0; 
            }

            this.health -= finalDamage;
            this.flashTime = 5;

            // クリティカル時にヒットストップを発動 (約0.05秒)
            if (isCritical) {
                engineState.hitStopFrames = 3; 
            }

            // Knockback Logic
            if (this.freezeTimer <= 0 && sourceId !== 'burn_dot' && sourceId !== 'poison_dot' && sourceId !== 'leech_dot') {
                if (this.tier.id === 'TANK') {
                    this.positionY -= 1; 
                } else if (this.tier.id !== 'BOSS') {
                    this.positionY -= 5;
                }
            } 

            // [Patch] Synergy Damage Colors
            let popupColor = EFFECT_CONSTANTS.COLOR_NORMAL;
            if (sourceId === 'steam') popupColor = "#dff9fb";        
            else if (sourceId === 'poison_blast') popupColor = "#be2edd"; 
            else if (sourceId === 'electric') popupColor = "#f6e58d";     
            else if (sourceId === 'meltdown') popupColor = "#fab1a0";     
            else if (sourceId === 'overload') popupColor = "#ff5252";     
            else if (sourceId === 'superconduct') popupColor = "#a29bfe"; 
            else if (sourceId === 'corrosion') popupColor = "#7fff00";    
            else if (sourceId === 'plague') popupColor = "#9b59b6";       
            else if (sourceId === 'glacier') popupColor = "#74b9ff";      
            else if (sourceId === 'shield_bash') popupColor = "#66fcf1";  
            else if (sourceId === 'burn_dot') popupColor = EFFECT_CONSTANTS.COLOR_BURN;
            else if (isCritical) popupColor = EFFECT_CONSTANTS.COLOR_CRIT;

            const synergyIds = [
                'steam','poison_blast','electric','meltdown','overload','superconduct','corrosion','plague','glacier'
            ];
            const fontSize = (isCritical || synergyIds.includes(sourceId)) ? 28 : 18;
            const displayText = isCritical ? `${Math.floor(finalDamage)}!` : `${Math.floor(finalDamage)}`;
            activeFloatingTexts.push(new FloatingText(this.positionX, this.positionY - 20, displayText, popupColor, fontSize));
            audioManager.play('HIT');
        }

    draw(context) {
        context.save();

        if (this.isDying) {
            // 徐々に透明にし、小さくする
            context.globalAlpha = Math.max(0, 1.0 - this.deathProgress);
            const deathScale = 1.0 - (this.deathProgress * 0.4);
            context.translate(this.positionX, this.positionY);
            context.scale(deathScale, deathScale);
            context.translate(-this.positionX, -this.positionY);
        }

        // 1. Target Marker
        if (engineState.manualTargetId === this.id) {
            context.strokeStyle = EFFECT_CONSTANTS.COLOR_TARGET;
            context.lineWidth = 2;
            context.beginPath();
            context.arc(this.positionX, this.positionY, this.size * 0.8, 0, Math.PI * 2);
            context.stroke();
        }

        // 2. Determine Color based on Status
        if (this.flashTime > 0) context.fillStyle = "#ffffff";
        else if (this.confusionTimer > 0) context.fillStyle = "#e056fd";
        else if (this.freezeTimer > 0) context.fillStyle = EFFECT_CONSTANTS.COLOR_FREEZE;
        else if (this.stunTimer > 0) context.fillStyle = "#7f8c8d";
        else if (this.burnTimer > 0) context.fillStyle = EFFECT_CONSTANTS.COLOR_BURN;
        else if (this.poisonTimer > 0) context.fillStyle = "#8e44ad";
        else if (this.soakedTimer > 0) context.fillStyle = "#3498db";
        else if (this.shockTimer > 0) context.fillStyle = "#f1c40f";
        else if (this.leechTimer > 0) context.fillStyle = "#2ecc71";
        else context.fillStyle = this.tier.color;

        const drawSize = this.size;
        const halfSize = drawSize / 2;

        // 3. Draw Shape based on Tier ID
        context.shadowBlur = 10;
        context.shadowColor = this.tier.color;

        context.beginPath();
        if (this.tier.id === 'BOSS') {
            // Hexagon with rotation
            const rot = Date.now() / 1000;
            for (let i = 0; i < 6; i++) {
                const angle = rot + (i * Math.PI / 3);
                const x = this.positionX + Math.cos(angle) * halfSize;
                const y = this.positionY + Math.sin(angle) * halfSize;
                if (i === 0) context.moveTo(x, y);
                else context.lineTo(x, y);
            }
            context.closePath();
        } 
        else if (this.tier.id === 'TANK') {
            // Heavy Square
            context.rect(this.positionX - halfSize, this.positionY - halfSize, drawSize, drawSize);
        }
        else if (this.tier.id === 'ROGUE') {
            // Triangle pointing down (V shape)
            context.moveTo(this.positionX - halfSize, this.positionY - halfSize);
            context.lineTo(this.positionX + halfSize, this.positionY - halfSize);
            context.lineTo(this.positionX, this.positionY + halfSize);
            context.closePath();
        }
        else if (this.tier.id === 'SWARM') {
            // Diamond / Rhombus
            context.moveTo(this.positionX, this.positionY - halfSize);
            context.lineTo(this.positionX + halfSize, this.positionY);
            context.lineTo(this.positionX, this.positionY + halfSize);
            context.lineTo(this.positionX - halfSize, this.positionY);
            context.closePath();
        }
        else {
            // NORMAL / MAGIC / RARE: Circle or Standard
            if (this.tier.id === 'MAGIC') {
                 // Star-ish (Pentagon)
                for (let i = 0; i < 5; i++) {
                    const angle = (i * Math.PI * 2 / 5) - Math.PI/2;
                    const x = this.positionX + Math.cos(angle) * halfSize;
                    const y = this.positionY + Math.sin(angle) * halfSize;
                    if (i === 0) context.moveTo(x, y);
                    else context.lineTo(x, y);
                }
                context.closePath();
            } else {
                // Normal Circle
                context.arc(this.positionX, this.positionY, halfSize, 0, Math.PI * 2);
            }
        }
        context.fill();

        // 4. Inner Details (Eyes/Core)
        context.fillStyle = "rgba(0,0,0,0.5)";
        context.beginPath();
        if (this.tier.id === 'ROGUE') {
             context.arc(this.positionX, this.positionY - 5, 4, 0, Math.PI*2);
        } else {
             context.arc(this.positionX, this.positionY, 4, 0, Math.PI*2);
        }
        context.fill();

        // 5. Status Icons
        if (this.confusionTimer > 0) {
            context.fillStyle = "#fff";
            context.font = "bold 14px Arial";
            context.fillText("?", this.positionX + halfSize, this.positionY - halfSize);
        }
        if (this.poisonStacks > 0) {
            context.fillStyle = "#8e44ad";
            context.font = "10px Arial";
            context.fillText(`${this.poisonStacks}`, this.positionX, this.positionY + 5);
        }

        // 6. Health Bar & Numeric HP Display (Strategic Placement)
        context.shadowBlur = 0;
        const isBoss = this.tier.id === 'BOSS';
        const hpBarW = isBoss ? 100 : 40; 
        const hpBarH = isBoss ? 8 : 4;   

        // 描画位置の決定: ボスは下、ザコは上
        const hpY = isBoss ? (this.positionY + halfSize + 15) : (this.positionY - halfSize - 15);

        // 背景（黒枠）
        context.fillStyle = "rgba(0, 0, 0, 0.8)";
        context.fillRect(this.positionX - hpBarW/2 - 1, hpY - 1, hpBarW + 2, hpBarH + 2);

        // バー本体
        context.fillStyle = "#222";
        context.fillRect(this.positionX - hpBarW/2, hpY, hpBarW, hpBarH);

        const hpColor = this.freezeTimer > 0 ? "#74b9ff" : (isBoss ? "#ff3f34" : "#2ecc71");
        context.fillStyle = hpColor;
        const healthRatio = Math.max(0, this.health / this.maxHealth);
        context.fillRect(this.positionX - hpBarW/2, hpY, hpBarW * healthRatio, hpBarH);

        // ボスの場合、体の中央に残りHP数値を表示
        if (isBoss) {
            context.font = "bold 16px 'Consolas', 'Monaco', monospace"; // デジタル感のあるフォント
            context.textAlign = "center";
            context.textBaseline = "middle";
            const displayHp = Math.ceil(this.health).toLocaleString();

            // 視認性のためのドロップシャドウ/縁取り
            context.strokeStyle = "#000";
            context.lineWidth = 4;
            context.strokeText(displayHp, this.positionX, this.positionY);

            // ネオンカラーの数値
            context.fillStyle = "#fff";
            context.fillText(displayHp, this.positionX, this.positionY);

            // ボス名を表示 (バーのすぐ下)
            context.font = "bold 10px sans-serif";
            context.fillStyle = "#aaa";
            context.fillText(this.tier.name, this.positionX, hpY + hpBarH + 10);
        }

        context.restore();
    }
}

class ZoneEffect {
    constructor(x, y, type, config) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.life = 300; // 5 seconds
        this.maxLife = 300;
        this.radius = 100; // Large area
        this.config = config;
        this.tickTimer = 0;
        this.rotation = Math.random() * Math.PI * 2;

        // [Patch] Spike Trap Settings
        if (this.type === 'SPIKE_TRAP') {
            this.life = 600; // 10 seconds duration
            this.maxLife = 600;
            this.radius = 25; // Small trigger radius
        }
    }

    update() {
        this.life--;
        this.tickTimer++;
        this.rotation += 0.01;

        // [Patch] Spike Trap Logic: Trigger on contact
        if (this.type === 'SPIKE_TRAP') {
            for (const enemy of activeEnemies) {
                if (!enemy.isActive) continue;
                const d = Math.hypot(enemy.positionX - this.x, enemy.positionY - this.y);
                // Hitbox overlap check
                if (d < this.radius + (enemy.size / 2)) {
                    // Trigger Trap
                    const dmg = this.config.damage || 50;
                    enemy.takeDamage(dmg, false, 'spike_trap');
                    activeParticles.push(new ParticleEffect(this.x, this.y, "#7f8c8d", 8));
                    activeFloatingTexts.push(new FloatingText(this.x, this.y, "BOOM!", "#7f8c8d", 24));
                    triggerScreenShake(5, 3);
                    this.life = 0; // Destroy trap immediately
                    break; 
                }
            }
            return; // Skip normal tick logic
        }

        // Apply effects every 0.33s (20 ticks)
        if (this.tickTimer % 20 === 0) {
            const damage = this.config.damage || 10;

            for (const enemy of activeEnemies) {
                if (!enemy.isActive) continue;
                const d = Math.hypot(enemy.positionX - this.x, enemy.positionY - this.y);

                if (d < this.radius) {
                    if (this.type === 'POISON_CLOUD') {
                        enemy.applyStatus('POISON', damage * 0.5);
                    } 
                    else if (this.type === 'FIRE_ZONE') {
                        enemy.takeDamage(damage, false, 'fire_zone');
                        enemy.applyStatus('BURN', damage * 0.2);
                    }
                    else if (this.type === 'STATIC_FIELD') {
                        enemy.takeDamage(damage * 0.8, false, 'static_field');
                        if (Math.random() < 0.3) enemy.applyStatus('SHOCK', damage);
                    }
                    else if (this.type === 'FREEZE_ZONE') {
                        enemy.takeDamage(damage * 0.5, false, 'freeze_zone');
                        // Slow down or freeze
                        if (Math.random() < 0.2) enemy.applyStatus('FREEZE');
                        else enemy.applyStatus('SOAKED'); // Wet/Slow effect
                    }
                }
            }
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        // [Patch] Spike Trap Visuals
        if (this.type === 'SPIKE_TRAP') {
             ctx.fillStyle = "#95a5a6";
             ctx.beginPath();
             // Draw spiky shape
             for(let i=0; i<8; i++) {
                 const angle = (Math.PI * 2 / 8) * i;
                 const r = (i % 2 === 0) ? this.radius : this.radius * 0.4;
                 const px = Math.cos(angle) * r;
                 const py = Math.sin(angle) * r;
                 if (i===0) ctx.moveTo(px, py);
                 else ctx.lineTo(px, py);
             }
             ctx.closePath();
             ctx.fill();

             // Blinking red light center
             if (Math.floor(Date.now() / 200) % 2 === 0) {
                 ctx.fillStyle = "#e74c3c";
                 ctx.beginPath(); ctx.arc(0,0, 5, 0, Math.PI*2); ctx.fill();
             }
             ctx.restore();
             return;
        }

        const opacity = (this.life / this.maxLife) * 0.6;
        ctx.globalAlpha = opacity;

        let mainColor = "#fff";
        let subColor = "#fff";

        if (this.type === 'POISON_CLOUD') { mainColor = "#8e44ad"; subColor = "#2ecc71"; }
        else if (this.type === 'FIRE_ZONE') { mainColor = "#e74c3c"; subColor = "#f39c12"; }
        else if (this.type === 'STATIC_FIELD') { mainColor = "#f1c40f"; subColor = "#66fcf1"; }
        else if (this.type === 'FREEZE_ZONE') { mainColor = "#74b9ff"; subColor = "#dfe6e9"; }

        // Draw Zone Base
        ctx.fillStyle = mainColor;
        ctx.beginPath(); 
        ctx.arc(0, 0, this.radius, 0, Math.PI*2); 
        ctx.fill();

        // Draw Swirl Effect
        ctx.strokeStyle = subColor;
        ctx.lineWidth = 4;
        ctx.beginPath();
        for(let i=0; i<3; i++) {
            const r = this.radius * (0.3 + (i * 0.2));
            const start = i * 2;
            ctx.arc(0, 0, r, start, start + 3);
        }
        ctx.stroke();

        ctx.restore();
    }
}

class EnemyProjectile {
    constructor(x, y, isReflected = false) {
        this.x = x;
        this.y = y;
        this.speed = isReflected ? -12 : 6;
        this.size = 8;
        // [Patch] Configurable Enemy Damage
        this.damage = GAME_SETTINGS.ENEMY_PROJECTILE_DAMAGE !== undefined ? GAME_SETTINGS.ENEMY_PROJECTILE_DAMAGE : 15;
        this.isAlive = true;
        this.isReflected = isReflected;
        this.color = isReflected ? "#66fcf1" : "#e74c3c";
    }

    update() {
        this.y += this.speed;
        if (this.isReflected) {
            if (this.y < -50) this.isAlive = false;
            for (const enemy of activeEnemies) {
                if (!enemy.isActive) continue;
                const dist = Math.hypot(enemy.positionX - this.x, enemy.positionY - this.y);
                if (dist < enemy.size + this.size) {
                    enemy.takeDamage(500, true, 'reflected_orb');
                    this.isAlive = false;
                    activeParticles.push(new ParticleEffect(this.x, this.y, "#66fcf1", 8));
                    break;
                }
            }
            return;
        }

        if (engineState.isShieldActive) {
            const distToCastle = GAME_SETTINGS.CASTLE_Y - this.y;
            // ドーム高さに合わせて判定距離を調整
            if (distToCastle < 75 && distToCastle > 0) {
                if (engineState.shieldTimer < 20) { // [Patch] Ease JG window (15->20)
                    this.isReflected = true;
                    this.speed = -15;
                    this.color = "#66fcf1";
                    activeFloatingTexts.push(new FloatingText(this.x, this.y, "PERFECT!", "#66fcf1", 28));
                    engineState.energy = Math.min(engineState.maxEnergy, engineState.energy + 15);
                    triggerScreenShake(5, 5);

                    // Artifact: Mana Converter
                    const manaConv = engineState.artifacts.find(a => a.id === 'mana_conv');
                    if (manaConv) {
                        const heal = manaConv.config ? manaConv.config.heal_amount : 20;
                        const maxHP = GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max;
                        engineState.baseIntegrity = Math.min(engineState.baseIntegrity + heal, maxHP);
                        activeFloatingTexts.push(new FloatingText(this.x, this.y - 30, `HP+${heal}`, "#3498db", 16));
                    }
                    // Artifact: Reflect Prism
                    if (engineState.artifacts.some(a => a.id === 'reflect_prism')) {
                        applyAreaDamage(this.x, this.y, 200, 100 + (engineState.currentLevel * 5), 'nova');
                    }

                } else {
                    engineState.energy -= 10;
                    activeFloatingTexts.push(new FloatingText(this.x, this.y, "BLOCKED", "#ccc", 18));
                    activeParticles.push(new ParticleEffect(this.x, this.y, "#66fcf1", 6));
                    this.isAlive = false;
                }
                return;
            }
        }

        if (this.y >= GAME_SETTINGS.CASTLE_Y) {
            let dmg = this.damage;
            // Apply Damage Taken Multiplier (e.g. Glass Cannon)
            dmg *= (1.0 + (engineState.stats.damage_taken_mul || 0));

            engineState.baseIntegrity -= dmg;
            activeParticles.push(new ParticleEffect(this.x, this.y, "#e74c3c", 6));
            triggerScreenShake(5, 2);
            this.isAlive = false;
        }
        if (this.y > GAME_SETTINGS.SCREEN_HEIGHT) this.isAlive = false;
    }

    draw(ctx) {
        ctx.save();
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

// --- Logic Helpers ---

function createIceShatter(centerX, centerY, damage) {
    const shardDamage = damage * 0.5;
    const shardCount = EFFECT_CONSTANTS.SHATTER_PROJECTILE_COUNT;
    for (let i = 0; i < shardCount; i++) {
        const angle = (Math.PI * 2 / shardCount) * i;
        const vx = Math.cos(angle) * EFFECT_CONSTANTS.SHATTER_SPEED;
        const vy = Math.sin(angle) * EFFECT_CONSTANTS.SHATTER_SPEED;
        activeProjectiles.push(new MagicProjectile(centerX, centerY, null, {
            damage: shardDamage,
            speed: EFFECT_CONSTANTS.SHATTER_SPEED,
            color: "#a29bfe",
            id: 'shatter_shard',
            isShatter: true,
            pierce_count: 2,
            velocityX: vx,
            velocityY: vy
        }));
    }
    activeFloatingTexts.push(new FloatingText(centerX, centerY, "SHATTER!", "#74b9ff", 22));
}

function applyAreaDamage(centerX, centerY, radius, damage, sourceId) {
    // [Patch] Rock Spikes (Mines) - Configurable
    if (sourceId === 'rock') {
        const base = GAME_SETTINGS.ROCK_SPIKES_BASE !== undefined ? GAME_SETTINGS.ROCK_SPIKES_BASE : 3;
        const variance = GAME_SETTINGS.ROCK_SPIKES_VAR !== undefined ? GAME_SETTINGS.ROCK_SPIKES_VAR : 3;
        const spikeCount = base + Math.floor(Math.random() * variance);

        for (let i = 0; i < spikeCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * radius * 0.8;
            const sx = centerX + Math.cos(angle) * dist;
            const sy = centerY + Math.sin(angle) * dist;
            // Spikes deal heavy physical damage
            activeZoneEffects.push(new ZoneEffect(sx, sy, 'SPIKE_TRAP', { damage: damage * 1.5 }));
        }
    }

    const finalRadius = radius * (1.0 + (engineState.stats.aoe_pct || 0));
    const color = sourceId === 'fireball' ? "#e67e22" : (sourceId === 'rock' ? "#7f8c8d" : "#3498db");

    // Shockwave Effect (Arcade Upgrade)
    activeShockwaves.push(new ShockwaveEffect(centerX, centerY, color, finalRadius));

    for (let i = 0; i < 15; i++) {
        activeParticles.push(new ParticleEffect(centerX, centerY, color, 6));
    }
    activeEnemies.forEach(enemy => {
        if (!enemy.isActive) return;
        const dist = Math.hypot(enemy.positionX - centerX, enemy.positionY - centerY);
        if (dist <= finalRadius + (enemy.size/2)) { 
            enemy.takeDamage(damage, false, sourceId);
            if (engineState.recordDamage) engineState.recordDamage(sourceId, damage);

            if (sourceId === 'nova' && Math.random() < EFFECT_CONSTANTS.FREEZE_CHANCE) {
                enemy.applyStatus('FREEZE');
                 activeFloatingTexts.push(new FloatingText(enemy.positionX, enemy.positionY - 40, "FROZEN", "#74b9ff", 14));
            }
            if (sourceId === 'fireball') {
                enemy.applyStatus('BURN', damage);
            }
        }
    });
}

function handleEnemyDeath(enemy, isCrit, shatterDamage = 10) {
    if (!enemy.isActive || enemy.isDying) return;

    const isBoss = enemy.tier.id === 'BOSS';

    if (isBoss) {
        enemy.isDying = true;
        enemy.deathProgress = 0;
    } else {
        enemy.isActive = false;
    }

    if (isCrit) triggerScreenShake(5, 3);
    if (enemy.freezeTimer > 0) createIceShatter(enemy.positionX, enemy.positionY, shatterDamage);

    // Artifact: Corrosive Crown
    if (enemy.poisonStacks > 0 && engineState.artifacts.some(a => a.id === 'corrosive_crown')) {
         activeZoneEffects.push(new ZoneEffect(enemy.positionX, enemy.positionY, 'POISON_CLOUD', { damage: 20 }));
    }

    // Artifact: Vampire Cup
    const vampireCup = engineState.artifacts.find(a => a.id === 'vampire_cup');
    if (vampireCup) {
        const pct = vampireCup.config ? vampireCup.config.heal_pct : 0.01;
        const heal = (GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max) * pct;
        engineState.baseIntegrity = Math.min(engineState.baseIntegrity + heal, GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max);
    }

    // Artifact: Ancient Coin
    const ancientCoin = engineState.artifacts.find(a => a.id === 'ancient_coin');
    if (ancientCoin) {
        const chance = ancientCoin.config ? ancientCoin.config.chance : 0.05;
        const amount = ancientCoin.config ? ancientCoin.config.amount : 10;
        if (Math.random() < chance) {
            engineState.gold += amount;
            activeFloatingTexts.push(new FloatingText(enemy.positionX, enemy.positionY, `+${amount}G`, "#f1c40f", 14));
        }
    }

    for(let i=0; i<EFFECT_CONSTANTS.PARTICLE_COUNT; i++) activeParticles.push(new ParticleEffect(enemy.positionX, enemy.positionY, "#e74c3c"));
    let xpGain = (20 * enemy.tier.xpMod) * (1.0 + engineState.stats.xp_gain);
    const amulet = engineState.equippedArtifacts.AMULET;
    if (amulet && amulet.stats && amulet.stats.xp_gain) xpGain *= (1 + amulet.stats.xp_gain);

    addExperience(xpGain);
    if (Math.random() < GAME_SETTINGS.DROP_CHANCE) generateDrop(enemy.positionX, enemy.positionY);
    audioManager.play('EXPLOSION');
    engineState.checkProgression(enemy);
}

function selectEnemyHelper(enemyList, criteria) {
    if (!enemyList || enemyList.length === 0) return null;
    let selectedEnemy = enemyList[0];
    switch (criteria) {
        case SELECTION_CRITERIA.MIN_DIST:
            let minDistance = Infinity;
            enemyList.forEach(enemyUnit => {
                const distance = Math.hypot(enemyUnit.positionX - RENDER_CONSTANTS.TURRET_POS_X, enemyUnit.positionY - RENDER_CONSTANTS.TURRET_POS_Y);
                if (distance < minDistance) {
                    minDistance = distance;
                    selectedEnemy = enemyUnit;
                }
            });
            break;
        case SELECTION_CRITERIA.MAX_HP:
            selectedEnemy = enemyList.reduce((prev, curr) => (prev.health > curr.health) ? prev : curr);
            break;
        case SELECTION_CRITERIA.MIN_HP:
            selectedEnemy = enemyList.reduce((prev, curr) => (prev.health < curr.health) ? prev : curr);
            break;
    }
    return selectedEnemy;
}

function getTarget() {
    if (engineState.manualTargetId) {
        const manualTarget = activeEnemies.find(e => e.id === engineState.manualTargetId);
        if (manualTarget && manualTarget.isActive) return manualTarget;
        else engineState.manualTargetId = null;
    }
    if (customAiFunction) {
        try {
            return customAiFunction(activeEnemies, selectEnemyHelper);
        } catch (errorInstance) { console.warn("AI Error"); }
    }
    return selectEnemyHelper(activeEnemies, SELECTION_CRITERIA.MIN_DIST);
}

function handleAutoAttack() {
    const loadouts = [
        { gems: engineState.equippedGems, isMain: true, scale: 1.0 },
        { gems: engineState.altGems,      isMain: false, scale: 0.5 }
    ];
    loadouts.forEach(loadout => {
        const activeGem = loadout.gems[0];
        if (!activeGem) return;

        const target = getTarget();
        // [Patch] Prevent firing at nothing unless it's an area/random skill
        const isAreaSkill = ['nova', 'rock'].includes(activeGem.id);
        if (!target && !isAreaSkill) return;

        const supportGems = loadout.gems.slice(1).filter(gem => gem !== null);
        let damageMod = 1.0 + engineState.stats.damage_pct;
        let rateMod = 1.0 + engineState.stats.rate_pct;
        let supportPower = 1.0 + engineState.stats.support_effect;
        let finalFireRate = activeGem.rate || 60;
        
        if (activeGem.level > 1) finalFireRate *= (1 - (activeGem.level * 0.02)); 

        // Artifact: Luna Turbo (Fire rate 1.5x during shield)
        if (engineState.isShieldActive && engineState.artifacts.some(a => a.id === 'luna_turbo')) {
            rateMod *= 1.5;
        }

        finalFireRate /= rateMod;

        let isShotgun = false;
        let spreadCount = 1;

        const finalConfig = { ...activeGem };
        finalConfig.damage *= damageMod;

        // Artifact: Luna Wing (Damage + 20% of Projectile Speed)
        if (engineState.artifacts.some(a => a.id === 'luna_wing')) {
            const speedBonus = (activeGem.speed || 5) * 0.2;
            finalConfig.damage *= (1.0 + speedBonus);
        }

        finalConfig.damage *= loadout.scale; 

        // [Patch] Apply Artifact Flags globally to all projectiles in this loadout
        finalConfig.isHoming = engineState.artifacts.some(a => a.id === 'homing_beacon');
        finalConfig.isBound = engineState.artifacts.some(a => a.id === 'bound_orb');
        finalConfig.sourceGemId = activeGem.id; // Track damage source

        // Apply Final Damage Multiplier (Keystones)
        if (engineState.stats.final_damage_mul > 0) {
            finalConfig.damage *= engineState.stats.final_damage_mul;
        }

        // Artifact: Berserker Helm (HP Loss Bonus)
        const berserkerHelm = engineState.artifacts.find(a => a.id === 'berserker_helm');
        if (berserkerHelm) {
            const maxHP = GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max;
            const currentHP = engineState.baseIntegrity;
            // 減少率 (0.0 ~ 1.0)
            const lossRatio = Math.max(0, 1.0 - (currentHP / maxHP));
            const maxBonus = berserkerHelm.config ? berserkerHelm.config.max_bonus : 0.5;
            finalConfig.damage *= (1.0 + (lossRatio * maxBonus));
        }

        // HIT/DoT 分離（System Hacker 等）
        // - rawDamageValue: DoT計算の基準（HIT減衰の影響を受けない）
        // - hitDamageMultiplier: HITのみに掛かる倍率
        const hitDamageMultiplier = 1 + (engineState.stats.hit_damage_mul_pct || 0);
        const dotPowerMultiplier = 1 + (engineState.stats.dot_power_pct || 0);
        finalConfig.rawDamageValue = finalConfig.damage * dotPowerMultiplier;
        finalConfig.hitDamageMultiplier = hitDamageMultiplier;


        supportGems.forEach(support => {
            // Apply Support Level Bonus (Nanotech Swarm)
            const lvl = (support.level || 1) + (engineState.stats.support_level_bonus || 0);
            const lvlBonus = 1 + ((lvl - 1) * 0.1 * supportPower);
            if (support.damage_mod) finalConfig.damage *= (support.damage_mod * lvlBonus);
            if (support.id === 'multishot') {
                isShotgun = true;
                // 初期弾数+1、レベルごとに+1 (Lv1=2, Lv2=3...)
                spreadCount = 1 + (support.projectiles || 1) + (lvl - 1); 
            }
            if (support.speed_mod) finalConfig.speed *= (support.speed_mod * lvlBonus);
            if (support.rate_mod) {
                // 連射速度もレベルで強化 (1.1, 1.2... で割ることで間隔を短縮)
                finalFireRate *= (support.rate_mod / lvlBonus); 
            }
            if (support.pierce_count) {
                // 初期貫通1、レベルごとに+1
                finalConfig.pierce_count = (finalConfig.pierce_count || 0) + support.pierce_count + (lvl - 1);
            }
            if (support.chain_count) {
                // 初期連鎖+2、レベルごとに+1
                finalConfig.chain_count = (finalConfig.chain_count || 0) + support.chain_count + (lvl - 1);
                finalConfig.chain_range = support.range || 200;
            }
        });

        // Artifact: Tesla Coil (Global Chain Count)
        if (engineState.stats.chain_count > 0) {
            finalConfig.chain_count = (finalConfig.chain_count || 0) + engineState.stats.chain_count;
            if (!finalConfig.chain_range) finalConfig.chain_range = 200;
        }

        let fire = false;
        if (loadout.isMain) {
            attackCooldownCounter++;
            if (attackCooldownCounter >= finalFireRate) {
                fire = true;
                attackCooldownCounter = 0;
            }
        } else {
            attackCooldownSub++;
            if (attackCooldownSub >= finalFireRate * 2) {
                fire = true;
                attackCooldownSub = 0;
            }
        }

        if (fire) {
            // Play Shoot SE
            if (loadout.isMain) audioManager.play('SHOOT');

            // Flat Self Damage
            if (engineState.stats.self_damage > 0) {
                engineState.baseIntegrity -= (engineState.stats.self_damage * (loadout.isMain ? 1.0 : 0.5));
            }
            // Percentage Self Damage (Blood Rite)
            if (engineState.stats.self_damage_pct > 0) {
                const cost = engineState.baseIntegrity * engineState.stats.self_damage_pct * (loadout.isMain ? 1.0 : 0.5);
                engineState.baseIntegrity -= cost;
            }

            const fireProjectile = (cfg, tgt, x, y) => {
                // Artifact: Phantom Barrel (Extra Shot)
                const phantomBarrel = engineState.artifacts.find(a => a.id === 'phantom_barrel');
                let shots = 1;
                if (phantomBarrel) {
                    const chance = phantomBarrel.config ? phantomBarrel.config.chance : 0.20;
                    const extra = phantomBarrel.config ? phantomBarrel.config.extra_shots : 1;
                    if (Math.random() < chance) shots += extra;
                }

                // Artifact: Chaos Dice
                if (engineState.artifacts.some(a => a.id === 'chaos_dice')) {
                    cfg.damage *= (0.5 + Math.random() * 1.5);
                }

                for(let s=0; s<shots; s++) {
                    const finalCfg = { ...cfg };

                    let aimTarget = tgt;
                    // ... (Original Aim Logic)
                    if (tgt && finalCfg.id !== 'nova') {
                        const dist = Math.hypot(tgt.positionX - x, tgt.positionY - y);
                        const timeToHit = dist / finalCfg.speed;
                        const enemySpeed = (tgt.freezeTimer > 0) ? 0 : tgt.baseSpeed;
                        const predictedY = tgt.positionY + (enemySpeed * timeToHit);
                        aimTarget = { positionX: tgt.positionX, positionY: predictedY };
                    }
                    // Scatter Phantom shots slightly
                    const originX = s===0 ? x : x + (Math.random()-0.5)*20;

                    activeProjectiles.push(new MagicProjectile(originX, y, aimTarget, finalCfg));
                }
            };

            const sourceX = RENDER_CONSTANTS.TURRET_POS_X;
            const sourceY = RENDER_CONSTANTS.TURRET_POS_Y;

            if (finalConfig.id === 'rock') {
                let baseTargetX = target ? target.positionX : (Math.random() * (GAME_SETTINGS.SCREEN_WIDTH - 100) + 50);
                let baseTargetY = target ? target.positionY : (400 + Math.random() * 200);
                const safeMargin = 40;

                for (let i = 0; i < spreadCount; i++) {
                    const scatterW = 120 + (spreadCount * 10);
                    const scatterH = 80;
                    let offsetX = (Math.random() - 0.5) * scatterW * 2;
                    let offsetY = (Math.random() - 0.5) * scatterH;
                    if (target && i === 0) { offsetX *= 0.2; offsetY *= 0.2; }
                    let tx = baseTargetX + offsetX;
                    let ty = baseTargetY + offsetY;
                    if (tx < safeMargin) tx = safeMargin + (Math.random() * 20);
                    if (tx > GAME_SETTINGS.SCREEN_WIDTH - safeMargin) tx = GAME_SETTINGS.SCREEN_WIDTH - safeMargin - (Math.random() * 20);
                    const startY = -100 - (Math.random() * 150);
                    activeProjectiles.push(new MagicProjectile(tx, startY, null, {
                        ...finalConfig,
                        velocityX: 0,
                        velocityY: finalConfig.speed * 2,
                        isFallingRock: true,
                        targetY: ty
                    }));
                }
            }
            else if (isShotgun) {
                let baseAngle = -Math.PI / 2;
                if (target) {
                    const dist = Math.hypot(target.positionX - sourceX, target.positionY - sourceY);
                    const timeToHit = dist / finalConfig.speed;
                    const enemySpeed = (target.freezeTimer > 0) ? 0 : target.baseSpeed;
                    const predictedY = target.positionY + (enemySpeed * timeToHit);
                    const deltaX = target.positionX - sourceX;
                    const deltaY = predictedY - sourceY;
                    baseAngle = Math.atan2(deltaY, deltaX);
                }
                for (let i = 0; i < spreadCount; i++) {
                    // [Fix] Smart Spread: 最初の1発は常に正面、2発目以降を左右に振り分けることで偶数時の「中央の穴」を防止
                    const angleOffset = (i === 0) ? 0 : Math.ceil(i / 2) * (i % 2 === 0 ? 1 : -1) * EFFECT_CONSTANTS.MULTISHOT_SPREAD_ANGLE;
                    const finalAngle = baseAngle + angleOffset;
                    const vx = Math.cos(finalAngle) * finalConfig.speed;
                    const vy = Math.sin(finalAngle) * finalConfig.speed;
                    activeProjectiles.push(new MagicProjectile(sourceX, sourceY, null, { ...finalConfig, velocityX: vx, velocityY: vy }));
                }
            } else {
                fireProjectile(finalConfig, target, sourceX, sourceY);
            }

            engineState.activeSupportUnits.forEach(unit => {
                if (unit.type === 'CLONE') {
                    if (isShotgun) {
                         for (let i = 0; i < spreadCount; i++) {
                            // [Fix] Smart Spread for Clone
                            const angleOffset = (i === 0) ? 0 : Math.ceil(i / 2) * (i % 2 === 0 ? 1 : -1) * EFFECT_CONSTANTS.MULTISHOT_SPREAD_ANGLE;
                            let baseAngle = -Math.PI / 2;
                            if (target) baseAngle = Math.atan2(target.positionY - unit.y, target.positionX - unit.x);
                            const finalAngle = baseAngle + angleOffset;
                            const vx = Math.cos(finalAngle) * finalConfig.speed;
                            const vy = Math.sin(finalAngle) * finalConfig.speed;
                            activeProjectiles.push(new MagicProjectile(unit.x, unit.y, null, { ...finalConfig, velocityX: vx, velocityY: vy }));
                        }
                    } else {
                        activeProjectiles.push(new MagicProjectile(unit.x, unit.y, target, finalConfig));
                    }
                }
            });
        }
    });
}

function spawnEnemy() {
    if (engineState.isBossWave) {
        if (Math.random() < 0.85) return; // Reduce noise during boss
        // Spawns minions during boss fight
        const minionTier = Math.random() < 0.3 ? ENEMY_TIERS.SWARM : ENEMY_TIERS.NORMAL;
        activeEnemies.push(new EnemyUnit(minionTier));
        return;
    }

    // [Patch] Advanced Spawn Logic
    if (Math.random() < GAME_SETTINGS.FORMATION_CHANCE) {
        const pattern = Math.random();
        if (pattern < 0.33) spawnFormation_Line();
        else if (pattern < 0.66) spawnFormation_Horde();
        else spawnFormation_Guard();
    } else {
        const rand = Math.random();
        const wave = engineState.currentWaveNumber;
        let tier = ENEMY_TIERS.NORMAL;

        // Dynamic Probability based on ENEMY_TIERS.chance and Wave
        // Higher wave = higher chance for advanced types
        // Base chances: TANK(0.15), ROGUE(0.30), SWARM(0.45), MAGIC(0.60), RARE(0.70)

        const difficultyMod = Math.min(0.25, (wave - 1) * 0.02); // Increases 2% per wave, cap at 25%

        // Check from rarest to common
        if (rand > (1.0 - (0.05 + difficultyMod))) tier = ENEMY_TIERS.RARE;
        else if (rand > (1.0 - (0.15 + difficultyMod))) tier = ENEMY_TIERS.MAGIC;
        else if (rand > 0.75) tier = ENEMY_TIERS.TANK;  // 25% chance
        else if (rand > 0.55) tier = ENEMY_TIERS.ROGUE; // 20% chance
        else if (rand > 0.35) tier = ENEMY_TIERS.SWARM; // 20% chance
        // else NORMAL (35% chance)

        activeEnemies.push(new EnemyUnit(tier));
    }
}

function spawnFormation_Line() {
    const count = 3 + Math.floor(Math.random() * 2); 
    const spacing = 60;
    const startX = Math.random() * (GAME_SETTINGS.SCREEN_WIDTH - (count * spacing));
    for(let i=0; i<count; i++) activeEnemies.push(new EnemyUnit(ENEMY_TIERS.NORMAL, startX + i*spacing, -50));
    activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, 100, "⚠ LINE FORMATION", "#e74c3c", 16));
}
function spawnFormation_Horde() {
    const count = 5 + Math.floor(Math.random() * 3);
    const centerX = Math.random() * (GAME_SETTINGS.SCREEN_WIDTH - 100) + 50;
    for(let i=0; i<count; i++) {
        const offsetX = (Math.random() - 0.5) * 80;
        const offsetY = (Math.random() - 0.5) * 80 - 50;
        activeEnemies.push(new EnemyUnit(ENEMY_TIERS.NORMAL, centerX + offsetX, offsetY));
    }
    activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, 100, "⚠ HORDE INCOMING", "#e74c3c", 16));
}
function spawnFormation_Guard() {
    const centerX = Math.random() * (GAME_SETTINGS.SCREEN_WIDTH - 100) + 50;
    const leaderTier = Math.random() < 0.2 ? ENEMY_TIERS.RARE : ENEMY_TIERS.MAGIC;
    activeEnemies.push(new EnemyUnit(leaderTier, centerX, -50));
    activeEnemies.push(new EnemyUnit(ENEMY_TIERS.NORMAL, centerX - 40, -30));
    activeEnemies.push(new EnemyUnit(ENEMY_TIERS.NORMAL, centerX + 40, -30));
    activeEnemies.push(new EnemyUnit(ENEMY_TIERS.NORMAL, centerX - 40, -70));
    activeEnemies.push(new EnemyUnit(ENEMY_TIERS.NORMAL, centerX + 40, -70));
    activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, 100, "⚠ ELITE GUARD", "#f1c40f", 16));
}

function mainLoop() {
    if (engineState.isGameOver) {
        // If clear screen is shown, we stop updating but keep rendering is handled by UI overlay
        // If not clear (died), show Game Over
        if (engineState.baseIntegrity <= 0) {
            displayGameOver();
        } else {
             // Game Clear State: Keep rendering background but stop logic?
             // Or just let it run in background? Let's render scene for cool effect.
             renderScene();
        }
        return;
    }

    // ヒットストップ処理: 残りフレームがある場合は描画だけ行い、ロジック更新を飛ばす
    if (engineState.hitStopFrames > 0) {
        engineState.hitStopFrames--;
        renderScene();
        requestAnimationFrame(mainLoop);
        return;
    }

    if (!engineState.isPaused) {
        // [Patch] Variable Time Step Logic
        engineState.accumulator += engineState.timeScale;
        // Cap accumulator to prevent spiral of death
        if (engineState.accumulator > 5.0) engineState.accumulator = 5.0;

        while (engineState.accumulator >= 1.0) {
            engineState.accumulator -= 1.0;

            // --- Core Update Logic ---
            if (engineState.timeStopTimer > 0) {
                engineState.timeStopTimer--;
                if (engineState.timeStopTimer <= 0) {
                    activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2, "RESUME", "#fff", 30));
                }
            }

            // Spawn Logic (Paused during Time Stop)
            if (engineState.timeStopTimer <= 0) {
                enemySpawnCounter++;
                const rate = Math.max(GAME_SETTINGS.SPAWN_RATE_MIN, GAME_SETTINGS.SPAWN_RATE_BASE - (engineState.currentWaveNumber * 2));
                if (enemySpawnCounter > rate) {
                    spawnEnemy();
                    enemySpawnCounter = 0;
                }
            }

            handleAutoAttack();
            engineState.updateEnergy();
            engineState.updateCrewAbilities(); // Crew CD tick
            engineState.activeSupportUnits.forEach(unit => unit.update());
            engineState.activeSupportUnits = engineState.activeSupportUnits.filter(u => u.life > 0);
            activeZoneEffects.forEach(zone => zone.update());
            activeZoneEffects = activeZoneEffects.filter(z => z.life > 0);

            activeProjectiles.forEach(projectile => projectile.update());
            activeEnemyProjectiles.forEach(ep => ep.update());
            activeEnemyProjectiles = activeEnemyProjectiles.filter(ep => ep.isAlive);
            engineState.activeDrops.forEach(drop => drop.update());

            activeEnemies.forEach(enemy => {
                enemy.update();

                // 死亡演出中の敵には当たり判定を発生させない
                if (enemy.isDying) return;

                activeProjectiles.forEach(projectile => {
                    if (!projectile.isAlive) return;
                    if (projectile.hitTargetIds.has(enemy.id)) return;
                    if (enemy.confusionTimer > 0) return;

                    const hitDist = (enemy.size / 2) + RENDER_CONSTANTS.PROJECTILE_SIZE;
                    const collisionDistance = Math.hypot(enemy.positionX - projectile.currentX, enemy.positionY - projectile.currentY);

                    if (collisionDistance < hitDist) {
                        projectile.hitTargetIds.add(enemy.id);

                        if (engineState.stats.life_on_hit > 0) {
                            const maxHP = GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max;
                            if (engineState.baseIntegrity < maxHP) {
                                engineState.baseIntegrity = Math.min(engineState.baseIntegrity + engineState.stats.life_on_hit, maxHP);
                            }
                        }

                        let critChance = EFFECT_CONSTANTS.BASE_CRIT_CHANCE + engineState.stats.crit_chance;
                        const amulet = engineState.equippedArtifacts.AMULET;
                        if (amulet && amulet.stats && amulet.stats.crit_chance) critChance += amulet.stats.crit_chance;
                        const isCrit = Math.random() < critChance;
                        const finalDamage = isCrit ? projectile.damageValue * EFFECT_CONSTANTS.BASE_CRIT_MULTIPLIER : projectile.damageValue;

                        enemy.takeDamage(finalDamage, isCrit, projectile.effectType);
                        engineState.recordDamage(projectile.sourceGemId, finalDamage);

                        const statusPower = (projectile.rawDamageValue !== undefined) ? projectile.rawDamageValue : projectile.damageValue;

                        if (projectile.effectType === 'fireball') enemy.applyStatus('BURN', statusPower);
                        else if (projectile.effectType === 'nova') applyAreaDamage(enemy.positionX, enemy.positionY, EFFECT_CONSTANTS.NOVA_RADIUS, finalDamage * 0.5, 'nova');
                        else if (projectile.effectType === 'poison') {
                            activeZoneEffects.push(new ZoneEffect(enemy.positionX, enemy.positionY, 'POISON_CLOUD', { damage: statusPower }));
                            projectile.isAlive = false; 
                        }
                        else if (projectile.effectType === 'psychic') enemy.applyStatus('CONFUSION', 0, engineState.currentLevel);
                        else if (projectile.effectType === 'water') enemy.applyStatus('SOAKED', 0);
                        else if (projectile.effectType === 'electric') enemy.applyStatus('SHOCK', finalDamage);
                        else if (projectile.effectType === 'plant') {
                            const ratio = GAME_SETTINGS.LEECH_RATIO || 0.02;
                            const healPerTick = finalDamage * ratio; 
                            enemy.applyStatus('LEECH', healPerTick);
                            activeParticles.push(new ParticleEffect(enemy.positionX, enemy.positionY, "#2ecc71", 3));
                        }

                        if (projectile.pierceCount > 0) {
                            projectile.pierceCount--;
                        } else {
                            projectile.isAlive = false;
                            if (projectile.chainCount > 0) {
                                let nearest = null;
                                let minD = Infinity;
                                const effectiveRange = (projectile.chainRange || 200) * (1.0 + (engineState.stats.chain_range_pct || 0));
                                for (const other of activeEnemies) {
                                    if (other.id !== enemy.id && other.isActive && !projectile.hitTargetIds.has(other.id)) {
                                         const d = Math.hypot(other.positionX - enemy.positionX, other.positionY - enemy.positionY);
                                        if (d < effectiveRange && d < minD) {
                                            minD = d;
                                            nearest = other;
                                        }
                                    }
                                }

                                if (nearest) {
                                    const chainConfig = {
                                        id: projectile.effectType, 
                                        damage: projectile.damageValue * 0.8, 
                                        speed: projectile.moveSpeed,       
                                        color: EFFECT_CONSTANTS.COLOR_CHAIN,
                                        level: 1,                          
                                        chain_count: projectile.chainCount - 1,
                                        chain_range: projectile.chainRange,
                                        pierce_count: 0,
                                        ignoreIds: projectile.hitTargetIds,
                                        sourceGemId: projectile.sourceGemId
                                    };
                                    const chainProj = new MagicProjectile(enemy.positionX, enemy.positionY, nearest, chainConfig);
                                    activeProjectiles.push(chainProj);
                                    activeFloatingTexts.push(new FloatingText(enemy.positionX, enemy.positionY - 40, "CHAIN!", EFFECT_CONSTANTS.COLOR_CHAIN, 14));
                                } else if (projectile.effectType === 'fireball') {
                                    applyAreaDamage(enemy.positionX, enemy.positionY, EFFECT_CONSTANTS.FIREBALL_RADIUS, finalDamage * 0.5, 'fireball');
                                }
                            } else {
                                if (projectile.effectType === 'fireball') {
                                    applyAreaDamage(enemy.positionX, enemy.positionY, EFFECT_CONSTANTS.FIREBALL_RADIUS, finalDamage * 0.5, 'fireball');
                                }
                            }
                        }

                        if (enemy.health <= 0 && enemy.isActive) {
                            handleEnemyDeath(enemy, isCrit, projectile.damageValue);
                        }
                    }
                });
            });
            activeParticles.forEach(particleInstance => particleInstance.update());
            activeShockwaves.forEach(shockwaveInstance => shockwaveInstance.update());
            activeFloatingTexts.forEach(textInstance => textInstance.update());

            activeEnemies = activeEnemies.filter(enemy => enemy.isActive);
            activeProjectiles = activeProjectiles.filter(projectile => projectile.isAlive);
            activeParticles = activeParticles.filter(particleInstance => particleInstance.life > 0);
            activeShockwaves = activeShockwaves.filter(shockwaveInstance => shockwaveInstance.currentLife > 0);
            activeFloatingTexts = activeFloatingTexts.filter(textInstance => textInstance.life > 0);
            if (engineState.baseIntegrity <= 0) {
                // Artifact: Phoenix Core (One-time revive)
                const phoenixIdx = engineState.artifacts.findIndex(a => a.id === 'phoenix_core');
                if (phoenixIdx !== -1) {
                    engineState.artifacts.splice(phoenixIdx, 1); // 消費
                    const maxHP = GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max;
                    engineState.baseIntegrity = maxHP * 0.3;
                    triggerScreenShake(30, 15);
                    activeFloatingTexts.push(new FloatingText(RENDER_CONSTANTS.TURRET_POS_X, GAME_SETTINGS.CASTLE_Y - 100, "PHOENIX REBIRTH!", "#fab1a0", 40));
                    audioManager.play('LEVELUP');
                } else {
                    engineState.isGameOver = true;
                }
            }
        }
    }

    // Background Update
    if (starField) starField.update(engineState.currentWaveNumber);

    renderScene();

    if (engineState.inventoryDirty) {
        refreshInventoryInterface();
        engineState.inventoryDirty = false;
    }

    if (shakeTime > 0) {
        shakeTime--;
        shakeIntensity *= 0.9;
    }
    requestAnimationFrame(mainLoop);
}

function renderScene() {
    gameContext.save();
    gameContext.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
    if (shakeTime > 0) {
        const dx = (Math.random() - 0.5) * shakeIntensity;
        const dy = (Math.random() - 0.5) * shakeIntensity;
        gameContext.translate(dx, dy);
    }

    // Draw Dynamic Starfield Background
    if (starField) {
        starField.draw(gameContext, engineState.currentWaveNumber);
    } else {
        gameContext.fillStyle = "#1e272e";
        gameContext.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
    }

    // Draw Ground (Castle Area)
    gameContext.fillStyle = "#2c3e50";
    gameContext.fillRect(0, GAME_SETTINGS.CASTLE_Y, gameCanvas.width, gameCanvas.height - GAME_SETTINGS.CASTLE_Y);

    // --- Enhanced Shield Rendering (Arc Dome) ---
    if (engineState.isShieldActive || engineState.shieldImpactTimer > 0) {
        gameContext.save();
        const isJust = engineState.shieldTimer < 20;
        const isImpact = engineState.shieldImpactTimer > 0;

        if (isImpact) engineState.shieldImpactTimer--;

        // シールドの設定
        const centerX = RENDER_CONSTANTS.TURRET_POS_X;
        const centerY = GAME_SETTINGS.CASTLE_Y;
        const radiusX = gameCanvas.width / 1.5; // 横幅広めになだらかに
        const radiusY = 70; // 砲台の先端より少し高い位置
        const baseColor = isImpact ? "#ffffff" : (isJust ? "#66fcf1" : "#45a29e");
        const glowColor = isImpact ? "#ffffff" : "#66fcf1";

        // パスの作成（ドーム型）
        gameContext.beginPath();
        gameContext.ellipse(centerX, centerY, radiusX, radiusY, 0, Math.PI, 2 * Math.PI);

        // 1. 内部グラデーション（放射状）
        const grad = gameContext.createRadialGradient(
            centerX, centerY, radiusY * 0.2,
            centerX, centerY, radiusY
        );
        const alphaMain = isImpact ? 0.6 : 0.25;
        const alphaCore = isImpact ? 0.3 : 0.05;

        grad.addColorStop(0, `rgba(102, 252, 241, ${alphaCore})`);
        grad.addColorStop(0.7, `rgba(102, 252, 241, ${alphaMain})`);
        grad.addColorStop(1, `rgba(102, 252, 241, 0.7)`); // 縁付近を濃く

        gameContext.fillStyle = grad;
        gameContext.fill();

        // 2. 発光する縁（アウトライン）
        gameContext.shadowBlur = isImpact ? 40 : (isJust ? 25 : 15);
        gameContext.shadowColor = glowColor;
        gameContext.strokeStyle = baseColor;
        gameContext.lineWidth = isImpact ? 6 : (isJust ? 4 : 2);
        gameContext.stroke();

        // 3. ヘックスグリッド模様（Tech感）
        if (!isImpact) {
            gameContext.save();
            gameContext.clip(); // ドーム内に限定

            gameContext.strokeStyle = "rgba(102, 252, 241, 0.15)";
            gameContext.lineWidth = 1;
            gameContext.shadowBlur = 0;

            // 簡易的なハニカム風ライン描画
            const hexSize = 40;
            gameContext.beginPath();
            // 斜め線のみでグリッド感を出す
            for (let x = -gameCanvas.width; x < gameCanvas.width * 2; x += hexSize) {
                gameContext.moveTo(x, centerY);
                gameContext.lineTo(x + radiusY, centerY - radiusY * 1.5);
                gameContext.moveTo(x, centerY);
                gameContext.lineTo(x - radiusY, centerY - radiusY * 1.5);
            }
            gameContext.stroke();
            gameContext.restore();
        }

        gameContext.restore();
    }

    const equippedActive = engineState.equippedGems[0];
    const turretColor = equippedActive ? equippedActive.color : "#95a5a6";
    const tx = RENDER_CONSTANTS.TURRET_POS_X;
    const ty = RENDER_CONSTANTS.TURRET_POS_Y;

    // --- Enhanced Turret Drawing (Image Support) ---
    gameContext.save();
    gameContext.translate(tx, ty);

    // 1. Turret Base (Fixed)
    if (GAME_ASSETS.BASE) {
        // 画像がある場合 (少し大きめに描画)
        const baseSize = 80; 
        gameContext.drawImage(GAME_ASSETS.BASE, -baseSize/2, -baseSize/2, baseSize, baseSize);
    } else {
        // Fallback: Canvas Drawing
        gameContext.beginPath();
        gameContext.arc(0, 10, 25, Math.PI, 0); 
        gameContext.fillStyle = "#2c3e50";
        gameContext.fill();
        gameContext.strokeStyle = "#555";
        gameContext.lineWidth = 2;
        gameContext.stroke();
    }

    // 2. Rotating Barrel
    let angle = -Math.PI / 2; 
    // Simple target tracking for visuals
    const aimingTarget = getTarget(); 
    if (aimingTarget) {
        angle = Math.atan2(aimingTarget.positionY - ty, aimingTarget.positionX - tx);
    } else if (engineState.manualTargetId) {
        const mTarget = activeEnemies.find(e => e.id === engineState.manualTargetId);
        if (mTarget) angle = Math.atan2(mTarget.positionY - ty, mTarget.positionX - tx);
    } else {
        // Idle animation (breath)
        angle = -Math.PI / 2 + Math.sin(Date.now() / 1000) * 0.1;
    }

    // Apply Rotation
    gameContext.rotate(angle);
    // 画像素材が「上向き(270度)」であると仮定し、Canvasの「右向き(0度)」に合わせるため+90度回転補正
    gameContext.rotate(Math.PI / 2);

    // Recoil Animation (Y軸方向に後退)
    const recoil = (attackCooldownCounter < 4) ? (4 - attackCooldownCounter) * 2 : 0;

    // Select Barrel Image
    let barrelImg = null;
    if (equippedActive) {
        switch (equippedActive.id) {
            case 'fireball': barrelImg = GAME_ASSETS.BARREL_FIREBALL; break;
            case 'nova':     barrelImg = GAME_ASSETS.BARREL_NOVA; break;
            case 'arrow':    barrelImg = GAME_ASSETS.BARREL_ARROW; break;
            case 'poison':   barrelImg = GAME_ASSETS.BARREL_POISON; break;
            case 'rock':     barrelImg = GAME_ASSETS.BARREL_ROCK; break;
            case 'psychic':  barrelImg = GAME_ASSETS.BARREL_PSYCHIC; break;
            case 'water':    barrelImg = GAME_ASSETS.BARREL_WATER; break;
            case 'electric': barrelImg = GAME_ASSETS.BARREL_ELECTRIC; break;
            case 'plant':    barrelImg = GAME_ASSETS.BARREL_PLANT; break;
            default:         barrelImg = GAME_ASSETS.BARREL_FIREBALL; break; 
        }
    }

    if (barrelImg) {
        const bSize = 64;
        // Recoil logic: 画像描画位置をずらす (回転しているのでY軸が砲身の後ろ方向)
        gameContext.drawImage(barrelImg, -bSize/2, -bSize/2 + recoil, bSize, bSize);
    } else {
        // Fallback: Canvas Drawing
        // 回転補正を戻す
        gameContext.rotate(-Math.PI / 2);

        // Barrel Body
        gameContext.fillStyle = "#34495e";
        gameContext.fillRect(0, -10, 45 - recoil, 20); 

        // Colored Stripe
        gameContext.fillStyle = turretColor;
        gameContext.shadowColor = turretColor;
        gameContext.shadowBlur = 10;
        gameContext.fillRect(10, -6, 25 - recoil, 12);
        gameContext.shadowBlur = 0;

        // Muzzle
        gameContext.fillStyle = "#7f8c8d";
        gameContext.fillRect(40 - recoil, -12, 8, 24);

        // Core Light
        gameContext.beginPath();
        gameContext.arc(0, 0, 6, 0, Math.PI * 2);
        gameContext.fillStyle = turretColor;
        gameContext.shadowColor = turretColor;
        gameContext.shadowBlur = 15;
        gameContext.fill();
        gameContext.shadowBlur = 0;
    }

    gameContext.restore();

    engineState.activeDrops.forEach(drop => drop.draw(gameContext));
    activeZoneEffects.forEach(zone => zone.draw(gameContext));
    engineState.activeSupportUnits.forEach(unit => unit.draw(gameContext));
    activeEnemies.forEach(enemy => enemy.draw(gameContext));
    activeProjectiles.forEach(projectile => projectile.draw(gameContext));
    activeEnemyProjectiles.forEach(enemyProjectileInstance => enemyProjectileInstance.draw(gameContext));
    activeParticles.forEach(particleInstance => particleInstance.draw(gameContext));
    activeShockwaves.forEach(shockwaveInstance => shockwaveInstance.draw(gameContext));
    activeFloatingTexts.forEach(textInstance => textInstance.draw(gameContext));
    
    gameContext.restore();
    updateHudDisplay();
}

function displayGameOver() {
    audioManager.stopBgm();
    gameContext.save();
    gameContext.fillStyle = "rgba(0,0,0,0.85)";
    gameContext.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
    gameContext.fillStyle = "#e74c3c";
    gameContext.font = "bold 40px 'Hiragino Kaku Gothic Pro', sans-serif";
    gameContext.textAlign = "center";
    gameContext.fillText("通信途絶 (ゲームオーバー)", gameCanvas.width / 2, gameCanvas.height / 2);
    gameContext.font = "20px sans-serif";
    gameContext.fillStyle = "#fff";
    gameContext.fillText("[R]キー でリトライ", gameCanvas.width / 2, gameCanvas.height / 2 + 50);
    gameContext.restore();
}

function addExperience(value) {
    engineState.experiencePoints += value;
    if (engineState.experiencePoints >= engineState.calculateNextLevelXp()) {
        engineState.experiencePoints = 0;
        engineState.currentLevel++;
        engineState.skillPoints++; 

        audioManager.play('LEVELUP');

        // [Patch] Trigger New Upgrade UI
        activeFloatingTexts.push(new FloatingText(GAME_SETTINGS.SCREEN_WIDTH/2, GAME_SETTINGS.SCREEN_HEIGHT/2 - 100, `レベルアップ！`, "#f1c40f", 30));
        triggerScreenShake(10, 5);

        // Open Modal after a short delay
        setTimeout(() => {
            if (window.showLevelUpOptions) window.showLevelUpOptions();
        }, 600);
    }
}

/**
 * 敵撃破時のアイテム/ゴールドドロップ生成
 * @param {number} positionX - 生成X座標
 * @param {number} positionY - 生成Y座標
 */
function generateDrop(positionX, positionY) {
    // 1. ゴールドドロップ判定
    if (Math.random() < (GAME_SETTINGS.GOLD_DROP_CHANCE || 0.4)) {
        engineState.activeDrops.push(new DropItem(positionX, positionY, MISC_ITEMS.GOLD));
        return;
    }

    // 2. アイテムドロッププールの構築
    const itemPool = [];
    const allTemplates = [...Object.values(GEMS), ...Object.values(ARTIFACTS)];

    // 現在の装備状況を確認
    const currentEquippedItems = [...engineState.equippedGems, ...engineState.altGems].filter(itemInstance => itemInstance !== null);
    const equippedActiveGems = currentEquippedItems.filter(itemInstance => itemInstance.type === GEM_TYPES.ACTIVE);
    const equippedItemIds = currentEquippedItems.map(itemInstance => itemInstance.id);

    // アクティブGEMが2つ以上装備されているか（ビルドの方向性が決まっているか）
    const isBuildEstablished = equippedActiveGems.length >= 2;

    allTemplates.forEach(template => {
        // 全アイテムをプールに入れる。
        // サポートGEMは種類が少ないため、ベースの重みを増やす(1->3)
        const baseWeight = (template.type === GEM_TYPES.SUPPORT) ? 3 : 1;
        for (let count = 0; count < baseWeight; count++) {
            itemPool.push(template);
        }

        // 装備中のアイテム（Active/Support問わず）の重みを大幅に増やす
        // ビルド確定（Active2種以上）ならさらに強力なボーナス
        if (equippedItemIds.includes(template.id)) {
            const weightBonus = isBuildEstablished ? 15 : 8; 
            for (let count = 0; count < weightBonus; count++) {
                itemPool.push(template);
            }
        }
    });

    const selectedTemplate = itemPool[Math.floor(Math.random() * itemPool.length)];

    // 3. ドロップレベルの決定
    let dropLevel = 1;
    const currentWave = engineState.currentWaveNumber;
    const levelRoll = Math.random();

    const chanceLevel3 = Math.min(0.20, Math.max(0, (currentWave - 10) * 0.02));
    const chanceLevel2 = Math.min(0.40, Math.max(0, (currentWave - 3) * 0.03));

    if (levelRoll < chanceLevel3) {
        dropLevel = 3;
    } else if (levelRoll < (chanceLevel3 + chanceLevel2)) {
        dropLevel = 2;
    }

    const finalItemTemplate = { ...selectedTemplate, forcedLevel: dropLevel };
    engineState.activeDrops.push(new DropItem(positionX, positionY, finalItemTemplate));
}

window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyQ') engineState.swapLoadout(); 
    if (e.code === 'Space') engineState.togglePause();
    if (e.code === 'KeyR' && engineState.isGameOver) {
        location.reload();
    }
});

// --- Game Flow Control ---
window.isGameRunning = false;

window.startGame = function() {
    // Show Crew Selection first
    if (window.showCrewSelection) {
        window.showCrewSelection(async (selectedCrewIds, startGem) => {
            // Loading Indication
            if (window.showToast) window.showToast("SYSTEM BOOT...", "#66fcf1");

            // Load Assets Wait
            await Promise.all([
                loadGameAssets(),
                audioManager.load()
            ]);

            const title = document.getElementById('title-screen');
            if (title) title.classList.add('hidden');

            // Reset and Start
            engineState.reset();

            // Apply Selection
            engineState.selectedCrew = selectedCrewIds;
            engineState.recalcStats();
            engineState.addItemToInventory(startGem);
            engineState.equipItem(engineState.inventory[0].uuid, 0);

            // Start BGM
            audioManager.playBgm('BGM_EARLY');

            activeEnemies = [];
            activeProjectiles = [];
            activeEnemyProjectiles = [];
            activeParticles = [];
            activeFloatingTexts = [];
            // Reset Background
            starField = new StarField(GAME_SETTINGS.SCREEN_WIDTH, GAME_SETTINGS.SCREEN_HEIGHT);

            refreshInventoryInterface();
            if(window.updateArtifactHud) window.updateArtifactHud();
            if(window.updateCrewHud) window.updateCrewHud();

            if (!window.isGameRunning) {
                window.isGameRunning = true;
                mainLoop();
            }
        });
    } else {
        console.error("UI Module not loaded.");
    }
};

/**
 * デバッグ用：最強状態で最終WAVEから開始
 */
window.debugStartGame = function() {
    if (window.showCrewSelection) {
        window.showCrewSelection(async (selectedCrewIds, startGem) => {
            if (window.showToast) window.showToast("DEBUG MODE ACTIVATED", "#e74c3c");
            await Promise.all([loadGameAssets(), audioManager.load()]);

            const title = document.getElementById('title-screen');
            if (title) title.classList.add('hidden');

            engineState.reset();
            engineState.selectedCrew = selectedCrewIds;

            // --- デバッグ用チートステータス ---
            engineState.currentLevel = 50;
            engineState.skillPoints = 100;
            engineState.currentWaveNumber = 10; // 最終WAVE
            engineState.gold = 99999;
            engineState.bonusStats.damage_pct = 10.0; // 攻撃力 +1000%
            engineState.bonusStats.rate_pct = 5.0;   // 攻撃速度 +500%
            engineState.bonusStats.hp_max = 5000;    // HP超強化
            engineState.baseIntegrity = 5000 + GAME_SETTINGS.BASE_MAX_HP;

            engineState.recalcStats();
            engineState.addItemToInventory(startGem, 5); // 最初からLv.5
            engineState.equipItem(engineState.inventory[0].uuid, 0);

            // BGM再生
            audioManager.playBgm('BGM_LATE');

            activeEnemies = [];
            activeProjectiles = [];
            activeEnemyProjectiles = [];
            activeParticles = [];
            activeFloatingTexts = [];
            starField = new StarField(GAME_SETTINGS.SCREEN_WIDTH, GAME_SETTINGS.SCREEN_HEIGHT);

            refreshInventoryInterface();
            if(window.updateArtifactHud) window.updateArtifactHud();
            if(window.updateCrewHud) window.updateCrewHud();

            if (!window.isGameRunning) {
                window.isGameRunning = true;
                mainLoop();
            }
        });
    }
};
▲▲▲ FILE END: game.js ▲▲▲

▼▼▼ FILE START: index.html ▼▼▼
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Project OVERLORD: Vertical Ops</title>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
    <style>
        /* --- Quick Buy Buttons --- */
        .quick-buy-container {
            position: absolute;
            /* top: 75% から bottom基準に変更し、画面サイズが変わってもHUDの上に配置されるように修正 */
            bottom: 160px;
            display: flex;
            flex-direction: row;
            gap: 8px;
            z-index: 100; /* 最前面に確実に表示 */
            pointer-events: none;
        }
        /* 砲台を中心に左右に振り分け（中央寄せ配置に修正） */
        #quick-buy-left { 
            right: 50%; 
            margin-right: 35px; /* 砲台の直下に収まるよう間隔を縮小 */
        } 
        #quick-buy-right { 
            left: 50%; 
            margin-left: 35px; /* 砲台の直下に収まるよう間隔を縮小 */
        }

        /* タッチターゲットを最小44px以上に確保（iOS/Android推奨） */
        .quick-btn, .hud-btn, .side-hud-btn, .inv-item, .gem-slot {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .quick-btn {
            width: 36px; height: 36px; /* クルーアイコンと被らないようサイズを縮小 */
            background: rgba(11, 12, 16, 0.85);
            border: 1px solid var(--accent-cyan);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            transition: 0.2s;
            box-shadow: 0 0 8px rgba(102, 252, 241, 0.2);
            position: relative;
        }
        .quick-btn:active { transform: scale(0.9); }
        .quick-btn.disabled {
            filter: grayscale(1) opacity(0.4);
            border-color: #555;
            cursor: not-allowed;
        }
        .quick-btn .icon { font-size: 18px; } /* アイコンサイズも調整 */

        :root {
            --bg-color: #0b0c10;
            --panel-bg: #1f2833;
            --accent-cyan: #66fcf1;
            --accent-gold: #f1c40f;
            --accent-red: #e74c3c;
            --text-main: #c5c6c7;
            --slot-border: #45a29e;
        }

        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%;
            background: #000; color: var(--text-main); 
            font-family: 'Hiragino Kaku Gothic Pro', 'Meiryo', sans-serif; 
            overflow: hidden; user-select: none;
            display: flex; justify-content: center; align-items: center;
        }

        #device-frame {
            position: relative;
            /* アスペクト比を維持 (600:900 = 2:3) */
            aspect-ratio: 2 / 3;
            /* 画面内に収まるように自動調整 */
            width: auto; height: auto;
            max-width: 100%; max-height: 100dvh;

            background: radial-gradient(circle at 50% 80%, #2c3e50 0%, #000000 100%);
            border: 2px solid #333;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            overflow: hidden;
            display: flex; flex-direction: column;
        }

        #game-canvas { 
            width: 100%; height: 100%; 
            flex-grow: 1; display: block; 
            object-fit: contain;
            /* キャンバス上でのスクロールやズームを禁止 */
            touch-action: none;
        }

        /* --- Mobile Optimization --- */
        @media (max-width: 600px) {
            #device-frame {
                border: none;
                box-shadow: none;
                max-height: 100%;
                /* アスペクト比固定を解除し、画面全体を使用するよう変更 */
                aspect-ratio: unset;
                width: 100%;
                height: 100%;
                border-radius: 0;
            }
            body {
                background: #0b0c10;
            }
            /* モバイルでのボタン位置微調整：砲台の下、HUDの上に配置 */
            .quick-buy-container {
                bottom: 135px;
            }
        }

        /* --- PoE Style HUD (Bottom Panel) --- */
        #bottom-hud {
            position: absolute; bottom: 0; left: 0; width: 100%; 
            /* 高さ調整: 140px -> 120px */
            height: calc(120px + env(safe-area-inset-bottom));
            /* グラデーションを調整して上部の抜けを良くする */
            background: linear-gradient(to top, #0b0c10 60%, transparent 100%);
            display: flex; justify-content: space-between; align-items: flex-end;
            padding-bottom: calc(10px + env(safe-area-inset-bottom)); 
            z-index: 50;
            pointer-events: none;
            box-sizing: border-box;
        }

        /* Vertical Meters (HP / Energy) - Mobile Optimized */
        .orb-container {
            width: 40px; height: 110px; /* 少し短縮: 120px -> 110px */
            position: relative;
            margin: 0 8px 0 8px; /* マージン微調整 */
            pointer-events: auto;
            border-radius: 20px;
            background: #111;
            border: 2px solid #555;
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
            overflow: hidden;
            display: flex; flex-direction: column; justify-content: flex-end;
        }
        .orb-fill {
            width: 100%; 
            /* height controlled by JS */
            transition: height 0.2s;
        }
        .orb-fill.hp {
            background: linear-gradient(to top, #c0392b, #ff6b6b);
            box-shadow: 0 0 10px #c0392b;
        }
        .orb-fill.energy {
            background: linear-gradient(to top, #2980b9, #74b9ff);
            box-shadow: 0 0 10px #2980b9;
        }
        .orb-text {
            position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
            font-size: 22px; line-height: 1; z-index: 10;
            filter: drop-shadow(0 0 2px #000);
            pointer-events: none;
        }
        .orb-label {
            position: absolute; bottom: 8px; width: 100%; text-align: center;
            font-size: 10px; font-weight: bold; color: #fff; 
            text-shadow: 0 0 4px #000; z-index: 10; font-family: monospace;
            pointer-events: none;
        }

        /* Center Panel (Controls & Stats) */
        .center-panel {
            flex-grow: 1; height: 100px;
            display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
            pointer-events: auto;
            margin-bottom: 5px;
        }

        .stats-row {
            display: flex; gap: 15px; margin-bottom: 5px;
            font-size: 12px; font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }
        .stat-item { color: #fff; display: flex; align-items: center; gap: 4px; }
        .stat-gold { color: #f1c40f; }
        .stat-sp { color: #00d2d3; }

        .xp-bar-container {
            width: 90%; height: 6px; background: #333;
            border: 1px solid #555; border-radius: 3px;
            margin-bottom: 8px; overflow: hidden;
        }
        .xp-bar-fill {
            height: 100%; background: #f1c40f; width: 0%; transition: width 0.3s;
        }

        .control-buttons {
            display: flex; gap: 10px;
        }
        .hud-btn {
            width: 40px; height: 40px; /* コンパクト化: 45px -> 40px */
            background: #1f2833; border: 2px solid #45a29e;
            border-radius: 8px; color: #66fcf1;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; font-size: 16px; transition: 0.1s;
        }
        .hud-btn:active { transform: scale(0.95); }
        .hud-btn span { font-size: 8px; margin-top: 2px; }
        .hud-btn.active { background: #66fcf1; color: #000; }

        /* Wave Info (Top Center - Minimal) */
        #top-info {
            position: absolute; top: 10px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
        }
        .wave-badge {
            display: inline-block; background: rgba(0,0,0,0.6); 
            border: 1px solid #f1c40f; color: #f1c40f;
            padding: 5px 15px; border-radius: 15px;
            font-weight: bold; font-size: 14px;
        }
        .wave-progress {
            width: 200px; height: 4px; background: rgba(255,255,255,0.2);
            margin: 5px auto; border-radius: 2px; overflow: hidden;
        }
        .wave-progress-fill {
            height: 100%; background: #f1c40f; width: 0%;
        }

        /* --- Modals & Overlays --- */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 15, 20, 0.95); 
            z-index: 6000; /* Higher than title screen (5000) */
            display: flex; flex-direction: column;
            transition: opacity 0.2s; opacity: 1; pointer-events: auto;
        }
        .modal-overlay.hidden { opacity: 0; pointer-events: none; }

        .modal-header {
            /* モバイルのノッチ対策: 上部にセーフエリア分のパディングを追加 */
            padding: calc(15px + env(safe-area-inset-top)) 15px 15px 15px;
            border-bottom: 2px solid #45a29e;
            display: flex; justify-content: space-between; align-items: center;
            background: #0b0c10;
        }
        .modal-title { font-size: 18px; font-weight: bold; color: #66fcf1; }
        .close-btn { background: none; border: none; color: #e74c3c; font-size: 28px; cursor: pointer; }

        .modal-content { flex-grow: 1; padding: 10px; overflow-y: auto; }

        /* Upgrade Selection (Vampire Survivors Style) */
        #upgrade-selection-modal {
            background: rgba(0, 0, 0, 0.85);
            align-items: center; justify-content: center;
        }
        .upgrade-container {
            display: flex; flex-direction: column; gap: 15px; width: 90%; max-width: 400px;
        }
        .upgrade-card {
            background: linear-gradient(135deg, #2c3e50, #1a1a2e);
            border: 2px solid #bdc3c7; border-radius: 8px;
            padding: 15px; color: #fff; cursor: pointer;
            display: flex; align-items: center; gap: 15px;
            transition: transform 0.2s;
            position: relative; overflow: hidden;
        }
        .upgrade-card:hover { transform: scale(1.03); border-color: #f1c40f; background: linear-gradient(135deg, #34495e, #2c3e50); }
        .upgrade-card.rare { border-color: #f1c40f; }
        .upgrade-icon { font-size: 32px; width: 50px; text-align: center; }
        .upgrade-info { flex: 1; }
        .upgrade-name { font-weight: bold; font-size: 16px; color: #f1c40f; margin-bottom: 4px; }
        .upgrade-desc { font-size: 12px; color: #ccc; line-height: 1.3; }
        .upgrade-btn {
            margin-top: 10px; padding: 10px; background: #333; border: 1px solid #777; 
            color: #fff; cursor: pointer; border-radius: 4px; text-align: center;
        }

        /* Skill Tree Container (Zoomable) */
        #skill-tree-viewport {
            width: 100%; height: 100%; overflow: hidden; position: relative;
            background: radial-gradient(circle, #222 0%, #000 100%);
            touch-action: none; /* Prevent browser default zoom */
        }
        #skill-tree-content {
            transform-origin: 0 0;
            position: absolute;
        }

        /* Skill Tree Nodes Styling */
        .tree-node {
            position: absolute;
            width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            background: #222; border: 2px solid #555; border-radius: 50%;
            cursor: pointer; z-index: 2;
            transition: all 0.2s ease;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .tree-node:hover { transform: translate(-50%, -50%) scale(1.2); border-color: #fff; z-index: 10; }
        .tree-node.allocated { background: #f1c40f; border-color: #fff; box-shadow: 0 0 15px #f1c40f; }

        .node-start { width: 60px; height: 60px; border-color: #00d2d3; background: #1a1a2e; box-shadow: 0 0 20px #00d2d3; }

        .node-keystone { 
            width: 70px; height: 70px; 
            border-radius: 8px; border-width: 3px; border-color: #e74c3c; 
            transform: translate(-50%, -50%) rotate(45deg); 
        }
        .node-keystone.allocated { background: #c0392b; border-color: #ff7675; box-shadow: 0 0 25px #e74c3c; }
        .node-keystone:hover { transform: translate(-50%, -50%) rotate(45deg) scale(1.1); }
        /* Fix text rotation inside keystone */
        .node-keystone > div { transform: rotate(-45deg); } 

        .node-medium { width: 50px; height: 50px; border-color: #a29bfe; border-width: 2px; }
        .node-medium.allocated { background: #6c5ce7; }

        .node-label {
            position: absolute;
            top: 105%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #fff;
            text-shadow: 0 0 4px #000;
            white-space: nowrap;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 4px;
            z-index: 20;
        }

        /* --- Specific Modal Styles --- */
        /* Equipment & Inventory UI */
        .loadout-row { display: flex; gap: 5px; margin-bottom: 5px; align-items: center; }
        .loadout-label { width: 40px; font-size: 10px; color: #aaa; text-align: right; margin-right: 5px; }
        .gem-slot {
            flex: 1; height: 50px; background: rgba(0,0,0,0.5); border: 1px solid #555;
            display: flex; align-items: center; justify-content: center;
            border-radius: 4px; font-size: 10px; color: #666; position: relative;
        }
        .acc-row { display: flex; justify-content: center; gap: 20px; margin: 15px 0; border-top: 1px solid #333; border-bottom: 1px solid #333; padding: 10px 0; }
        .acc-slot { width: 80px; height: 80px; }

        .inv-section-header { font-size: 12px; color: #f1c40f; margin-top: 10px; border-bottom: 1px solid #444; padding-bottom: 2px; }
        #inventory-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-top: 5px; } /* Mobile friendly: 4 cols */

        .inv-item {
            aspect-ratio: 1; border: 1px solid #444; border-radius: 4px; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            font-size: 10px; background: rgba(255,255,255,0.05); position: relative;
            cursor: pointer; overflow: hidden;
        }
        .inv-name { font-size: 9px; text-align: center; line-height: 1.1; margin-top: 2px; width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Tap Selection Highlight */
        .selected-item { border-color: #f1c40f !important; box-shadow: 0 0 10px #f1c40f; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        /* Side Action Buttons (Pause, Swap) */
        .side-hud-btn {
            position: absolute; width: 44px; height: 44px;
            background: rgba(0,0,0,0.6); border: 2px solid #fff; color: #fff;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 20px; cursor: pointer; z-index: 90; transition: 0.1s;
            pointer-events: auto;
        }
        .side-hud-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.2); }

        /* Action Menu for Touch */
        #action-menu {
            position: absolute; background: #222; border: 1px solid #66fcf1;
            padding: 5px; border-radius: 4px; z-index: 7000;
            display: flex; flex-direction: column; gap: 5px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .action-btn {
            background: #333; color: #fff; border: none; padding: 8px 12px;
            font-size: 12px; cursor: pointer; text-align: left;
        }
        .action-btn:hover { background: #444; }
        .action-btn.danger { color: #e74c3c; }
        .inv-item { 
            aspect-ratio: 1; border: 1px solid #444; border-radius: 4px; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            font-size: 10px; background: rgba(255,255,255,0.05);
        }

        /* Shop Grid */
        #shop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }

        /* Title Screen */
        #title-screen {
            background: radial-gradient(circle at 50% 30%, #1f2833 0%, #0b0c10 80%);
            z-index: 5000; /* High priority, but below modals */
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .title-logo {
            color: #66fcf1; font-size: 40px; text-shadow: 0 0 20px #45a29e;
            margin-bottom: 10px; font-weight: bold; text-align: center; line-height: 1.1;
        }
        .title-sub {
            color: #c5c6c7; font-size: 16px; letter-spacing: 4px; 
            margin-bottom: 60px; text-transform: uppercase;
        }
        .title-btn {
            width: 220px; margin: 10px auto; padding: 15px;
            background: transparent; border: 2px solid #66fcf1;
            color: #66fcf1; font-family: monospace; font-size: 16px; font-weight: bold;
            cursor: pointer; transition: 0.2s; position: relative; overflow: hidden;
            text-align: center; text-decoration: none; display: block;
        }
        .title-btn:hover {
            background: rgba(102, 252, 241, 0.1);
            box-shadow: 0 0 15px rgba(102, 252, 241, 0.5);
            letter-spacing: 2px;
            color: #fff; border-color: #fff;
        }

        /* Guide Colors */
        .slot-active-bg { background: rgba(231, 76, 60, 0.1); border-color: #c0392b !important; }
        .slot-support-bg { background: rgba(46, 204, 113, 0.1); border-color: #27ae60 !important; }

        /* Help Modal Text */
        .help-section { margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .help-title { color: #f1c40f; font-weight: bold; margin-bottom: 5px; }
        .help-desc { font-size: 12px; color: #ccc; line-height: 1.4; }

        /* --- Arcade Style Cut-in Effect --- */
        #cutin-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 8000; overflow: hidden; display: none;
        }
        .cutin-banner {
            position: absolute; top: 42%; left: -110%; width: 120%; height: 60px; /* 高さ半分 */
            background: linear-gradient(90deg, transparent, rgba(0,210,211,0.6) 15%, rgba(0,210,211,0.6) 85%, transparent); /* 透過度アップ */
            transform: skewX(-20deg);
            display: flex; align-items: center;
            box-shadow: 0 0 20px rgba(0,210,211,0.3);
            border-top: 1px solid rgba(255,255,255,0.5); border-bottom: 1px solid rgba(255,255,255,0.5);
        }
        .cutin-image {
            height: 140%; margin-left: 15%; margin-top: -10px; /* サイズ調整 */
            filter: drop-shadow(0 0 8px #000);
            image-rendering: pixelated;
            transform: skewX(20deg);
            opacity: 0.8;
        }
        .cutin-text-group {
            margin-left: 15px; transform: skewX(20deg); color: #fff;
            text-shadow: 0 0 8px #000;
        }
        .cutin-ability-name {
            font-size: 20px; font-weight: 900; font-style: italic; /* コンパクトに */
            letter-spacing: 1px; text-transform: uppercase;
        }
        .cutin-crew-name { font-size: 10px; opacity: 0.8; font-weight: bold; }

        /* Animations */
        @keyframes cutin-sequence {
            0% { left: -110%; opacity: 0; }
            15% { left: -10%; opacity: 1; }
            85% { left: 0%; opacity: 1; }
            100% { left: 110%; opacity: 0; }
        }
        .animate-cutin { animation: cutin-sequence 1.2s cubic-bezier(0.16, 1, 0.3, 1) forwards; }

        /* Fuse Notification Banner */
        #fuse-overlay {
            position: absolute; top: 180px; left: 0; width: 100%;
            pointer-events: none; z-index: 7000; display: none;
        }
        .fuse-banner {
            background: linear-gradient(90deg, transparent, rgba(102, 252, 241, 0.2) 20%, rgba(102, 252, 241, 0.2) 80%, transparent);
            border-top: 1px solid rgba(102, 252, 241, 0.5);
            border-bottom: 1px solid rgba(102, 252, 241, 0.5);
            height: 40px; display: flex; align-items: center; justify-content: center;
            overflow: hidden; box-shadow: 0 0 20px rgba(102, 252, 241, 0.1);
        }
        .fuse-content { color: var(--accent-cyan); font-weight: bold; font-family: monospace; letter-spacing: 2px; font-size: 14px; text-shadow: 0 0 8px var(--accent-cyan); }
        .fuse-level { color: var(--accent-gold); margin-left: 10px; font-size: 18px; }

        @keyframes fuse-in {
            0% { transform: scaleY(0); opacity: 0; }
            10% { transform: scaleY(1); opacity: 1; }
            90% { transform: scaleY(1); opacity: 1; }
            100% { transform: scaleY(0); opacity: 0; }
        }
        .animate-fuse { animation: fuse-in 1.8s cubic-bezier(0.19, 1, 0.22, 1) forwards; }

    </style>
</head>
<body>
    <div id="device-frame">
        <!-- Title Screen -->
        <div id="title-screen" class="modal-overlay">
            <div>
                <div class="title-logo">PROJECT<br>OVERLORD</div>
                <div class="title-sub">Vertical Ops</div>

                <div class="title-btn" onclick="startGame()">MISSION START</div>
                <div class="title-btn" onclick="toggleMenu('synergy-modal')" style="border-color:#f1c40f; color:#f1c40f;">SYNERGY ARCHIVE</div>
                <div class="title-btn" onclick="toggleMenu('help-modal')">TUTORIAL / HELP</div>
                <!-- <div class="title-btn" onclick="configManager.togglePanel()">SYSTEM CONFIG</div> -->
            </div>
            <div style="position:absolute; bottom:20px; width:100%; text-align:center; color:#555; font-size:10px;">
                V3.0.0 - SYSTEM READY
            </div>
        </div>

        <canvas id="game-canvas" width="600" height="900"></canvas>

        <!-- Quick Buy Buttons (Left) -->
        <div id="quick-buy-left" class="quick-buy-container">
            <div class="quick-btn" id="qbtn-repair" onclick="engineState.buyShopItem('repair')">
                <span class="icon">🔧</span>
            </div>
            <div class="quick-btn" id="qbtn-drone_col" onclick="engineState.buyShopItem('drone_col')">
                <span class="icon">🧹</span>
            </div>
        </div>

        <!-- Quick Buy Buttons (Right) -->
        <div id="quick-buy-right" class="quick-buy-container">
            <div class="quick-btn" id="qbtn-drone_atk" onclick="engineState.buyShopItem('drone_atk')">
                <span class="icon">🛸</span>
            </div>
            <div class="quick-btn" id="qbtn-clone" onclick="engineState.buyShopItem('clone')">
                <span class="icon">👥</span>
            </div>
        </div>

        <!-- Artifacts HUD (Left Side) -->
        <div id="artifact-hud" style="position:absolute; top:80px; left:10px; width:40px; display:flex; flex-direction:column; gap:5px; pointer-events:auto; z-index:40;">
            <!-- Generated by JS -->
        </div>

        <!-- Speed Control Button (Top Right) -->
        <div id="speed-btn" 
             style="position:absolute; top:15px; right:15px; background:rgba(0,0,0,0.6); border:1px solid #7f8c8d; color:#fff; padding:5px 10px; border-radius:15px; font-size:12px; cursor:pointer; pointer-events:auto; z-index:100; user-select:none;"
             onclick="window.engineState && window.engineState.toggleGameSpeed()">
            ▶️ x1.0
        </div>

        <!-- BGM Toggle Button (Below Speed Button) -->
        <div id="bgm-btn" 
             style="position:absolute; top:50px; right:15px; background:rgba(0,0,0,0.6); border:1px solid #7f8c8d; color:#66fcf1; padding:5px 10px; border-radius:15px; font-size:12px; cursor:pointer; pointer-events:auto; z-index:100; user-select:none;"
             onclick="window.toggleBgmState()">
            ♫ ON
        </div>

        <div id="top-info">
            <div class="wave-badge" id="wave-info">WAVE 1</div>
            <div class="wave-progress">
                <div id="wave-bar-fill" class="wave-progress-fill"></div>
            </div>
            <div id="game-stats" style="font-size: 10px; color: #aaa; margin-top: 4px;">初期化中...</div>
        </div>

        <div id="bottom-hud">
            <div class="orb-container left">
                <div id="hp-orb-fill" class="orb-fill hp" style="height: 100%;"></div>
                <div class="orb-text">❤️</div>
                <div class="orb-label" id="hp-text">500</div>
            </div>

            <div class="center-panel">
                <div class="stats-row">
                    <div class="stat-item stat-gold">💰 <span id="gold-display">0</span></div>
                    <div class="stat-item stat-sp">✨ SP: <span id="sp-display">0</span></div>
                </div>
                
                <div class="xp-bar-container">
                    <div id="xp-bar-fill" class="xp-bar-fill"></div>
                </div>
                <div style="font-size: 8px; color:#aaa; margin-bottom: 5px;">けいけんち</div>

                <div class="control-buttons">
                    <div class="hud-btn" onclick="toggleMenu('dock-modal')">
                        🎒<span>そうび</span>
                    </div>
                    <div class="hud-btn" onclick="toggleMenu('skill-tree-modal')">
                        🌲<span>ツリー</span>
                    </div>
                    <div class="hud-btn" onclick="toggleMenu('shop-modal')">
                        🛒<span>店</span>
                    </div>
                    <div class="hud-btn" onclick="toggleMenu('help-modal')" style="border-color:#f1c40f; color:#f1c40f;">
                        ?<span>ヘルプ</span>
                    </div>
                </div>
            </div>

            <div class="orb-container right" id="btn-shield-orb"
                 style="cursor:pointer; transition:0.1s;"
                 onmousedown="engineState.setShieldState(true)" 
                 onmouseup="engineState.setShieldState(false)"
                 ontouchstart="engineState.setShieldState(true); event.preventDefault();" 
                 ontouchend="engineState.setShieldState(false); event.preventDefault();">
                <div id="energy-orb-fill" class="orb-fill energy" style="height: 100%;"></div>
                <div class="orb-text">🛡️</div>
                <div class="orb-label" id="energy-text">100</div>
            </div>
        </div>

        <!-- Side HUD Buttons: Swap (Left) and Pause (Right) -->
        <div class="side-hud-btn" style="bottom:calc(135px + env(safe-area-inset-bottom)); left:10px; border-color:#00d2d3; color:#00d2d3;"
             onclick="engineState.swapLoadout()">♻️</div>

        <div class="side-hud-btn" style="bottom:calc(135px + env(safe-area-inset-bottom)); right:10px;"
             onclick="engineState.togglePause()">⏸</div>

        <div id="upgrade-selection-modal" class="modal-overlay hidden">
            <h2 style="color:#f1c40f; text-shadow:0 0 10px orange; margin-bottom:20px;">レベルアップ！</h2>
            <div class="upgrade-container" id="upgrade-options-container">
                </div>
            <div id="btn-upgrade-close" class="upgrade-btn" onclick="closeUpgradeModal()">あとで決める（SPを保持）</div>
        </div>

        <div id="dock-modal" class="modal-overlay hidden">
            <div class="modal-header">
                <div class="modal-title">装備 & インベントリ</div>
                <button class="close-btn" onclick="toggleMenu('dock-modal')">×</button>
            </div>
            <div class="modal-content" id="dock-content">
                <!-- Generated by JS -->
            </div>
        </div>

        <div id="skill-tree-modal" class="modal-overlay hidden">
            <div class="modal-header">
                <div class="modal-title">スキルツリー</div>
                <div id="tree-sp-info" style="color: #00d2d3; font-weight: bold; font-size: 14px; margin-left: auto; margin-right: 15px;">SP: 0</div>
                <button class="close-btn" onclick="toggleMenu('skill-tree-modal')">×</button>
            </div>
            <div id="skill-tree-viewport">
                <div id="skill-tree-content" style="width: 2000px; height: 1500px;"></div>
            </div>
            <div style="position:absolute; bottom:20px; left:20px; pointer-events:none; color:#aaa; font-size:12px; background:rgba(0,0,0,0.5); padding:5px;">
                ピンチで拡大縮小 / ドラッグで移動
            </div>
        </div>

        <div id="logic-modal" class="modal-overlay hidden">
            <div class="modal-header">
                <div class="modal-title">AI 作成</div>
                <button class="upgrade-btn" style="background:#00d2d3; color:#000; margin-right:10px;" onclick="applyAiLogic()">決定</button>
                <button class="close-btn" onclick="toggleMenu('logic-modal')">×</button>
            </div>
            <div class="modal-content" style="padding:0;">
                <div id="blockly-div" style="width:100%; height:100%;"></div>
            </div>
        </div>

        <div id="fuse-overlay">
            <div class="fuse-banner" id="fuse-banner">
                <div class="fuse-content">
                    <span id="fuse-item-name">FIREBALL</span>
                    <span class="fuse-text">UPGRADED</span>
                    <span class="fuse-level" id="fuse-item-lv">Lv.2</span>
                </div>
            </div>
        </div>

        <div id="shop-modal" class="modal-overlay hidden">
            <div class="modal-header">
                <div class="modal-title" style="color:#f1c40f;">お店</div>
                <div id="shop-gold-info" style="color: #f1c40f; font-weight: bold; font-size: 14px; margin-left: auto; margin-right: 15px;">💰 0</div>
                <button class="close-btn" onclick="toggleMenu('shop-modal')">×</button>
            </div>
            <div class="modal-content">
                <div id="shop-message" style="background:#222; padding:10px; border-radius:4px; font-size:12px; margin-bottom:10px;">いらっしゃいませ...</div>
                <div id="shop-grid"></div>
            </div>
        </div>

        <!-- Special Move Cut-in Overlay -->
        <div id="cutin-overlay">
            <div class="cutin-banner" id="cutin-banner">
                <img src="" class="cutin-image" id="cutin-img">
                <div class="cutin-text-group">
                    <div class="cutin-crew-name" id="cutin-crew-name">COMMANDER</div>
                    <div class="cutin-ability-name" id="cutin-ability">ULTIMATE SKILL</div>
                </div>
            </div>
        </div>

        <div id="synergy-modal" class="modal-overlay hidden">
            <div class="modal-header">
                <div class="modal-title" style="color:#f1c40f;">シナジー図鑑</div>
                <button class="close-btn" onclick="toggleMenu('synergy-modal')">×</button>
            </div>
            <div class="modal-content">
                <div style="font-size:12px; color:#aaa; margin-bottom:15px; border-left:3px solid #f1c40f; padding-left:10px;">
                    属性を組み合わせて発見した特殊反応の記録です。<br>
                    実戦で一度でも発動させると詳細がアンロックされます。
                </div>
                <div id="synergy-list" style="display:flex; flex-direction:column; gap:10px;">
                    <!-- JS generated items -->
                </div>
            </div>
        </div>

        <div id="help-modal" class="modal-overlay hidden">
            <div class="modal-header">
                <div class="modal-title">マニュアル</div>
                <button class="close-btn" onclick="toggleMenu('help-modal')">×</button>
            </div>
            <div class="modal-content">
                <div class="help-section">
                    <div class="help-title">🎮 基本操作</div>
                    <div class="help-desc">
                        ・<strong>攻撃</strong>: 自動射撃（カーソル/タップで優先ターゲット指定可）<br>
                        ・<strong>アイテム回収</strong>: ドロップ品をクリック/タップ<br>
                        ・<strong>シールド</strong>: 右クリック / Space / 右下ボタン長押し<br>
                        ・<strong>装備切替</strong>: Qキー / SWAPボタン
                    </div>
                </div>
                <div class="help-section">
                    <div class="help-title">🛡️ ジャストガード (重要)</div>
                    <div class="help-desc">
                        シールド展開の<strong>「直後」</strong>に敵弾を受けると、<br>
                        弾を反射し <span style="color:#66fcf1">MPが回復</span> します。<br>
                        MPが尽きるとシールドが割れるため、タイミングよく防ぐのが生存のカギです。
                    </div>
                </div>
                <div class="help-section">
                    <div class="help-title">⚔️ 装備と合成</div>
                    <div class="help-desc">
                        ・<strong>メイン(左端)</strong>: 武器GEM（赤枠）を装備<br>
                        ・<strong>サポート(右2枠)</strong>: 強化GEM（緑枠）を装備<br>
                        ・<strong>自動合成</strong>: 同じアイテムを3つ集めると上位Lvに進化<br>
                        ・<strong>サブセット</strong>: 裏装備も 50% の性能で自動援護します。
                    </div>
                </div>
                <div class="help-section">
                    <div class="help-title">🔥 属性シナジー</div>
                    <div class="help-desc">
                        異なる状態異常を組み合わせると強力な効果が発生します。<br>
                        例: <span style="color:#e74c3c">炎上</span> + <span style="color:#3498db">水浸</span> = <strong>蒸発 (大ダメージ)</strong><br>
                        例: <span style="color:#f1c40f">感電</span> + <span style="color:#3498db">水浸</span> = <strong>伝播 (広範囲感電)</strong>
                    </div>
                </div>
                <div class="help-section">
                    <div class="help-title">👥 クルーシステム</div>
                    <div class="help-desc">
                        右下のキャラクターアイコンをクリックすると、強力な<br>
                        <strong>ユニークスキル</strong>を発動できます（クールダウンあり）。
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module" src="config-manager.js"></script>
    <script type="module" src="audio-manager.js"></script>
    <script type="module" src="game.js"></script>
    <script src="blocks.js"></script>
    <script>
        // Simple pinch/drag handler for skill tree will be implemented in ui.js
        // Placeholder for close function
        function closeUpgradeModal() {
            document.getElementById('upgrade-selection-modal').classList.add('hidden');
            if(window.engineState) window.engineState.isPaused = false;
        }
    </script>
</body>
</html>
▲▲▲ FILE END: index.html ▲▲▲

▼▼▼ FILE START: ui.js ▼▼▼
/**
 * @fileoverview UIコンポーネント、DOM操作、描画ロジック
 * 憲法準拠: 1文字変数禁止、型ヒント必須。
 * 更新: スマートレベルアップ提案、スキルツリーラベル対応、Export修正、アーティファクト対応
 */
import { GAME_SETTINGS, SKILL_TREE_NODES, GEM_TYPES, SHOP_ITEMS, GEMS, ARTIFACT_TYPES, BOSS_ARTIFACTS, CREW_DATA, EFFECT_CONSTANTS, ENEMY_TIERS, SYNERGY_METADATA } from './constants.js';
import { audioManager } from './audio-manager.js';

// --- UI Queue System (Conflict Resolver) ---
const uiQueue = [];

function isModalOpen() {
    const modal = document.getElementById('upgrade-selection-modal');
    return modal && !modal.classList.contains('hidden');
}

function processNextUiTask() {
    if (uiQueue.length > 0) {
        // 次のタスクを取り出して実行 (fromQueueフラグを立てる)
        const nextTask = uiQueue.shift();
        setTimeout(() => nextTask(true), 10); 
        return true; 
    }
    return false; 
}

// --- Tooltip System ---
const tooltipContainer = document.getElementById('ui-tooltip') || document.createElement('div');
if (!tooltipContainer.id) {
    tooltipContainer.id = 'ui-tooltip';
    Object.assign(tooltipContainer.style, {
        position: 'fixed', display: 'none', pointerEvents: 'none', zIndex: '9999', // Increased z-index
        backgroundColor: 'rgba(20, 20, 30, 0.95)', border: '1px solid #7f8c8d',
        padding: '8px 12px', borderRadius: '4px', color: '#ecf0f1',
        fontFamily: "'Hiragino Kaku Gothic Pro', sans-serif", fontSize: '12px', lineHeight: '1.4',
        boxShadow: '0 4px 6px rgba(0,0,0,0.3)', whiteSpace: 'pre-wrap'
    });
    document.body.appendChild(tooltipContainer);
}

/**
 * ツールチップの内容を生成 (日本語化)
 * サポートGEMの場合はレベルに応じた具体的な数値を算出する
 */
export function getTooltipContent(item) {
    if (!item) return '';
    let html = `<div style="font-weight:bold; color:${item.color || '#fff'}">${item.name}</div>`;
    if (item.level) html += `<div style="font-size:10px; color:#aaa">Lv.${item.level}</div>`;

    // アイコンの表示
    let displayIcon = item.icon;
    if (!displayIcon && (item.type === GEM_TYPES.ACTIVE || item.type === GEM_TYPES.SUPPORT)) {
        displayIcon = (item.type === GEM_TYPES.ACTIVE) ? '⚔️' : '💠';
    }

    if (displayIcon) html += `<div style="font-size:24px; text-align:center; margin:4px 0;">${displayIcon}</div>`;

    // サポートGEM用の動的説明生成
    if (item.type === GEM_TYPES.SUPPORT) {
        // game.jsのロジックに基づき、Lv1以降、1レベルごとに10%のボーナスを加算
        const levelBonusMultiplier = 1 + (item.level - 1) * 0.1;
        let dynamicDescription = "";

        if (item.id === 'multishot') {
            const totalProjectiles = 1 + (item.projectiles || 1) + (item.level - 1);
            const damagePenalty = (item.damage_mod * levelBonusMultiplier).toFixed(2);
            dynamicDescription = `拡散射撃: 弾数 ${totalProjectiles}<br>1発あたりの威力 x${damagePenalty}`;
        } else if (item.id === 'power') {
            const damageBoost = (item.damage_mod * levelBonusMultiplier).toFixed(2);
            dynamicDescription = `威力強化: 全ダメージ x${damageBoost}`;
        } else if (item.id === 'speed') {
            const speedBoost = (item.speed_mod * levelBonusMultiplier).toFixed(2);
            const rateMod = (item.rate_mod / levelBonusMultiplier).toFixed(2);
            dynamicDescription = `高速化: 弾速 x${speedBoost}<br>連射間隔 x${rateMod}`;
        } else if (item.id === 'pierce') {
            const pierceCount = item.pierce_count + (item.level - 1);
            const damagePenalty = (item.damage_mod * levelBonusMultiplier).toFixed(2);
            dynamicDescription = `貫通: 最大 ${pierceCount}体貫通<br>ダメージ倍率 x${damagePenalty}`;
        } else if (item.id === 'chain') {
            const chainCount = item.chain_count + (item.level - 1);
            const damagePenalty = (item.damage_mod * levelBonusMultiplier).toFixed(2);
            dynamicDescription = `連鎖: 最大 ${chainCount}回連鎖<br>ダメージ倍率 x${damagePenalty}`;
        } else if (item.id === 'omega_prism') {
            const allBoost = (item.damage_mod * levelBonusMultiplier).toFixed(2);
            dynamicDescription = `全性能強化: 全てのステータス x${allBoost}`;
        }

        html += `<div style="margin-top:4px; color:#66fcf1; font-size:11px; line-height:1.2;">${dynamicDescription}</div>`;
    } else {
        html += `<div style="margin-top:4px;">${item.description || item.desc || ''}</div>`;
    }

    // Stats (Active Gems等)
    if (item.damage) html += `<div>攻撃力: ${item.damage}</div>`;
    if (item.speed) html += `<div>弾速: ${item.speed}</div>`;
    if (item.rate) html += `<div>連射: ${item.rate}F</div>`;

    if (item.stats) {
        Object.entries(item.stats).forEach(([k, v]) => {
            html += `<div style="font-size:10px; color:#bdc3c7">${k}: ${v}</div>`;
        });
    }
    return html;
}

export function showTooltip(ev, item) {
    if (!item) return;
    if (window.tooltipHideTimer) {
        clearTimeout(window.tooltipHideTimer);
        window.tooltipHideTimer = null;
    }
    tooltipContainer.innerHTML = getTooltipContent(item);
    tooltipContainer.style.display = 'block';
    moveTooltip(ev);
}
window.showTooltip = showTooltip;

export function moveTooltip(ev) {
    const offset = 20;
    // タッチイベントとマウスイベントの両方の座標に対応
    const clientX = (ev.touches && ev.touches[0]) ? ev.touches[0].clientX : ev.clientX;
    const clientY = (ev.touches && ev.touches[0]) ? ev.touches[0].clientY : ev.clientY;

    if (clientX === undefined || clientY === undefined) return;

    let left = clientX + offset;
    let top = clientY + offset;
    
    // 画面端の調整
    if (left + 200 > window.innerWidth) left = clientX - 210;
    if (top + 100 > window.innerHeight) top = clientY - 110;

    tooltipContainer.style.left = `${left}px`;
    tooltipContainer.style.top = `${top}px`;
}
window.moveTooltip = moveTooltip;

export function hideTooltip() {
    // 既にタイマーが動いている場合は重ねない
    if (window.tooltipHideTimer) clearTimeout(window.tooltipHideTimer);

    // 0.5秒後に非表示にする
    window.tooltipHideTimer = setTimeout(() => {
        tooltipContainer.style.display = 'none';
        window.tooltipHideTimer = null;
    }, 500);
}
window.hideTooltip = hideTooltip;

/**
 * 簡易トースト通知を表示 (UI最前面)
 */
export function showToast(message, color = "#fff") {
    const toast = document.createElement('div');
    toast.innerText = message;
    Object.assign(toast.style, {
        position: 'fixed', top: '80px', left: '50%', transform: 'translateX(-50%)',
        background: 'rgba(0,0,0,0.9)', color: color, padding: '8px 16px',
        borderRadius: '20px', border: `1px solid ${color}`, zIndex: '10000',
        fontSize: '14px', fontWeight: 'bold', pointerEvents: 'none',
        boxShadow: '0 4px 15px rgba(0,0,0,0.5)', transition: 'all 0.3s ease-out',
        opacity: '0', marginTop: '10px'
    });
    document.body.appendChild(toast);
    
    // Animation frame
    requestAnimationFrame(() => {
        toast.style.opacity = '1';
        toast.style.marginTop = '0px';
    });

    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.marginTop = '-10px';
        setTimeout(() => toast.remove(), 300);
    }, 1500);
}
window.showToast = showToast;

// --- HUD & Interfaces ---

export function updateHudDisplay() {
    const engineState = window.engineState;
    if (!engineState) return;

    // HP Bar
    const maxHp = GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max;
    const hpPct = Math.max(0, (engineState.baseIntegrity / maxHp) * 100);
    const hpBar = document.getElementById('hp-orb-fill'); 
    const hpText = document.getElementById('hp-text');    
    if (hpBar) hpBar.style.height = `${hpPct}%`;          
    if (hpText) hpText.innerText = `${Math.floor(engineState.baseIntegrity)}`;

    // XP Bar
    const nextXp = engineState.calculateNextLevelXp();
    const xpPct = Math.max(0, (engineState.experiencePoints / nextXp) * 100);
    const xpBar = document.getElementById('xp-bar-fill');
    if (xpBar) xpBar.style.width = `${xpPct}%`;

    // Resources
    const goldEl = document.getElementById('gold-display');
    if (goldEl) goldEl.innerText = `${engineState.gold}`;
    
    const spEl = document.getElementById('sp-display');
    if (spEl) spEl.innerText = `${engineState.skillPoints}`;

    // モーダルヘッダー内の情報（SP/Gold）を同期
    const treeSpInfo = document.getElementById('tree-sp-info');
    if (treeSpInfo) treeSpInfo.innerText = `SP: ${engineState.skillPoints}`;

    const shopGoldInfo = document.getElementById('shop-gold-info');
    if (shopGoldInfo) shopGoldInfo.innerText = `💰 ${engineState.gold}`;

    const statsText = document.getElementById('game-stats');
    if (statsText) statsText.innerText = `LV: ${engineState.currentLevel}`;
    
    const waveEl = document.getElementById('wave-info');
    const waveBar = document.getElementById('wave-bar-fill');
    if (waveEl && waveBar) {
        if (engineState.isBossWave) {
             waveBar.style.width = "100%";
             waveBar.style.backgroundColor = "#e74c3c";
             waveEl.innerText = "⚠ BOSS";
             waveEl.style.color = "#e74c3c";
             waveEl.style.borderColor = "#e74c3c";
        } else {
             const wavePct = Math.min(100, (engineState.waveProgress / engineState.waveQuota) * 100);
             waveBar.style.width = `${wavePct}%`;
             waveBar.style.backgroundColor = "#f1c40f";
             waveEl.innerText = `WAVE ${engineState.currentWaveNumber}`;
             waveEl.style.color = "#f1c40f";
             waveEl.style.borderColor = "#f1c40f";
        }
    }
    
    // Energy Orb
    const enFill = document.getElementById('energy-orb-fill');
    const enText = document.getElementById('energy-text');
    if (enFill) {
        const enPct = (engineState.energy / engineState.maxEnergy) * 100;
        enFill.style.height = `${enPct}%`;
        enText.innerText = `${Math.floor(engineState.energy)}`;
    }

    // Quick Buy Buttons State Update
    const quickItems = [
        { id: 'qbtn-repair', cost: SHOP_ITEMS.REPAIR.cost },
        { id: 'qbtn-drone_col', cost: SHOP_ITEMS.DRONE_COL.cost },
        { id: 'qbtn-drone_atk', cost: SHOP_ITEMS.DRONE_ATK.cost },
        { id: 'qbtn-clone', cost: SHOP_ITEMS.CLONE.cost }
    ];
    quickItems.forEach(q => {
        const btn = document.getElementById(q.id);
        if (btn) {
            if (engineState.gold < q.cost) btn.classList.add('disabled');
            else btn.classList.remove('disabled');
        }
    });

    updateCrewHud();
}
window.updateHudDisplay = updateHudDisplay;

export function updateMainScreenLoadout() {
    // Placeholder required by game.js imports
}
window.updateMainScreenLoadout = updateMainScreenLoadout;

export function updateArtifactHud() {
    const container = document.getElementById('artifact-hud');
    if (!container) return;

    // 状態が変わっていない場合は再構築しない (イベントリスナー維持のため)
    const artifactCount = window.engineState.artifacts.length;
    if (container.dataset.lastCount === artifactCount.toString()) return;
    container.dataset.lastCount = artifactCount.toString();

    container.innerHTML = '';

    window.engineState.artifacts.forEach(art => {
        const icon = document.createElement('div');
        icon.innerHTML = `<div style="pointer-events:none;">${art.icon}</div>`;
        icon.style.cssText = `width:40px; height:40px; background:rgba(0,0,0,0.6); border:1px solid ${art.color}; border-radius:4px; text-align:center; line-height:38px; font-size:22px; cursor:help; display:flex; align-items:center; justify-content:center; touch-action:none; pointer-events:auto;`;

        const showInfo = (e) => {
            e.stopPropagation(); // ゲーム画面へのイベント伝播を阻止
            // タッチイベントの場合は座標を取り出す
            const ptr = (e.touches && e.touches[0]) ? e.touches[0] : e;
            window.showTooltip(ptr, art);
        };

        // PC hover
        icon.onmouseenter = showInfo;
        icon.onmousemove = (e) => { e.stopPropagation(); window.moveTooltip(e); };
        icon.onmouseleave = window.hideTooltip;

        // Mobile / Click
        // タッチ開始時に確実に表示し、伝播を止める
        icon.ontouchstart = (e) => {
            if (e.cancelable) e.preventDefault();
            showInfo(e);
        };
        // クリックでも表示（マウス操作や一部タッチ環境用）
        icon.onclick = (e) => {
            showInfo(e);
        };

        container.appendChild(icon);
    });
}
window.updateArtifactHud = updateArtifactHud;

export function updateCrewHud() {
    const engineState = window.engineState;
    if (!engineState || !engineState.selectedCrew || engineState.selectedCrew.length === 0) return;

    let container = document.getElementById('crew-hud');
    if (!container) {
        container = document.createElement('div');
        container.id = 'crew-hud';
        // [Patch] Position optimized using calc/env to stack neatly above the pause button
        container.style.cssText = "position:absolute; bottom:calc(185px + env(safe-area-inset-bottom)); right:10px; display:flex; flex-direction:column; gap:10px; z-index:45;";
        document.getElementById('device-frame').appendChild(container);
    }

    // [Patch] Differential Update Strategy (DOMの全削除再生成を廃止)
    // 既存の要素を取得し、パラメータのみを更新することでイベントリスナーの外れやレイアウト計算負荷を防ぐ

    engineState.selectedCrew.forEach(crewId => {
        const crew = CREW_DATA[crewId];
        if (!crew) return;

        // ユニークIDでラッパー要素を取得
        let wrapper = document.getElementById(`crew-icon-${crewId}`);

        // --- 初回生成 ---
        if (!wrapper) {
            wrapper = document.createElement('div');
            wrapper.id = `crew-icon-${crewId}`;
            wrapper.style.cssText = `
                width: 48px; height: 48px; background: #000; 
                border: 2px solid #444; border-radius: 4px; 
                overflow: hidden; position: relative;
                transition: border-color 0.2s, box-shadow 0.2s;
                cursor: pointer; pointer-events: auto; touch-action: manipulation;
            `;

            // Activate Event
            wrapper.onpointerdown = (e) => {
                e.preventDefault(); e.stopPropagation();
                // 状態はengineStateから直接判定
                const cd = window.engineState.crewCooldowns[crewId] || 0;
                if (cd <= 0) window.engineState.activateCrewAbility(crewId);
                else window.showToast("リチャージ中...", "#7f8c8d");
            };

            // Image
            const img = document.createElement('img');
            img.className = 'crew-face-img';
            img.style.cssText = "width:100%; height:100%; image-rendering:pixelated; pointer-events:none; display:block;";
            wrapper.appendChild(img);

            // CD Overlay (Mask)
            const cdOverlay = document.createElement('div');
            cdOverlay.className = 'crew-cd-overlay';
            cdOverlay.style.cssText = "position:absolute; bottom:0; left:0; width:100%; height:0%; background:rgba(0,0,0,0.7); pointer-events:none; transition:height 0.1s linear;";
            wrapper.appendChild(cdOverlay);

            // Timer Text
            const timer = document.createElement('div');
            timer.className = 'crew-cd-timer';
            timer.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#fff; font-size:14px; font-weight:bold; text-shadow:0 0 2px #000; display:none;";
            wrapper.appendChild(timer);

            // Active Buff Overlay
            const buffOverlay = document.createElement('div');
            buffOverlay.className = 'crew-buff-overlay';
            buffOverlay.style.cssText = "position:absolute; top:0; left:0; width:100%; height:100%; border:2px solid rgba(0,210,211,0.5); box-sizing:border-box; display:none; animation: pulse 0.5s infinite alternate;";
            wrapper.appendChild(buffOverlay);

            container.appendChild(wrapper);
        }

        // --- 差分更新 ---
        const currentCd = engineState.crewCooldowns[crewId] || 0;
        const maxCd = crew.ability ? crew.ability.cd : 1;
        const isReady = currentCd <= 0;
        const isActive = (engineState.crewActiveBuffs[crewId] || 0) > 0;

        // 1. スタイル更新
        const borderColor = isActive ? '#00d2d3' : (engineState.isBossWave ? '#e74c3c' : '#444');
        const shadow = isActive ? '0 0 15px #00d2d3' : (engineState.isBossWave ? '0 0 15px red' : '0 0 5px #000');

        wrapper.style.borderColor = borderColor;
        wrapper.style.boxShadow = shadow;
        wrapper.style.cursor = isReady ? 'pointer' : 'default';

        // 2. 画像更新 (表情変化)
        const img = wrapper.querySelector('.crew-face-img');
        const desiredSrc = `${crew.imgBase}${engineState.crewStatusSuffix}.png`;
        if (img && !img.src.endsWith(desiredSrc)) {
            img.src = desiredSrc;
        }
        // ダメージ時の振動
        if (engineState.crewStatusSuffix === 'b') {
            wrapper.style.transform = `translate(${(Math.random()-0.5)*5}px, ${(Math.random()-0.5)*5}px)`;
        } else {
            wrapper.style.transform = 'none';
        }

        // 3. CDオーバーレイ更新
        const cdOverlay = wrapper.querySelector('.crew-cd-overlay');
        const pct = isReady ? 0 : (currentCd / maxCd) * 100;
        if (cdOverlay) cdOverlay.style.height = `${pct}%`;

        // 4. タイマーテキスト
        const timer = wrapper.querySelector('.crew-cd-timer');
        if (timer) {
            if (currentCd > 60) {
                timer.style.display = 'block';
                timer.innerText = Math.ceil(currentCd / 60);
            } else {
                timer.style.display = 'none';
            }
        }

        // 5. Active Overlay
        const buffOverlay = wrapper.querySelector('.crew-buff-overlay');
        if (buffOverlay) buffOverlay.style.display = isActive ? 'block' : 'none';
    });
}
window.updateCrewHud = updateCrewHud;

export function showCrewSelection(onComplete) {
    const modal = document.getElementById('upgrade-selection-modal');
    const container = document.getElementById('upgrade-options-container');
    const titleEl = modal.querySelector('h2');

    if (!modal || !container) return;

    // フッターボタン（あとで決める）を非表示
    const footerBtn = document.getElementById('btn-upgrade-close');
    if (footerBtn) footerBtn.style.display = 'none';

    modal.classList.remove('hidden');
    if (titleEl) titleEl.innerText = "作戦準備：クルー選抜";
    container.innerHTML = '';
    container.style.flexDirection = 'column'; // Vertical stack
    container.style.alignItems = 'center';

    // 選択状態
    let selectedCrewIds = [];
    let selectedGemId = 'fireball'; // Default

    // --- 1. 初期装備選択エリア ---
    const gemSection = document.createElement('div');
    gemSection.style.width = '100%';
    gemSection.innerHTML = '<div style="color:#00d2d3; font-weight:bold; margin-bottom:5px; text-align:center;">初期ウェポン選択</div>';

    const gemOptions = document.createElement('div');
    gemOptions.style.display = 'flex';
    gemOptions.style.gap = '10px';
    gemOptions.style.justifyContent = 'center';
    gemOptions.style.marginBottom = '15px';

    // 選択可能な初期GEM（使いやすいものを選抜: 火球、矢、電気）
    const targetIds = ['fireball', 'arrow', 'electric']; 
    const availableGems = targetIds.map(id => Object.values(GEMS).find(g => g.id === id)).filter(g => g);

    availableGems.forEach(gem => {
        const el = document.createElement('div');
        el.className = 'upgrade-card';
        el.style.width = '70px';
        el.style.flexDirection = 'column';
        el.style.padding = '8px';
        el.style.border = gem.id === selectedGemId ? '2px solid #f1c40f' : '1px solid #555';
        el.style.background = gem.id === selectedGemId ? 'rgba(241, 196, 15, 0.2)' : 'rgba(0,0,0,0.5)';
        el.innerHTML = `<div style="font-size:20px; margin-bottom:4px;">⚔️</div><div style="font-size:10px; text-align:center;">${gem.name}</div>`;
        el.onclick = () => {
            selectedGemId = gem.id;
            Array.from(gemOptions.children).forEach(c => {
                c.style.border = '1px solid #555';
                c.style.background = 'rgba(0,0,0,0.5)';
            });
            el.style.border = '2px solid #f1c40f';
            el.style.background = 'rgba(241, 196, 15, 0.2)';
        };
        gemOptions.appendChild(el);
    });
    gemSection.appendChild(gemOptions);
    container.appendChild(gemSection);

    // --- 2. クルー選択エリア ---
    const crewSection = document.createElement('div');
    crewSection.style.width = '100%';
    crewSection.innerHTML = '<div style="color:#e74c3c; font-weight:bold; margin-bottom:5px; text-align:center;">クルー選択 (2名)</div>';

    const crewGrid = document.createElement('div');
    crewGrid.style.display = 'grid';
    crewGrid.style.gridTemplateColumns = '1fr 1fr';
    crewGrid.style.gap = '8px';
    crewGrid.style.width = '100%';

    Object.values(CREW_DATA).forEach(crew => {
        const el = document.createElement('div');
        el.className = 'upgrade-card';
        el.style.padding = '5px';
        el.style.alignItems = 'center';
        el.style.gap = '8px';
        el.style.cursor = 'pointer';

        // Render content
        const render = () => {
            const isSelected = selectedCrewIds.includes(crew.id);
            el.style.borderColor = isSelected ? '#f1c40f' : '#555';
            el.style.background = isSelected ? 'rgba(231, 76, 60, 0.3)' : 'rgba(0,0,0,0.5)';
            el.innerHTML = `
                <img src="${crew.imgBase}a.png" style="width:36px; height:36px; border-radius:4px; image-rendering:pixelated; border:1px solid #777;">
                <div style="flex:1;">
                    <div style="font-size:11px; font-weight:bold; color:${isSelected ? '#f1c40f' : '#fff'};">${crew.name}</div>
                    <div style="font-size:8px; color:#ccc;">${crew.desc}</div>
                </div>
            `;
        };
        render();

        el.onclick = () => {
            if (selectedCrewIds.includes(crew.id)) {
                selectedCrewIds = selectedCrewIds.filter(id => id !== crew.id);
            } else {
                if (selectedCrewIds.length < 2) {
                    selectedCrewIds.push(crew.id);
                }
            }
            // Re-render all to update styles (simple enough)
            Array.from(crewGrid.children).forEach((child, idx) => {
                // Warning: This depends on order matching. 
                // Better to just update styles here or re-render logical state.
                // For simplicity, we just toggle this element's style logic via closure
            });
            // Re-render *all* because we need to reflect selection limit? 
            // Actually just re-rendering this one and updating the button is enough.
            render();
            updateStartBtn();
        };
        crewGrid.appendChild(el);
    });
    crewSection.appendChild(crewGrid);
    container.appendChild(crewSection);

    // --- 3. 開始ボタン ---
    const btnArea = document.createElement('div');
    btnArea.style.width = '100%';
    btnArea.style.marginTop = '15px';

    const startBtn = document.createElement('button');
    startBtn.className = 'upgrade-btn';
    startBtn.style.width = '100%';
    startBtn.style.fontWeight = 'bold';
    startBtn.style.fontSize = '16px';
    startBtn.style.padding = '12px';
    startBtn.innerText = "出撃不可 (クルーを2名選択)";
    startBtn.disabled = true;
    startBtn.style.opacity = 0.5;

    startBtn.onclick = () => {
        const startGem = availableGems.find(g => g.id === selectedGemId) || GEMS.FIREBALL;
        modal.classList.add('hidden');
        onComplete(selectedCrewIds, startGem);
    };

    btnArea.appendChild(startBtn);
    container.appendChild(btnArea);

    function updateStartBtn() {
        if (selectedCrewIds.length === 2) {
            startBtn.disabled = false;
            startBtn.style.opacity = 1;
            startBtn.style.background = '#e74c3c';
            startBtn.style.color = '#fff';
            startBtn.innerText = "MISSION START";
        } else {
            startBtn.disabled = true;
            startBtn.style.opacity = 0.5;
            startBtn.style.background = '#333';
            startBtn.innerText = `クルーを選択 (${selectedCrewIds.length}/2)`;
        }
    }
}
window.showCrewSelection = showCrewSelection;

let selectedItemUuid = null; // Global state for tap interaction

export function refreshInventoryInterface() {
    // 画面更新時はツールチップを確実に消す
    if (window.hideTooltip) window.hideTooltip();

    const engineState = window.engineState;
    if (!engineState) return;

    const container = document.getElementById('dock-content');
    if (!container) return;
    container.innerHTML = '';

    // Remove old menu if exists
    const oldMenu = document.getElementById('action-menu');
    if (oldMenu) oldMenu.remove();

    // --- Interaction Handler (Mobile Optimized 2-Step Move) ---
    const handleSlotClick = (e, uuid, type, slotId) => {
        e.stopPropagation();
        e.preventDefault(); // ダブルタップズーム等を防止

        // 1. すでにアイテムが選択されている場合、ターゲットへ移動を試みる
        if (selectedItemUuid) {
            // 同じアイテムをタップしたら選択解除
            if (selectedItemUuid === uuid) {
                selectedItemUuid = null;
                window.hideTooltip();
                refreshInventoryInterface();
                return;
            }

            const fromInv = engineState.inventory.find(i => i.uuid === selectedItemUuid);
            if (fromInv) {
                if (type === 'SLOT') {
                    engineState.equipItem(selectedItemUuid, slotId);
                    selectedItemUuid = null;
                } else if (type === 'SALVAGE') {
                    engineState.salvageItem(selectedItemUuid);
                    selectedItemUuid = null;
                } else if (type === 'SELL') {
                    engineState.sellItem(selectedItemUuid);
                    selectedItemUuid = null;
                }
                window.hideTooltip();
                refreshInventoryInterface();
                return;
            }
        }

        // 2. 選択されていない場合、新規選択またはメニュー表示
        if (uuid) {
            audioManager.play('CLICK');
            const item = [...engineState.inventory, ...engineState.equippedGems, ...engineState.altGems, engineState.equippedArtifacts.RING, engineState.equippedArtifacts.AMULET]
                          .find(i => i && i.uuid === uuid);

            if (type === 'SLOT') {
                // 装備スロットの場合は「外す」メニューを表示
                showActionMenu((e.touches ? e.touches[0].clientX : e.clientX), (e.touches ? e.touches[0].clientY : e.clientY), uuid);
                if (item) window.showTooltip(e, item);
            } else {
                // インベントリの場合は選択状態にする
                selectedItemUuid = uuid;
                if (item) window.showTooltip(e, item);
                refreshInventoryInterface();
            }
        }
    };

    const showActionMenu = (x, y, uuid) => {
        const menu = document.createElement('div');
        menu.id = 'action-menu';
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        
        const btnUnequip = document.createElement('button');
        btnUnequip.className = 'action-btn';
        btnUnequip.innerText = '外す (Unequip)';
        btnUnequip.onclick = () => {
            engineState.unequipByUuid(uuid);
            menu.remove();
        };

        const btnCancel = document.createElement('button');
        btnCancel.className = 'action-btn';
        btnCancel.innerText = '閉じる';
        btnCancel.onclick = () => menu.remove();

        menu.appendChild(btnUnequip);
        menu.appendChild(btnCancel);
        document.body.appendChild(menu);

        // Close on outside click
        setTimeout(() => {
            window.addEventListener('click', function close(e) {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    window.removeEventListener('click', close);
                }
            });
        }, 0);
    };

    // --- Helper to create a slot ---
    const createSlot = (id, item, label, typeHint, dropTargetId) => {
        const el = document.createElement('div');
        el.className = 'gem-slot';
        if (id.includes('ring') || id.includes('amulet')) el.classList.add('acc-slot');
        
        if (typeHint === 'ACTIVE') el.classList.add('slot-active-bg');
        if (typeHint === 'SUPPORT') el.classList.add('slot-support-bg');

        if (item) {
            el.innerHTML = `<div style="text-align:center; color:${item.color}; line-height:1.1;">${item.name}<br><span style="font-size:9px; color:#fff;">Lv.${item.level}</span></div>`;
            el.style.borderColor = item.color;
            el.draggable = true;
            el.ondragstart = (e) => window.handleDragStart(e, item.uuid);
            el.ondragend = (e) => window.handleDragEnd(e);
            el.onclick = (e) => handleSlotClick(e, item.uuid, 'SLOT', dropTargetId);
            
            // Hover Tooltip
            el.onmouseenter = (e) => window.showTooltip(e, item);
            el.onmousemove = (e) => window.moveTooltip(e);
            el.onmouseleave = () => window.hideTooltip();
        } else {
            el.innerText = label;
            if (typeHint === 'ACTIVE') el.style.borderColor = '#c0392b';
            else if (typeHint === 'SUPPORT') el.style.borderColor = '#27ae60';
            else el.style.borderColor = '#444';
            
            el.onclick = (e) => handleSlotClick(e, null, 'SLOT', dropTargetId);
        }

        el.ondragover = window.allowDrop;
        el.ondrop = (e) => window.handleDrop(e, 'SLOT', dropTargetId);
        
        return el;
    };

    // [UI Patch] Sticky Loadout Header Container
    // 装備エリアを固定表示にし、スクロール時も常にドロップ先が見えるようにする
    const stickyHeader = document.createElement('div');
    stickyHeader.style.cssText = `
        position: sticky; top: -10px; z-index: 100;
        background: #0b0c10;
        margin: -10px -10px 10px -10px; padding: 10px 10px 5px 10px;
        border-bottom: 2px solid #45a29e;
        box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    `;

    // --- 0. Crew Info ---
    if (engineState.selectedCrew && engineState.selectedCrew.length > 0) {
        const crewHeader = document.createElement('div');
        crewHeader.className = 'inv-section-header';
        crewHeader.innerText = "CREW (編成)";
        stickyHeader.appendChild(crewHeader);

        const crewRow = document.createElement('div');
        crewRow.style.cssText = "display:flex; gap:6px; margin-bottom:5px;";

        engineState.selectedCrew.forEach(crewId => {
            const crew = CREW_DATA[crewId];
            if (!crew) return;
            const el = document.createElement('div');
            // [Patch] Detailed Crew Info
            el.style.cssText = "flex:1; display:flex; gap:6px; align-items:center; background:rgba(255,255,255,0.08); padding:6px; border:1px solid #555; border-radius:4px;";

            // Ability Desc Construction
            const abilityText = crew.ability ? `${crew.ability.name}: ${crew.ability.desc}` : 'No Ability';

            el.innerHTML = `
                <img src="${crew.imgBase}a.png" style="width:32px; height:32px; border-radius:4px; image-rendering:pixelated; border:1px solid #777; flex-shrink:0;">
                <div style="flex:1; overflow:hidden; display:flex; flex-direction:column; justify-content:center;">
                    <div style="font-size:11px; font-weight:bold; color:#f1c40f; line-height:1.2;">${crew.name} <span style="font-size:9px; color:#aaa; font-weight:normal;">(${crew.job})</span></div>
                    <div style="font-size:9px; color:#fff; line-height:1.2; margin-top:1px;">P: ${crew.desc}</div>
                    <div style="font-size:9px; color:#00d2d3; line-height:1.2;">A: ${abilityText}</div>
                </div>
            `;
            crewRow.appendChild(el);
        });
        stickyHeader.appendChild(crewRow);
    }

    // --- 1. Main Loadout (Set 1) ---
    const mainRow = document.createElement('div');
    mainRow.className = 'loadout-row';
    mainRow.innerHTML = `<div class="loadout-label">MAIN<br><span style="color:#00d2d3">ACTIVE</span></div>`;
    engineState.equippedGems.forEach((g, i) => {
        const label = i === 0 ? "スキル" : "サポ";
        const type = i === 0 ? "ACTIVE" : "SUPPORT";
        mainRow.appendChild(createSlot(`main-slot-${i}`, g, label, type, `MAIN_${i}`));
    });
    stickyHeader.appendChild(mainRow);

    // --- 2. Sub Loadout (Set 2) ---
    const subRow = document.createElement('div');
    subRow.className = 'loadout-row';
    subRow.innerHTML = `<div class="loadout-label">SUB<br><span style="color:#f39c12">50%</span></div>`;
    engineState.altGems.forEach((g, i) => {
        const label = i === 0 ? "スキル" : "サポ";
        const type = i === 0 ? "ACTIVE" : "SUPPORT";
        subRow.appendChild(createSlot(`sub-slot-${i}`, g, label, type, `SUB_${i}`));
    });
    stickyHeader.appendChild(subRow);

    // --- 3. Accessories ---
    const accRow = document.createElement('div');
    accRow.className = 'acc-row';
    accRow.style.margin = "5px 0"; // Reduce margin
    accRow.appendChild(createSlot('slot-ring', engineState.equippedArtifacts.RING, "指輪", "RING", "RING"));
    accRow.appendChild(createSlot('slot-amulet', engineState.equippedArtifacts.AMULET, "首飾り", "AMULET", "AMULET"));
    stickyHeader.appendChild(accRow);

    // Append sticky header to container
    container.appendChild(stickyHeader);

    // --- 4. Inventory (Sorted) ---
    const invTitle = document.createElement('div');
    invTitle.className = 'inv-section-header';
    invTitle.innerText = `インベントリ (${engineState.inventory.length}/${GAME_SETTINGS.INVENTORY_CAPACITY})`;
    if (selectedItemUuid) {
        invTitle.innerHTML += ` <span style="color:#f1c40f; animation:pulse 1s infinite;">(配置先を選択...)</span>`;
    }
    container.appendChild(invTitle);

    const invGrid = document.createElement('div');
    invGrid.id = 'inventory-grid';
    // [UI Patch] Increase columns to 6 for smaller items
    invGrid.style.gridTemplateColumns = "repeat(6, 1fr)";
    invGrid.style.gap = "4px";

    invGrid.ondragover = window.allowDrop;
    invGrid.ondrop = (e) => window.handleDrop(e, 'INVENTORY');

    // Sort: Active -> Support -> Ring -> Amulet -> Others
    const sortedInv = [...engineState.inventory].sort((a, b) => {
        const typeOrder = { 'ACTIVE': 1, 'SUPPORT': 2, 'RING': 3, 'AMULET': 4 };
        const ta = typeOrder[a.type] || 99;
        const tb = typeOrder[b.type] || 99;
        if (ta !== tb) return ta - tb;
        return b.level - a.level;
    });

    sortedInv.forEach(item => {
        const slot = document.createElement('div');
        slot.className = 'inv-item';
        if (selectedItemUuid === item.uuid) slot.classList.add('selected-item');
        
        // Background Tint & Border based on Type Category
        if (item.type === 'ACTIVE') {
             slot.style.background = "rgba(192, 57, 43, 0.2)";
             slot.style.borderColor = "#c0392b"; 
        }
        else if (item.type === 'SUPPORT') {
             slot.style.background = "rgba(39, 174, 96, 0.2)";
             slot.style.borderColor = "#27ae60";
        }
        else if (item.type === 'RING') {
             slot.style.background = "rgba(41, 128, 185, 0.2)";
             slot.style.borderColor = "#2980b9";
        }
        else if (item.type === 'AMULET') {
             slot.style.background = "rgba(142, 68, 173, 0.2)";
             slot.style.borderColor = "#8e44ad";
        }
        else {
             slot.style.borderColor = item.color;
        }
        
        // Icon Logic
        let icon = '?';
        if (item.type === 'ACTIVE') icon = '⚔️'; 
        else if (item.type === 'SUPPORT') icon = '💠';
        else if (item.type === 'RING') icon = '💍';
        else if (item.type === 'AMULET') icon = '🧿';
        else if (item.id === 'gold') icon = '💰';
        
        // Rich Content: Icon + Name
        slot.innerHTML = `
            <div style="font-size:14px;">${icon}</div>
            <div class="inv-name" style="color:${item.color}">${item.name}</div>
            <span style="font-size:8px; color:#aaa; position:absolute; top:2px; right:2px;">Lv.${item.level}</span>
        `;
        
        slot.draggable = true;
        slot.dataset.uuid = item.uuid;
        
        slot.onmouseenter = (e) => window.showTooltip(e, item);
        slot.onmousemove = (e) => window.moveTooltip(e);
        slot.onmouseleave = () => window.hideTooltip();
        
        slot.ondragstart = (e) => window.handleDragStart(e, item.uuid);
        slot.ondragend = (e) => window.handleDragEnd(e);
        slot.onclick = (e) => handleSlotClick(e, item.uuid, 'INVENTORY');

        invGrid.appendChild(slot);
    });
    container.appendChild(invGrid);

    // --- 5. Conversion Areas (XP & Sell) ---
    const convertContainer = document.createElement('div');
    convertContainer.style.cssText = "margin-top:15px; display:flex; gap:10px;";

    // XP Convert
    const salvage = document.createElement('div');
    salvage.id = 'salvage-area';
    salvage.style.cssText = "flex:1; border:2px dashed #00d2d3; color:#00d2d3; padding:10px; text-align:center; font-size:12px; cursor:pointer; border-radius:4px;";
    salvage.innerHTML = "XP変換<br>(タップ/ドロップ)";
    salvage.ondragover = window.allowDrop;
    salvage.ondrop = (e) => window.handleDrop(e, 'SALVAGE');
    salvage.onclick = (e) => handleSlotClick(e, null, 'SALVAGE');
    
    // Sell
    const sell = document.createElement('div');
    sell.id = 'sell-area';
    sell.style.cssText = "flex:1; border:2px dashed #f1c40f; color:#f1c40f; padding:10px; text-align:center; font-size:12px; cursor:pointer; border-radius:4px;";
    sell.innerHTML = "売却 (Gold)<br>(タップ/ドロップ)";
    sell.ondragover = window.allowDrop;
    sell.ondrop = (e) => window.handleDrop(e, 'SELL');
    sell.onclick = (e) => handleSlotClick(e, null, 'SELL');

    convertContainer.appendChild(salvage);
    convertContainer.appendChild(sell);
    container.appendChild(convertContainer);

    // --- 6. Boss Artifacts List ---
    if (engineState.artifacts.length > 0) {
        const artHeader = document.createElement('div');
        artHeader.className = 'inv-section-header';
        artHeader.innerText = "所持アーティファクト";
        container.appendChild(artHeader);

        const artGrid = document.createElement('div');
        artGrid.style.cssText = "display:flex; flex-wrap:wrap; gap:5px; margin-top:5px;";
        
        engineState.artifacts.forEach((art, idx) => {
            const el = document.createElement('div');
            el.style.cssText = `width:40px; height:40px; border:1px solid ${art.color}; background:rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; font-size:20px; cursor:pointer; position:relative;`;
            el.innerHTML = art.icon;
            
            // Delete button on hover/tap
            const delBtn = document.createElement('div');
            delBtn.innerText = "×";
            delBtn.style.cssText = "position:absolute; top:-5px; right:-5px; background:#e74c3c; color:white; width:18px; height:18px; border-radius:50%; font-size:12px; line-height:18px; text-align:center; display:none; pointer-events:auto; border:1px solid white;";
            el.appendChild(delBtn);

            // PC hover
            el.onmouseenter = (e) => {
                delBtn.style.display = "block";
                window.showTooltip(e, art);
            };
            el.onmouseleave = () => {
                delBtn.style.display = "none";
                window.hideTooltip();
            };

            // アイコンクリック時はツールチップのみ（破棄しない）
            el.onclick = (e) => {
                e.stopPropagation();
                window.showTooltip(e, art);
                // モバイル用に×ボタンを一瞬表示させる
                delBtn.style.display = "block";
                setTimeout(() => { if(!el.matches(':hover')) delBtn.style.display = "none"; }, 3000);
            };

            // ×ボタンをクリックした時だけ破棄の確認を出す
            delBtn.onclick = (e) => {
                e.stopPropagation(); // 親のel.onclickを発動させない
                audioManager.play('CLICK');
                if (confirm(`「${art.name}」を破棄してスロットを空けますか？`)) {
                    engineState.artifacts.splice(idx, 1);
                    engineState.recalcStats();
                    window.refreshInventoryInterface();
                    window.updateArtifactHud();
                }
            };

            artGrid.appendChild(el);
        });
        container.appendChild(artGrid);
    }
}
window.refreshInventoryInterface = refreshInventoryInterface;

export function refreshShopInterface() {
    const container = document.getElementById('shop-grid');
    if (!container) return;
    container.innerHTML = '';
    const engineState = window.engineState;

    const createCard = (item, isGem = false) => {
        const isSoldOut = isGem && engineState.purchasedShopItems.includes(item.id);
        const card = document.createElement('div');
        // Simple card style inline
        card.style.cssText = `background:rgba(0,0,0,0.5); border:1px solid #444; padding:5px; border-radius:4px; display:flex; align-items:center; opacity:${isSoldOut ? 0.5 : 1}; cursor:${isSoldOut ? 'default' : 'pointer'};`;

        const cost = isGem ? 300 : item.cost;

        let icon = item.icon;
        if (isGem) {
            icon = (item.type === GEM_TYPES.ACTIVE) ? '⚔️' : '💠';
        }

        const desc = isGem ? 'Lv.1 習得' : item.desc;
        const name = item.name;

        card.innerHTML = `
            <div style="font-size:20px; margin-right:8px;">${icon}</div>
            <div style="flex:1;">
                <div style="font-weight:bold; font-size:12px; color:${item.color || '#f1c40f'}">${name}</div>
                <div style="font-size:10px; color:#aaa;">${desc}</div>
                <div style="color:${isSoldOut ? '#e74c3c' : '#fff'}; font-size:11px;">${isSoldOut ? 'SOLD OUT' : cost + ' G'}</div>
            </div>
        `;

        if (!isSoldOut) {
            card.onclick = () => {
                if (item.id === 'mystery') engineState.buyMysteryBox();
                else engineState.buyShopItem(item.id);
            };
        }
        container.appendChild(card);
    };

    Object.values(SHOP_ITEMS).forEach(item => createCard(item));
    Object.values(GEMS).forEach(gem => {
        // アクティブGEMおよびサポートGEMの両方をショップのラインナップに表示
        createCard(gem, true);
    });
}
window.refreshShopInterface = refreshShopInterface;

// --- Skill Tree Renderer ---

export function renderSkillTree() {
    const container = document.getElementById('skill-tree-content');
    if (!container) return;
    container.innerHTML = '';

    const engineState = window.engineState;
    
    // Canvas for lines
    const canvas = document.createElement('canvas');
    canvas.width = GAME_SETTINGS.TREE_WIDTH;
    canvas.height = GAME_SETTINGS.TREE_HEIGHT;
    canvas.style.cssText = "position:absolute; top:0; left:0; pointer-events:none; z-index:1;";
    container.appendChild(canvas);
    const ctx = canvas.getContext('2d');

    // Render Connections
    ctx.lineWidth = 4;
    Object.values(SKILL_TREE_NODES).forEach(node => {
        if (node.connections) {
            node.connections.forEach(targetId => {
                const target = SKILL_TREE_NODES[targetId];
                if (target) {
                    const nodeRank = engineState.allocatedNodes[node.id] || 0;
                    const targetRank = engineState.allocatedNodes[targetId] || 0;
                    const isAllocated = (nodeRank > 0 && targetRank > 0);
                    
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(target.x, target.y);
                    ctx.strokeStyle = isAllocated ? "#f1c40f" : "#444";
                    ctx.stroke();
                }
            });
        }
    });

    // Render Nodes
    Object.values(SKILL_TREE_NODES).forEach(node => {
        const el = document.createElement('div');
        const rank = engineState.allocatedNodes[node.id] || 0;
        const max = node.maxRank || 1;
        const isAllocated = rank > 0;
        const isMaxed = rank >= max;

        // Base Classes
        let className = 'tree-node '; 
        if (node.type === 'START') className += 'node-start';
        else if (node.type === 'KEYSTONE') className += 'node-keystone';
        else if (node.type === 'MEDIUM') className += 'node-medium';
        if (isAllocated) className += ' allocated';

        el.className = className;
        el.style.left = `${node.x}px`;
        el.style.top = `${node.y}px`;

        // Reset default border/bg to handle custom progress ring
        el.style.border = 'none';
        el.style.background = 'transparent';
        el.style.display = 'flex';
        el.style.alignItems = 'center';
        el.style.justifyContent = 'center';

        // 1. Progress Ring (Background)
        const progressEl = document.createElement('div');
        const percent = (rank / max) * 100;
        // Color: Max=Cyan, Allocated=Gold, Locked=Gray
        let progressColor = isMaxed ? '#00d2d3' : (isAllocated ? '#f1c40f' : '#444'); 
        if (rank === 0) progressColor = '#555'; 

        // Keystone(45deg) needs rotation fix for gradient start
        const startAngle = node.type === 'KEYSTONE' ? 'from -45deg' : 'from 0deg';

        progressEl.style.cssText = `
            position: absolute; top:0; left:0; width:100%; height:100%;
            border-radius: ${node.type === 'KEYSTONE' ? '8px' : '50%'};
            background: conic-gradient(${startAngle} at 50% 50%, ${progressColor} ${percent}%, #2c3e50 0);
            z-index: 0;
            box-shadow: ${isMaxed ? `0 0 15px ${progressColor}` : '0 0 5px rgba(0,0,0,0.5)'};
        `;
        el.appendChild(progressEl);

        // 2. Inner Content (The actual "Node" look)
        const innerEl = document.createElement('div');
        const borderW = 4; // Thickness of the progress ring
        let bg = '#222';
        if (isAllocated) {
            if (node.type === 'KEYSTONE') bg = '#c0392b';
            else if (node.type === 'MEDIUM') bg = '#6c5ce7';
            else bg = '#f1c40f';
        }

        innerEl.style.cssText = `
            position: absolute; 
            top:${borderW}px; left:${borderW}px; 
            width:calc(100% - ${borderW*2}px); height:calc(100% - ${borderW*2}px);
            background: ${bg};
            border-radius: ${node.type === 'KEYSTONE' ? '4px' : '50%'};
            z-index: 1;
            display: flex; align-items: center; justify-content: center;
        `;
        el.appendChild(innerEl);

        // Rank Badge (High Visibility)
        if (max > 1) {
            const badge = document.createElement('div');
            badge.innerText = `${rank}/${max}`;
            // Rotate back if keystone
            const transform = node.type === 'KEYSTONE' ? 'rotate(-45deg)' : '';
            // Center the badge inside the node to avoid overlapping with the label below
            badge.style.cssText = `
                position: absolute; 
                top: 50%; left: 50%; 
                transform: translate(-50%, -50%) ${transform};
                font-size: 10px; font-weight: bold; color: #fff;
                text-shadow: 0 0 3px #000, 0 0 1px #000;
                pointer-events: none; z-index: 10;
                white-space: nowrap;
            `;
            // Highlight if maxed
            if (isMaxed) {
                badge.style.color = '#00d2d3';
                badge.style.textShadow = '0 0 3px #000';
            }
            el.appendChild(badge);
        }

        // Label
        if (node.label) {
            const label = document.createElement('div');
            label.className = 'node-label';
            label.innerText = node.label;
            // Keystone label positioning fix
            if (node.type === 'KEYSTONE') {
                 label.style.transform = 'translateX(-50%) rotate(-45deg)';
                 label.style.top = '120%';
            }
            el.appendChild(label);
        }

        // Interaction
        el.onclick = (e) => {
            e.stopPropagation();
            if (engineState.allocateNode(node.id)) {
                window.renderSkillTree();
                window.updateHudDisplay();
            }
        };

        el.onmouseenter = (e) => window.showTooltip(e, {
            name: node.name,
            desc: node.description,
            color: isAllocated ? '#f1c40f' : '#aaa'
        });
        el.onmouseleave = window.hideTooltip;

        container.appendChild(el);
    });
}
window.renderSkillTree = renderSkillTree;

// =====================================================
// Skill Tree Viewport Controls (mouse / keyboard / touch)
// =====================================================

function _getSkillTreeEls() {
    const modal = document.getElementById('skill-tree-modal');
    const viewport = document.getElementById('skill-tree-viewport');
    const content = document.getElementById('skill-tree-content');
    return { modal, viewport, content };
}

function _ensureSkillTreeViewState() {
    if (!window.skillTreeViewState) {
        window.skillTreeViewState = {
            scale: 1,
            x: 0,
            y: 0,
            initialized: false,
            _controlsBound: false,
            _renderWrapped: false
        };
    }
    return window.skillTreeViewState;
}

function _clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
}

function applySkillTreeTransform() {
    const { content } = _getSkillTreeEls();
    if (!content) return;
    const state = _ensureSkillTreeViewState();
    content.style.transformOrigin = '0 0';
    content.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
}
window.applySkillTreeTransform = applySkillTreeTransform;

function centerSkillTreeViewport(force = false) {
    const { viewport, content } = _getSkillTreeEls();
    if (!viewport || !content) return;

    const state = _ensureSkillTreeViewState();

    // If already initialized and not forced, just re-apply transform after re-render
    if (state.initialized && !force) {
        applySkillTreeTransform();
        return;
    }

    const vw = viewport.clientWidth || 1;
    const vh = viewport.clientHeight || 1;

    const treeW = (window.GAME_SETTINGS && window.GAME_SETTINGS.TREE_WIDTH)
        ? window.GAME_SETTINGS.TREE_WIDTH
        : (parseFloat(content.style.width) || 2000);

    const treeH = (window.GAME_SETTINGS && window.GAME_SETTINGS.TREE_HEIGHT)
        ? window.GAME_SETTINGS.TREE_HEIGHT
        : (parseFloat(content.style.height) || 1500);

    // Fit inside viewport a bit
    const fitScale = Math.min(vw / treeW, vh / treeH) * 0.92;
    state.scale = _clamp(fitScale, 0.35, 2.5);

    state.x = (vw - treeW * state.scale) / 2;
    state.y = (vh - treeH * state.scale) / 2;

    state.initialized = true;
    applySkillTreeTransform();
}
window.centerSkillTreeViewport = centerSkillTreeViewport;

function _zoomAtScreenPoint(screenX, screenY, nextScale) {
    const { viewport } = _getSkillTreeEls();
    if (!viewport) return;

    const state = _ensureSkillTreeViewState();

    const rect = viewport.getBoundingClientRect();
    const vx = screenX - rect.left;
    const vy = screenY - rect.top;

    const prev = state.scale;
    const ns = _clamp(nextScale, 0.35, 2.5);
    if (Math.abs(ns - prev) < 1e-6) return;

    // Keep (vx, vy) stable
    const contentX = (vx - state.x) / prev;
    const contentY = (vy - state.y) / prev;

    state.scale = ns;
    state.x = vx - contentX * ns;
    state.y = vy - contentY * ns;

    applySkillTreeTransform();
}

export function initSkillTreeViewportControls() {
    const { modal, viewport } = _getSkillTreeEls();
    if (!modal || !viewport) return;

    const state = _ensureSkillTreeViewState();
    if (state._controlsBound) return;
    state._controlsBound = true;

    viewport.tabIndex = 0;

    const activePointers = new Map();
    let isDragging = false;
    let isRealDrag = false; // 移動量が閾値を超えたかどうかのフラグ
    let dragBase = { x: 0, y: 0, baseX: 0, baseY: 0 };
    let startPos = { x: 0, y: 0 }; // クリック判定用の開始座標
    let pinch = null; // { dist, baseScale }

    function isOpen() {
        return !modal.classList.contains('hidden');
    }

    function dist(p1, p2) {
        const dx = p1.x - p2.x;
        const dy = p1.y - p2.y;
        return Math.hypot(dx, dy);
    }

    function mid(p1, p2) {
        return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    }

    viewport.addEventListener('pointerdown', (e) => {
        if (!isOpen()) return;
        e.preventDefault();
        viewport.setPointerCapture(e.pointerId);
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        const pts = Array.from(activePointers.values());
        if (pts.length === 1) {
            isDragging = true;
            isRealDrag = false;
            startPos = { x: e.clientX, y: e.clientY };
            dragBase = { x: e.clientX, y: e.clientY, baseX: state.x, baseY: state.y };
            pinch = null;
        } else if (pts.length === 2) {
            pinch = { dist: dist(pts[0], pts[1]), baseScale: state.scale };
            isDragging = false;
            isRealDrag = true; // ピンチ操作はクリックとみなさない
        }
    }, { passive: false });

    viewport.addEventListener('pointermove', (e) => {
        if (!isOpen()) return;
        if (!activePointers.has(e.pointerId)) return;

        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        const pts = Array.from(activePointers.values());

        if (pts.length === 1 && isDragging) {
            const dx = e.clientX - dragBase.x;
            const dy = e.clientY - dragBase.y;
            
            // 閾値判定 (5px以上動いたらドラッグとみなす)
            if (!isRealDrag && Math.hypot(e.clientX - startPos.x, e.clientY - startPos.y) > 5) {
                isRealDrag = true;
            }

            state.x = dragBase.baseX + dx;
            state.y = dragBase.baseY + dy;
            applySkillTreeTransform();
            return;
        }

        if (pts.length === 2 && pinch) {
            const m = mid(pts[0], pts[1]);
            const d = dist(pts[0], pts[1]);
            const ratio = d / (pinch.dist || 1);
            _zoomAtScreenPoint(m.x, m.y, pinch.baseScale * ratio);
        }
    }, { passive: false });

    function endPointer(e) {
        if (activePointers.has(e.pointerId)) {
            // クリック判定: ドラッグ（移動）しておらず、かつ指が1本だけの操作終了時
            if (!isRealDrag && activePointers.size === 1) {
                // setPointerCaptureしているため、ターゲット要素を再取得する
                // viewportのキャプチャを一瞬解除するか、elementFromPointを使用する
                try {
                    viewport.releasePointerCapture(e.pointerId);
                } catch(err) {}

                const el = document.elementFromPoint(e.clientX, e.clientY);
                // ツリーノードまたはその子要素をクリックしたか判定
                const nodeEl = el?.closest('.tree-node');
                if (nodeEl && typeof nodeEl.onclick === 'function') {
                    // 明示的にクリックハンドラを実行
                    nodeEl.onclick(e);
                }
            }
            activePointers.delete(e.pointerId);
        }
        
        const pts = Array.from(activePointers.values());
        if (pts.length < 2) pinch = null;
        if (pts.length === 0) isDragging = false;
    }

    viewport.addEventListener('pointerup', endPointer, { passive: true });
    viewport.addEventListener('pointercancel', endPointer, { passive: true });

    // Wheel zoom (desktop)
    viewport.addEventListener('wheel', (e) => {
        if (!isOpen()) return;
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.92 : 1.08;
        _zoomAtScreenPoint(e.clientX, e.clientY, state.scale * factor);
    }, { passive: false });

    // Keyboard pan/zoom (when skill tree open)
    window.addEventListener('keydown', (e) => {
        if (!isOpen()) return;

        const step = e.shiftKey ? 80 : 40;
        let handled = true;

        if (e.key === 'ArrowLeft') state.x += step;
        else if (e.key === 'ArrowRight') state.x -= step;
        else if (e.key === 'ArrowUp') state.y += step;
        else if (e.key === 'ArrowDown') state.y -= step;
        else if (e.key === '+' || e.key === '=') {
            const r = viewport.getBoundingClientRect();
            _zoomAtScreenPoint(r.left + r.width / 2, r.top + r.height / 2, state.scale * 1.10);
        }
        else if (e.key === '-' || e.key === '_') {
            const r = viewport.getBoundingClientRect();
            _zoomAtScreenPoint(r.left + r.width / 2, r.top + r.height / 2, state.scale * 0.90);
        }
        else if (e.key === '0') {
            centerSkillTreeViewport(true);
        }
        else {
            handled = false;
        }

        if (handled) {
            e.preventDefault();
            applySkillTreeTransform();
        }
    }, { passive: false });

    // Wrap renderSkillTree once so transform persists after re-render
    const original = window.renderSkillTree;
    if (!state._renderWrapped && typeof original === 'function') {
        state._renderWrapped = true;
        window.renderSkillTree = function () {
            original();
            requestAnimationFrame(() => {
                applySkillTreeTransform();
            });
        };
    }
}
window.initSkillTreeViewportControls = initSkillTreeViewportControls;

// --- Level Up Options (Smart Suggestion System V2) ---

/**
 * レベルアップ選択肢を表示
 * @param {boolean} fromQueue - キューからの連続呼び出しフラグ
 */
export function showLevelUpOptions(fromQueue = false) {
    // Queue Check: 既に開いている場合はキューに積むが、キューからの呼び出し時はそのまま続行
    if (!fromQueue && isModalOpen()) {
        uiQueue.push(showLevelUpOptions);
        return;
    }

    const engineState = window.engineState;
    const modal = document.getElementById('upgrade-selection-modal');
    const container = document.getElementById('upgrade-options-container');
    if (!modal || !container) return;

    // フッターボタン（あとで決める）を表示復帰
    const footerBtn = document.getElementById('btn-upgrade-close');
    if (footerBtn) footerBtn.style.display = 'block';

    // Set Title
    const titleEl = modal.querySelector('h2');
    if (titleEl) titleEl.innerText = "レベルアップ！";

    engineState.isPaused = true;
    modal.classList.remove('hidden');
    container.innerHTML = '';

    const options = [];
    const maxHP = GAME_SETTINGS.BASE_MAX_HP + engineState.stats.hp_max;
    const hpRatio = engineState.baseIntegrity / maxHP;

    const mainGem = engineState.equippedGems[0];
    const hasMain = !!mainGem;
    const isProjectile = hasMain && ['arrow', 'fireball', 'knife', 'shuriken'].includes(mainGem.id);
    const isAoE = hasMain && ['fireball', 'nova', 'rock', 'meteor'].includes(mainGem.id);
    const isRapid = hasMain && (mainGem.rate < 20);

    // 1. Survival
    if (hpRatio < 0.4) {
        options.push({
            name: '緊急メンテナンス',
            desc: 'HP全回復 + シールド展開',
            icon: '🚑',
            isRare: true,
            action: () => {
                engineState.baseIntegrity = maxHP;
                engineState.setShieldState(true);
            }
        });
    }

    // 2. Skill Tree
    const availableNodes = [];
    Object.values(SKILL_TREE_NODES).forEach(node => {
        const rank = engineState.allocatedNodes[node.id] || 0;
        const max = node.maxRank || 1;
        if (rank < max) {
            let connectable = (rank > 0);
            if (!connectable) {
                Object.keys(engineState.allocatedNodes).forEach(ownedId => {
                    const oid = parseInt(ownedId);
                    if (engineState.allocatedNodes[oid] > 0) {
                        if (SKILL_TREE_NODES[oid].connections.includes(node.id)) connectable = true;
                        if (node.connections.includes(oid)) connectable = true;
                    }
                });
            }
            if (connectable) {
                let score = 10;
                if (node.type === 'KEYSTONE') score += 50;
                if (node.stats) {
                    if (node.stats.damage_pct) score += 20;
                    if (node.stats.rate_pct) score += 20;
                    if (node.stats.proj_speed_pct && isProjectile) score += 40;
                    if (node.stats.aoe_pct && isAoE) score += 40;
                    if (node.stats.crit_chance && (isRapid || engineState.stats.crit_chance > 0.1)) score += 30;
                    if (node.stats.life_on_hit && isRapid) score += 30;
                }
                availableNodes.push({ node, score });
            }
        }
    });
    if (availableNodes.length > 0) {
        availableNodes.sort((a, b) => b.score - a.score);
        const topCandidates = availableNodes.slice(0, 3);
        const selected = topCandidates[Math.floor(Math.random() * topCandidates.length)];
        const node = selected.node;
        options.push({
            name: `習得: ${node.label || node.name}`,
            desc: `${node.description} (ランク ${engineState.allocatedNodes[node.id]||0}/${node.maxRank})`,
            icon: '🌲',
            isRare: node.type === 'KEYSTONE',
            action: () => {
                // allocateNodeはSPを消費するため、一時的にSPを付与して相殺する (レベルアップ報酬はコストフリー)
                engineState.skillPoints++;
                if (engineState.allocateNode(node.id)) {
                    window.renderSkillTree();
                    window.updateHudDisplay();
                } else {
                    engineState.skillPoints--; // 万が一失敗した場合は戻す
                }
            }
        });
    }

    // 3. Equipment
    if (options.length < 3) {
        const allGems = Object.values(GEMS);
        let candidates = [];
        if (!hasMain) candidates = allGems.filter(g => g.type === GEM_TYPES.ACTIVE);
        else candidates = allGems.filter(g => g.type === GEM_TYPES.SUPPORT);
        if (candidates.length > 0) {
            const randomGem = candidates[Math.floor(Math.random() * candidates.length)];
            options.push({
                name: `支給: ${randomGem.name}`,
                desc: `インベントリに「${randomGem.name}」を追加`,
                icon: '💎',
                isRare: false,
                action: () => {
                    engineState.addItemToInventory(randomGem);
                }
            });
        }
    }

    // 4. Fillers
    while (options.length < 3) {
        const statTypes = [
            { 
                name: '攻撃力微増', desc: '全ダメージ +3%', icon: '⚔️',
                apply: () => {
                    engineState.bonusStats.damage_pct = (engineState.bonusStats.damage_pct || 0) + 0.03;
                    engineState.recalcStats();
                } 
            },
            { 
                name: '速度微増', desc: '攻撃速度 +3%', icon: '⚡',
                apply: () => {
                    engineState.bonusStats.rate_pct = (engineState.bonusStats.rate_pct || 0) + 0.03;
                    engineState.recalcStats();
                } 
            },
            { 
                name: '小銭', desc: '150 Gold獲得', icon: '💰',
                apply: () => engineState.gold += 150 
            }
        ];
        const statOpt = statTypes[Math.floor(Math.random() * statTypes.length)];
        options.push({
            name: statOpt.name,
            desc: statOpt.desc,
            icon: statOpt.icon,
            isRare: false,
            action: () => {
                statOpt.apply();
            }
        });
    }

    // Render
    options.slice(0, 3).forEach(opt => {
        const card = document.createElement('div');
        card.className = `upgrade-card ${opt.isRare ? 'rare' : ''}`;
        card.innerHTML = `
            <div class="upgrade-icon">${opt.icon}</div>
            <div class="upgrade-info">
                <div class="upgrade-name">${opt.name}</div>
                <div class="upgrade-desc">${opt.desc}</div>
            </div>
        `;
        card.onclick = () => {
            audioManager.play('CLICK');
            // SPチェック削除: 報酬はコストフリーで受け取れる
            opt.action();

            // Check Queue: If next task exists, run it and DO NOT hide modal
            if (processNextUiTask()) {
                return;
            }

            // No tasks left, close modal
            modal.classList.add('hidden');
            engineState.isPaused = false;
        };
        container.appendChild(card);
    });
}
window.showLevelUpOptions = showLevelUpOptions;

export function showArtifactSelection(fromQueue = false) {
    if (!fromQueue && isModalOpen()) {
        uiQueue.push(showArtifactSelection);
        return;
    }

    const engineState = window.engineState;
    const modal = document.getElementById('upgrade-selection-modal');
    const container = document.getElementById('upgrade-options-container');
    if (!modal || !container) return;

    // フッターボタン（あとで決める）を非表示
    const footerBtn = document.getElementById('btn-upgrade-close');
    if (footerBtn) footerBtn.style.display = 'none';

    // Force clear & update title
    container.innerHTML = '';
    const titleEl = modal.querySelector('h2');
    if (titleEl) titleEl.innerText = "ボス撃破報酬！";

    engineState.isPaused = true;
    modal.classList.remove('hidden');

    // フィルタリング: 未所持 かつ (クルー指定がない かつ 選択中クルーに合致する)
    const pool = Object.values(BOSS_ARTIFACTS).filter(a => {
        const alreadyOwned = engineState.artifacts.some(owned => owned.id === a.id);
        const crewCondition = !a.requiredCrewId || engineState.selectedCrew.includes(a.requiredCrewId);
        return !alreadyOwned && crewCondition;
    });
    const choices = [];

    for(let i=0; i<3; i++) {
        if(pool.length === 0) break;
        const idx = Math.floor(Math.random() * pool.length);
        choices.push(pool[idx]);
        pool.splice(idx, 1);
    }

    if (choices.length === 0) {
        choices.push({ name: "大金貨", desc: "1000 Gold", icon: "💰", action: () => engineState.gold += 1000 });
    }

    // [Fix] 連打防止フラグ
    let selectionMade = false;

    choices.forEach(art => {
        const card = document.createElement('div');
        card.className = 'upgrade-card rare';
        card.style.borderColor = art.color || '#f1c40f';
        card.innerHTML = `
            <div class="upgrade-icon">${art.icon}</div>
            <div class="upgrade-info">
                <div class="upgrade-name" style="color:${art.color}">${art.name}</div>
                <div class="upgrade-desc">${art.desc}</div>
            </div>
        `;
        card.onclick = () => {
            audioManager.play('CLICK');
            // 既に選択済みなら無視
            if (selectionMade) return;
            selectionMade = true;

            // 全カードを無効化（視覚的フィードバック）
            const allCards = container.querySelectorAll('.upgrade-card');
            allCards.forEach(c => {
                c.style.pointerEvents = 'none';
                c.style.opacity = '0.5';
            });
            card.style.opacity = '1';
            card.style.boxShadow = `0 0 15px ${art.color || '#fff'}`;

            if (art.action) {
                art.action();
            } else {
                engineState.artifacts.push(art);
                engineState.recalcStats();
                window.updateArtifactHud();
                window.showToast(`獲得: ${art.name}`, art.color);
            }

            // 少し待ってから閉じる（選択した感を出すため）
            setTimeout(() => {
                if (processNextUiTask()) return;
                modal.classList.add('hidden');
                engineState.isPaused = false;
            }, 300);
        };
        container.appendChild(card);
    });
}
window.showArtifactSelection = showArtifactSelection;

export function closeUpgradeModal() {
    // If user explicitly closes (skips), we still check queue?
    // Usually 'skip' means they keep the SP.
    // Let's assume queue tasks should be processed even if skipped.
    if (processNextUiTask()) return;

    document.getElementById('upgrade-selection-modal').classList.add('hidden');
    window.engineState.isPaused = false;
}
window.closeUpgradeModal = closeUpgradeModal;

// --- General Menu Toggles ---

/**
 * シナジーの発見を記録
 * @param {string} synergyId 
 */
export function recordSynergyDiscovery(synergyId) {
    const discovered = JSON.parse(localStorage.getItem('DISCOVERED_SYNERGIES') || '{}');
    if (!discovered[synergyId]) {
        discovered[synergyId] = true;
        localStorage.setItem('DISCOVERED_SYNERGIES', JSON.stringify(discovered));
        showToast(`NEW SYNERGY: ${SYNERGY_METADATA[synergyId]?.name || synergyId}`, "#f1c40f");
    }
}
window.recordSynergyDiscovery = recordSynergyDiscovery;

/**
 * シナジー図鑑の内容を更新
 */
export function refreshSynergyEncyclopedia() {
    const container = document.getElementById('synergy-list');
    if (!container) return;
    container.innerHTML = '';

    const discovered = JSON.parse(localStorage.getItem('DISCOVERED_SYNERGIES') || '{}');

    Object.entries(SYNERGY_METADATA).forEach(([id, data]) => {
        const isFound = discovered[id];
        const card = document.createElement('div');
        card.style.cssText = `
            background: ${isFound ? 'rgba(30, 40, 50, 0.8)' : 'rgba(0,0,0,0.4)'};
            border: 1px solid ${isFound ? '#66fcf1' : '#333'};
            padding: 10px; border-radius: 8px; display: flex; flex-direction: column; gap: 5px;
            opacity: ${isFound ? '1' : '0.5'};
            transition: 0.3s;
        `;

        if (isFound) {
            card.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="color:#66fcf1; font-weight:bold; font-size:16px;">${data.name}</span>
                    <span style="font-size:10px; color:#aaa;">${data.combo.join(' + ')}</span>
                </div>
                <div style="font-size:12px; color:#ccc; line-height:1.4;">${data.desc}</div>
            `;
        } else {
            card.innerHTML = `
                <div style="color:#555; font-weight:bold; text-align:center; padding:10px;">??? (未発見)</div>
            `;
        }
        container.appendChild(card);
    });
}
window.refreshSynergyEncyclopedia = refreshSynergyEncyclopedia;

export function toggleMenu(menuId) {
    const menus = ['skill-tree-modal', 'logic-modal', 'shop-modal', 'dock-modal', 'help-modal', 'synergy-modal'];
    const target = document.getElementById(menuId);

    // pre-render hooks
    if (menuId === 'synergy-modal' && target.classList.contains('hidden')) {
        refreshSynergyEncyclopedia();
    }
    if (menuId === 'skill-tree-modal' && target.classList.contains('hidden')) {
        window.renderSkillTree();
    }
    if (menuId === 'shop-modal' && target.classList.contains('hidden')) {
        window.refreshShopInterface();
    }

    menus.forEach(id => {
        if (id !== menuId) document.getElementById(id).classList.add('hidden');
    });

    audioManager.play('CLICK');
    if (target.classList.contains('hidden')) {
        target.classList.remove('hidden');
        window.engineState.isPaused = true;
        window.refreshInventoryInterface();

        // Skill Tree: viewport init + center + focus
        if (menuId === 'skill-tree-modal') {
            try {
                if (typeof window.initSkillTreeViewportControls === 'function') {
                    window.initSkillTreeViewportControls();
                }
                if (typeof window.centerSkillTreeViewport === 'function') {
                    window.centerSkillTreeViewport(true);
                }
                const vp = document.getElementById('skill-tree-viewport');
                if (vp) {
                    vp.tabIndex = 0;
                    vp.focus({ preventScroll: true });
                }
            } catch (e) {
                // ignore
            }
        }
    } else {
        target.classList.add('hidden');
        window.engineState.isPaused = false;
    }
}
window.toggleMenu = toggleMenu;

// --- Drag & Drop Handlers ---

export function handleDragStart(ev, uuid) {
    if (window.hideTooltip) window.hideTooltip(); // ドラッグ開始時に消す
    ev.dataTransfer.setData("text/plain", uuid);
    ev.dataTransfer.effectAllowed = "move";
    // opacity変更は setTimeout で遅らせないとドラッグ画像まで透明になることがある
    setTimeout(() => {
        if (ev.target) ev.target.style.opacity = '0.5';
    }, 0);
}
window.handleDragStart = handleDragStart;

export function handleDragEnd(ev) {
    if (window.hideTooltip) window.hideTooltip(); // ドラッグ終了時に消す
    if (ev.target) ev.target.style.opacity = '1.0';
}
window.handleDragEnd = handleDragEnd;

export function allowDrop(ev) {
    ev.preventDefault();
    ev.dataTransfer.dropEffect = "move";
}
window.allowDrop = allowDrop;

export function handleDrop(ev, targetType, targetIndex) {
    ev.preventDefault();
    const uuid = ev.dataTransfer.getData("text/plain");
    
    // 全アイテムの透明度をリセット (念のため)
    const allItems = document.querySelectorAll('.inv-item, .gem-slot');
    allItems.forEach(el => el.style.opacity = '1.0');

    if (!uuid) return;
    const engineState = window.engineState;

    if (targetType === 'SLOT') engineState.equipItem(uuid, targetIndex);
    else if (targetType === 'SALVAGE') engineState.salvageItem(uuid);
    else if (targetType === 'SELL') engineState.sellItem(uuid);
    else if (targetType === 'INVENTORY') engineState.unequipByUuid(uuid);
    
    window.updateHudDisplay();
}
window.handleDrop = handleDrop;

/**
 * クルーの必殺技カットインを表示する (アーケード演出)
 * @param {number} crewId - 発動したクルーのID
 */
export function showAbilityCutIn(crewId) {
    const crewData = CREW_DATA[crewId];
    if (!crewData || !crewData.ability) return;

    const overlay = document.getElementById('cutin-overlay');
    const banner = document.getElementById('cutin-banner');
    const imageElement = document.getElementById('cutin-img');
    const crewNameElement = document.getElementById('cutin-crew-name');
    const abilityNameElement = document.getElementById('cutin-ability');

    if (!overlay || !banner || !imageElement) return;

    // 演出データのセットアップ
    imageElement.src = `${crewData.imgBase}a.png`; // 通常時の顔を使用
    crewNameElement.innerText = `${crewData.job} ${crewData.name}`;
    abilityNameElement.innerText = crewData.ability.name;

    // アニメーションのトリガー
    overlay.style.display = 'block';
    banner.classList.remove('animate-cutin');

    // 強制リフロー (アニメーションを最初から再生させるため)
    void banner.offsetWidth; 

    banner.classList.add('animate-cutin');

    // 演出終了後に非表示に戻す (CSSの1.2秒に合わせて少し長めに設定)
    setTimeout(() => {
        overlay.style.display = 'none';
        banner.classList.remove('animate-cutin');
    }, 1300);
}
window.showAbilityCutIn = showAbilityCutIn;

/**
 * ゲームクリアリザルト画面を表示する
 */
/**
 * ゲームクリアリザルト画面を表示する
 */
export function showGameClearScreen() {
    const engineState = window.engineState;
    if (!engineState) return;

    // BGMを停止
    audioManager.stopBgm();

    // 既存のリザルトがあれば削除
    const oldScreen = document.getElementById('result-screen');
    if (oldScreen) oldScreen.remove();

    // オーバーレイ作成
    const overlay = document.createElement('div');
    overlay.id = 'result-screen';
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(10, 12, 16, 0.95); z-index: 9000;
        display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
        color: #fff; padding: 20px; box-sizing: border-box; overflow-y: auto;
        animation: fadeIn 1s ease-out; font-family: 'Hiragino Kaku Gothic Pro', sans-serif;
    `;

    // --- Header ---
    const header = document.createElement('div');
    header.style.textAlign = 'center';
    header.innerHTML = `
        <div style="font-size: 32px; font-weight: bold; color: #f1c40f; text-shadow: 0 0 20px #f1c40f; margin-bottom: 5px;">
            MISSION COMPLETE
        </div>
        <div style="font-size: 14px; color: #aaa; margin-bottom: 20px;">
            全WAVE クリア達成
        </div>
    `;
    overlay.appendChild(header);

    // --- Clear Time & Basic Stats ---
    const totalTimeSec = (Date.now() - engineState.startTime) / 1000;
    const mins = Math.floor(totalTimeSec / 60);
    const secs = Math.floor(totalTimeSec % 60);

    const infoBar = document.createElement('div');
    infoBar.style.cssText = "display:flex; gap:20px; font-size:14px; margin-bottom:30px; background:rgba(255,255,255,0.1); padding:10px 20px; border-radius:20px;";
    infoBar.innerHTML = `
        <div>⏱ TIME: <span style="color:#00d2d3; font-weight:bold;">${mins}m ${secs}s</span></div>
        <div>💀 KILLS: <span style="color:#e74c3c; font-weight:bold;">${engineState.experiencePoints || 0}</span> (XP Calc)</div>
        <div>💰 GOLD: <span style="color:#f1c40f; font-weight:bold;">${engineState.gold}</span></div>
    `;
    overlay.appendChild(infoBar);

    // --- Loadout Analysis Section ---
    const loadoutTitle = document.createElement('div');
    loadoutTitle.innerHTML = "📝 最終装備 & 性能分析";
    loadoutTitle.style.cssText = "width:100%; max-width:600px; border-bottom:1px solid #444; margin-bottom:15px; color:#aaa; font-size:14px;";
    overlay.appendChild(loadoutTitle);

    // Helper: Analyze and Render Skill Set
    const renderSkillSet = (gems, label, scale) => {
        const activeGem = gems[0];
        if (!activeGem) return null;

        const supports = gems.slice(1).filter(g => g !== null);
        const container = document.createElement('div');
        container.style.cssText = "width:100%; max-width:600px; background:rgba(30, 40, 50, 0.6); border:1px solid #555; border-radius:8px; padding:15px; margin-bottom:15px; display:flex; flex-direction:column; gap:10px;";

        // 1. Header (Active Skill)
        const headerRow = document.createElement('div');
        headerRow.style.cssText = "display:flex; align-items:center; gap:15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;";

        // Icon
        const iconDiv = document.createElement('div');
        iconDiv.style.cssText = `width:50px; height:50px; background:#222; border:2px solid ${activeGem.color}; border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:24px; position:relative; box-shadow:0 0 10px ${activeGem.color};`;
        iconDiv.innerHTML = "⚔️";
        const lvBadge = document.createElement('div');
        lvBadge.innerText = `Lv.${activeGem.level}`;
        lvBadge.style.cssText = "position:absolute; bottom:-5px; right:-5px; background:#000; color:#fff; font-size:10px; padding:2px 4px; border-radius:4px; border:1px solid #555;";
        iconDiv.appendChild(lvBadge);

        // Name & Label
        const nameDiv = document.createElement('div');
        nameDiv.innerHTML = `
            <div style="font-size:12px; color:#aaa;">${label} ARMAMENT</div>
            <div style="font-size:18px; font-weight:bold; color:${activeGem.color};">${activeGem.name}</div>
        `;

        // Stats Calculation (Approximation)
        // Base
        let damage = activeGem.damage || 10;
        if (activeGem.level > 1) damage *= (1 + (activeGem.level - 1) * 0.2);
        let rate = activeGem.rate || 60;
        if (activeGem.level > 1) rate *= (1 - (activeGem.level * 0.02));

        // Multipliers
        const stats = engineState.stats;
        damage *= (1.0 + stats.damage_pct);
        damage *= scale; // Main(1.0) or Sub(0.5)
        rate /= (1.0 + stats.rate_pct);

        // Apply Supports
        const supportDetails = [];
        const supportPower = 1.0 + stats.support_effect;

        supports.forEach(sup => {
            const lvl = (sup.level || 1) + (stats.support_level_bonus || 0);
            const lvlBonus = 1 + ((lvl - 1) * 0.1 * supportPower);

            let desc = "";
            if (sup.damage_mod) {
                damage *= (sup.damage_mod * lvlBonus);
                desc += `威力x${(sup.damage_mod * lvlBonus).toFixed(2)} `;
            }
            if (sup.rate_mod) {
                rate *= (sup.rate_mod / lvlBonus);
                desc += `間隔x${(sup.rate_mod / lvlBonus).toFixed(2)} `;
            }
            if (sup.id === 'multishot') {
                const count = 1 + (sup.projectiles || 1) + (lvl - 1);
                desc += `弾数+${count} `;
            }
            if (sup.pierce_count) {
                const p = sup.pierce_count + (lvl - 1);
                desc += `貫通+${p} `;
            }
            if (sup.chain_count) desc += `連鎖追加 `;

            supportDetails.push({ name: sup.name, lv: lvl, color: sup.color, desc: desc });
        });

        // Final Artifact/Passive Mods
        if (stats.final_damage_mul > 0) damage *= stats.final_damage_mul;

        const dpsTheoretical = (damage * (60 / rate)).toFixed(0);
        const rateSec = (rate / 60).toFixed(2);

        // Stats Display
        const statsDiv = document.createElement('div');
        statsDiv.style.cssText = "margin-left:auto; text-align:right; font-size:12px; line-height:1.4;";
        statsDiv.innerHTML = `
            <div>単発威力: <span style="color:#f1c40f;">${Math.floor(damage)}</span></div>
            <div>発射間隔: ${rateSec}s</div>
            <div>理論DPS: <span style="color:#00d2d3; font-weight:bold;">${dpsTheoretical}</span></div>
        `;

        headerRow.appendChild(iconDiv);
        headerRow.appendChild(nameDiv);
        headerRow.appendChild(statsDiv);
        container.appendChild(headerRow);

        // 2. Supports Visualization
        if (supportDetails.length > 0) {
            const linkRow = document.createElement('div');
            linkRow.style.cssText = "display:flex; align-items:center; gap:10px; background:rgba(0,0,0,0.3); padding:8px; border-radius:4px;";
            linkRow.innerHTML = `<div style="font-size:10px; color:#aaa; width:60px;">LINKS:</div>`;

            supportDetails.forEach(sup => {
                const supTag = document.createElement('div');
                supTag.style.cssText = `display:flex; align-items:center; gap:5px; border:1px solid ${sup.color}; padding:2px 6px; border-radius:4px; font-size:11px;`;
                supTag.innerHTML = `
                    <span style="color:${sup.color}; font-weight:bold;">${sup.name} Lv.${sup.lv}</span>
                    <span style="color:#fff; opacity:0.8; font-size:10px;">${sup.desc}</span>
                `;
                linkRow.appendChild(supTag);
            });
            container.appendChild(linkRow);
        }

        return container;
    };

    const mainPanel = renderSkillSet(engineState.equippedGems, "MAIN", 1.0);
    if (mainPanel) overlay.appendChild(mainPanel);

    const subPanel = renderSkillSet(engineState.altGems, "SUB", 0.5);
    if (subPanel) overlay.appendChild(subPanel);

    // --- Artifacts ---
    if (engineState.artifacts.length > 0) {
        const artContainer = document.createElement('div');
        artContainer.style.cssText = "width:100%; max-width:600px; display:flex; gap:5px; flex-wrap:wrap; margin-bottom:20px;";
        engineState.artifacts.forEach(art => {
            const icon = document.createElement('div');
            icon.innerHTML = art.icon;
            icon.style.cssText = `width:32px; height:32px; border:1px solid ${art.color}; background:rgba(0,0,0,0.5); border-radius:4px; display:flex; align-items:center; justify-content:center; cursor:help;`;
            // Tooltip integration
            icon.onmouseenter = (e) => window.showTooltip(e, art);
            icon.onmouseleave = window.hideTooltip;
            artContainer.appendChild(icon);
        });
        overlay.appendChild(artContainer);
    }

    // --- Actual DPS Report ---
    const statsSection = document.createElement('div');
    statsSection.style.cssText = "width:100%; max-width:600px; margin-bottom:20px;";
    statsSection.innerHTML = `<div style="border-bottom:1px solid #444; margin-bottom:10px; font-size:14px; color:#aaa;">⚔️ 戦闘実績 (Total Damage & DPS)</div>`;

    const table = document.createElement('table');
    table.style.cssText = "width:100%; font-size:12px; border-collapse:collapse;";
    table.innerHTML = `
        <tr style="color:#888; text-align:left; border-bottom:1px solid #555;">
            <th style="padding:5px;">SOURCE</th>
            <th style="text-align:right">TOTAL</th>
            <th style="text-align:right">DPS</th>
            <th style="text-align:right">%</th>
        </tr>
    `;

    // Total for percentage
    const totalDamageAll = Object.values(engineState.damageLog).reduce((a, b) => a + b, 0) || 1;
    const sortedLogs = Object.entries(engineState.damageLog).sort(([,a], [,b]) => b - a);

    sortedLogs.slice(0, 8).forEach(([srcId, val]) => { // Top 8 only
        let name = srcId;
        let color = "#fff";

        // Resolve Name (Use imported GEMS constant)
        const gem = Object.values(GEMS).find(g => g.id === srcId);

        // Check local GEMS import or use fallback
        // Since we are in ui.js which imports GEMS, use local reference.
        // Wait, GEMS might not include synergy names.

        if (gem) { name = gem.name; color = gem.color; }
        else if (srcId === 'shield_bash') { name = "シールドバッシュ"; color = "#66fcf1"; }
        else if (srcId === 'reflected_orb') { name = "反射弾"; color = "#66fcf1"; }
        else if (srcId === 'burn_dot') { name = "炎上(DoT)"; color = "#e67e22"; }
        else if (srcId === 'poison_dot') { name = "毒(DoT)"; color = "#8e44ad"; }
        // Synergy names
        else if (srcId === 'steam') { name = "蒸発反応"; color = "#dff9fb"; }
        else if (srcId === 'meltdown') { name = "融解反応"; color = "#fab1a0"; }
        else if (srcId === 'overload') { name = "過負荷"; color = "#ff5252"; }
        else if (srcId === 'superconduct') { name = "超電導"; color = "#a29bfe"; }

        const dps = (val / totalTimeSec).toFixed(1);
        const pct = ((val / totalDamageAll) * 100).toFixed(1);

        const tr = document.createElement('tr');
        tr.style.borderBottom = "1px solid #333";
        tr.innerHTML = `
            <td style="padding:4px; color:${color}">${name}</td>
            <td style="text-align:right; color:#ddd;">${Math.floor(val).toLocaleString()}</td>
            <td style="text-align:right; font-weight:bold;">${dps}</td>
            <td style="text-align:right; color:#888;">${pct}%</td>
        `;
        table.appendChild(tr);
    });
    statsSection.appendChild(table);
    overlay.appendChild(statsSection);

    // --- Buttons ---
    const btnRow = document.createElement('div');
    btnRow.style.cssText = "display:flex; gap:20px; margin-top:20px; margin-bottom:40px;";

    // Skill Tree View Button
    const treeBtn = document.createElement('button');
    treeBtn.innerHTML = "🌲 スキルツリー確認";
    treeBtn.style.cssText = "padding:12px 24px; background:#2c3e50; border:1px solid #00d2d3; color:#00d2d3; border-radius:4px; cursor:pointer; font-weight:bold;";
    treeBtn.onclick = () => {
        // Open tree modal on top of result screen
        const treeModal = document.getElementById('skill-tree-modal');
        if (treeModal) {
            toggleMenu('skill-tree-modal');
            // Force high z-index to overlay result screen
            treeModal.style.zIndex = "10000";

            // Add a temporary "Close" listener to restore z-index logic if needed, 
            // but toggleMenu handles hidden class.
            // When closing tree (via its X button), we just want to see the result screen again.
            // Result screen is z-index 9000. Tree default is lower? No, modal-overlay is 6000.
            // So manually setting 10000 works.
        }
    };
    btnRow.appendChild(treeBtn);

    // Return Button
    const returnBtn = document.createElement('button');
    returnBtn.innerText = "タイトルに戻る";
    returnBtn.style.cssText = "padding:12px 24px; background:#e74c3c; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer;";
    returnBtn.onclick = () => location.reload();
    btnRow.appendChild(returnBtn);

    overlay.appendChild(btnRow);

    // --- Wave Graph (Canvas) ---
    // (Optional: If screen space allows, keep it at bottom or remove to reduce clutter)
    // Let's keep it but make it compact.
    const chartDiv = document.createElement('div');
    chartDiv.style.cssText = "width:100%; max-width:600px; height:100px; border:1px solid #333; background:#111; border-radius:4px; position:relative;";
    const cvs = document.createElement('canvas');
    cvs.width = 600; cvs.height = 100;
    cvs.style.width = "100%"; cvs.style.height = "100%";
    chartDiv.appendChild(cvs);
    overlay.appendChild(chartDiv);

    // Simple Graph
    const ctx = cvs.getContext('2d');
    const logs = engineState.waveLog;
    if (logs.length > 1) {
        const maxTime = logs[logs.length-1].time;
        ctx.beginPath();
        ctx.strokeStyle = "#00d2d3";
        ctx.lineWidth = 2;
        ctx.moveTo(0, 100);
        logs.forEach((log, i) => {
            const x = (log.time / maxTime) * 600;
            const y = 100 - ((i / logs.length) * 80 + 10); // Rough step up
            ctx.lineTo(x, y);
            ctx.fillStyle = "#f1c40f";
            ctx.fillRect(x-2, y-2, 4, 4);
        });
        ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.5)";
        ctx.font = "10px sans-serif";
        ctx.fillText("PROGRESS", 5, 15);
    }

    // Inject Styles for FadeIn
    const style = document.createElement('style');
    style.innerHTML = `@keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }`;
    overlay.appendChild(style);

    document.body.appendChild(overlay);
}
window.showGameClearScreen = showGameClearScreen;
window.showAbilityCutIn = showAbilityCutIn;

/**
 * GEMレベルアップ（合成）の演出を表示
 */
export function showFuseEffect(item) {
    const overlay = document.getElementById('fuse-overlay');
    const banner = document.getElementById('fuse-banner');
    const nameEl = document.getElementById('fuse-item-name');
    const lvEl = document.getElementById('fuse-item-lv');

    if (!overlay || !banner) return;

    nameEl.innerText = item.name.toUpperCase();
    lvEl.innerText = `Lv.${item.level}`;

    // アイテムの色をテーマカラーに反映
    banner.style.borderColor = item.color;
    banner.style.background = `linear-gradient(90deg, transparent, ${item.color}33 50%, transparent)`;
    nameEl.style.color = item.color;
    nameEl.style.textShadow = `0 0 10px ${item.color}`;

    overlay.style.display = 'block';
    banner.classList.remove('animate-fuse');
    void banner.offsetWidth; // reflow
    banner.classList.add('animate-fuse');

    setTimeout(() => {
        overlay.style.display = 'none';
    }, 1900);
}
window.showFuseEffect = showFuseEffect;

export function toggleBgmState() {
    // クリック音を鳴らす
    audioManager.play('CLICK');

    // ミュート状態を切り替え
    const isMuted = audioManager.toggleBgm();

    // ボタンの見た目を更新
    const btn = document.getElementById('bgm-btn');
    if (btn) {
        if (isMuted) {
            btn.innerText = "♫ OFF";
            btn.style.color = "#7f8c8d";
            btn.style.borderColor = "#7f8c8d";
        } else {
            btn.innerText = "♫ ON";
            btn.style.color = "#66fcf1";
            btn.style.borderColor = "#66fcf1";
        }
    }
}
window.toggleBgmState = toggleBgmState;
▲▲▲ FILE END: ui.js ▲▲▲

▼▼▼ FILE START: utils.js ▼▼▼
/**
 * @fileoverview 汎用ユーティリティ関数
 * 憲法準拠: 1文字変数禁止、型ヒント必須。
 */

/**
 * ユニークIDを生成する
 * @returns {string} UUID文字列
 */
export function generateUuid() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

/**
 * アイテムテンプレートからインスタンスを作成する
 * @param {Object} template - アイテムの定義オブジェクト
 * @param {number} level - アイテムレベル
 * @returns {Object} インスタンス化されたアイテムオブジェクト
 */
export function createItemInstance(template, level = 1) {
    return {
        ...template,
        uuid: generateUuid(),
        level: level,
    };
}

/**
 * ゲームで使用する画像アセットの格納場所
 * @type {Object.<string, HTMLImageElement|null>}
 */
export const GAME_ASSETS = {};

/**
 * アセットのパス定義
 */
const ASSET_PATHS = {
    // Turret Parts
    BASE: 'assets/BASE.png',
    BARREL_FIREBALL: 'assets/FB.png',
    BARREL_NOVA: 'assets/NB.png',
    BARREL_ARROW: 'assets/AR.png',
    BARREL_POISON: 'assets/PO.png',
    BARREL_ROCK: 'assets/RC.png',
    BARREL_PSYCHIC: 'assets/PY.png',
    BARREL_WATER: 'assets/WA.png',
    BARREL_ELECTRIC: 'assets/EL.png',
    BARREL_PLANT: 'assets/PL.png'
};

/**
 * 定義された全画像を非同期で読み込む
 * @returns {Promise<void>}
 */
export async function loadGameAssets() {
    const promises = Object.entries(ASSET_PATHS).map(([key, path]) => {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = path;
            img.onload = () => {
                GAME_ASSETS[key] = img;
                resolve(true);
            };
            img.onerror = () => {
                console.warn(`[AssetLoader] Failed to load image: ${path}`);
                GAME_ASSETS[key] = null; // 読み込み失敗時はnull (フォールバック用)
                resolve(false);
            };
        });
    });

    await Promise.all(promises);
    console.log("[AssetLoader] All assets processing complete.");
}
▲▲▲ FILE END: utils.js ▲▲▲

▼▼▼ FILE START: config-manager.js ▼▼▼
/**
 * @fileoverview 設定管理マネージャー (ConfigManager)
 * game.js と ui.js で重複していた定義を統合。
 * 憲法準拠: 1文字変数禁止、型ヒント必須。
 */
import { GAME_SETTINGS, GEMS, EFFECT_CONSTANTS, ENEMY_TIERS } from './constants.js';

export class ConfigManager {
    constructor() {
        this.storageKey = 'PROJECT_OVERLORD_CONFIG_ULTIMATE';
        this.isVisible = false;
        // パネル要素の参照保持用
        this.panel = null;
        this.isPausedCache = false;
        
        this.init();
    }

    init() {
        // 1. Inject Default Settings if missing (安全策)
        if (GAME_SETTINGS.ROCK_SPIKES_BASE === undefined) GAME_SETTINGS.ROCK_SPIKES_BASE = 3;
        if (GAME_SETTINGS.ROCK_SPIKES_VAR === undefined) GAME_SETTINGS.ROCK_SPIKES_VAR = 3;
        if (GAME_SETTINGS.LEECH_RATIO === undefined) GAME_SETTINGS.LEECH_RATIO = 0.02;
        if (GAME_SETTINGS.ENEMY_BASE_HP === undefined) GAME_SETTINGS.ENEMY_BASE_HP = 60;
        if (GAME_SETTINGS.ENEMY_PROJECTILE_DAMAGE === undefined) GAME_SETTINGS.ENEMY_PROJECTILE_DAMAGE = 15;

        // 2. Load Saved Data
        this.load();

        // 3. Create UI
        // DOMContentLoadedを待つ必要が場合によってはあるが、モジュール読み込み時点ならbodyはある程度安全と仮定
        // 安全のため、document.bodyが存在するかチェックしてから実行
        if (document.body) {
            this.createUI();
        } else {
            window.addEventListener('DOMContentLoaded', () => this.createUI());
        }
        
        console.log("Ultimate ConfigManager V3 Initialized (Module)");
    }

    load() {
        const savedData = localStorage.getItem(this.storageKey);
        if (savedData) {
            try {
                const parsedData = JSON.parse(savedData);
                if (parsedData.gems) {
                    Object.keys(parsedData.gems).forEach(key => {
                        if (GEMS[key]) Object.assign(GEMS[key], parsedData.gems[key]);
                    });
                }
                if (parsedData.settings) Object.assign(GAME_SETTINGS, parsedData.settings);
                if (parsedData.effects) Object.assign(EFFECT_CONSTANTS, parsedData.effects);
                if (parsedData.enemies) {
                    Object.keys(parsedData.enemies).forEach(key => {
                        if (ENEMY_TIERS[key]) Object.assign(ENEMY_TIERS[key], parsedData.enemies[key]);
                    });
                }
                console.log("Config loaded from LocalStorage.");
            } catch (errorInstance) {
                console.error("Failed to load config:", errorInstance);
            }
        }
    }

    save() {
        const dataToSave = {
            gems: GEMS,
            settings: GAME_SETTINGS,
            effects: EFFECT_CONSTANTS,
            enemies: ENEMY_TIERS
        };
        localStorage.setItem(this.storageKey, JSON.stringify(dataToSave));
        
        if (window.showToast) {
            window.showToast("CONFIG SAVED!", "#2ecc71");
        } else {
            console.log("CONFIG SAVED!");
        }
    }

    reset() {
        if (confirm("Reset ALL settings to defaults? This will reload the page.")) {
            localStorage.removeItem(this.storageKey);
            location.reload();
        }
    }

    createUI() {
        // 既存のボタンやパネルがあれば削除（再生成時用）
        const oldButton = document.getElementById('config-btn');
        if (oldButton) oldButton.remove();
        const oldPanel = document.getElementById('config-panel');
        if (oldPanel) oldPanel.remove();

        // スタイルの注入
        if (!document.getElementById('config-manager-style')) {
            const styleElement = document.createElement('style');
            styleElement.id = 'config-manager-style';
            styleElement.textContent = `
                #config-panel { display: none; position: absolute; top: 50px; right: 10px; width: 420px; max-height: 85vh; overflow-y: auto; background: rgba(10, 10, 15, 0.95); border: 2px solid #00d2d3; z-index: 2000; padding: 15px; color: #fff; font-family: monospace; box-shadow: 0 0 20px rgba(0,0,0,0.8); }
                .cfg-section { margin-bottom: 20px; border-bottom: 1px solid #444; padding-bottom: 10px; }
                .cfg-header { font-size: 16px; font-weight: bold; color: #00d2d3; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
                .cfg-sub-header { font-size: 14px; font-weight: bold; color: #f1c40f; margin-top: 10px; margin-bottom: 5px; border-left: 3px solid #f1c40f; padding-left: 5px; }
                .cfg-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; padding: 2px 0; }
                .cfg-row:hover { background: rgba(255,255,255,0.05); }
                .cfg-row label { font-size: 12px; color: #bdc3c7; flex: 1; }
                .cfg-row input { width: 80px; background: #222; border: 1px solid #555; color: #fff; padding: 2px 5px; text-align: right; font-family: monospace; }
                .cfg-actions { display: flex; gap: 10px; margin-top: 20px; position: sticky; bottom: 0; background: rgba(10,10,15,0.9); padding: 10px 0; border-top: 1px solid #444; }
                .cfg-btn { flex: 1; padding: 8px; cursor: pointer; border: none; color: #fff; font-weight: bold; transition: 0.2s; }
                .cfg-btn.save { background: #27ae60; } .cfg-btn.save:hover { background: #2ecc71; }
                .cfg-btn.reset { background: #c0392b; } .cfg-btn.reset:hover { background: #e74c3c; }
                .cfg-btn.close { background: #7f8c8d; } .cfg-btn.close:hover { background: #95a5a6; }
            `;
            document.head.appendChild(styleElement);
        }

        this.panel = document.createElement('div');
        this.panel.id = 'config-panel';
        document.body.appendChild(this.panel);

        this.renderContent();
    }

    renderContent() {
        let htmlContent = '';

        // 1. GAME SETTINGS
        htmlContent += `<div class="cfg-section"><div class="cfg-header">Game Settings</div>`;
        Object.keys(GAME_SETTINGS).forEach(key => {
            if (typeof GAME_SETTINGS[key] === 'number') {
                htmlContent += this.createInputRow('GAME_SETTINGS', key, GAME_SETTINGS[key]);
            }
        });
        htmlContent += `</div>`;

        // 2. ENEMY TIERS
        htmlContent += `<div class="cfg-section"><div class="cfg-header">Enemy Tiers</div>`;
        Object.keys(ENEMY_TIERS).forEach(tierKey => {
            const tierData = ENEMY_TIERS[tierKey];
            htmlContent += `<div class="cfg-sub-header">${tierKey} (${tierData.id})</div>`;
            Object.keys(tierData).forEach(prop => {
                if (typeof tierData[prop] === 'number') {
                    htmlContent += this.createInputRow(`ENEMY_TIERS.${tierKey}`, prop, tierData[prop]);
                }
            });
        });
        htmlContent += `</div>`;

        // 3. EFFECT CONSTANTS
        htmlContent += `<div class="cfg-section"><div class="cfg-header">Effect Constants</div>`;
        Object.keys(EFFECT_CONSTANTS).forEach(key => {
             if (typeof EFFECT_CONSTANTS[key] === 'number') {
                htmlContent += this.createInputRow('EFFECT_CONSTANTS', key, EFFECT_CONSTANTS[key]);
            }
        });
        htmlContent += `</div>`;

        // 4. GEMS
        htmlContent += `<div class="cfg-section"><div class="cfg-header">Skill Parameters</div>`;
        Object.values(GEMS).forEach(gem => {
            htmlContent += `<div class="cfg-sub-header">${gem.name} (${gem.id})</div>`;
            Object.keys(gem).forEach(prop => {
                if (typeof gem[prop] === 'number') {
                    htmlContent += this.createInputRow(`GEMS.${gem.id}`, prop, gem[prop]);
                }
            });
        });
        htmlContent += `</div>`;

        // Actions
        htmlContent += `
            <div class="cfg-actions">
                <button class="cfg-btn save" onclick="window.configManager.save()">SAVE CONFIG</button>
                <button class="cfg-btn reset" onclick="window.configManager.reset()">RESET DEFAULTS</button>
                <button class="cfg-btn close" onclick="window.configManager.togglePanel()">CLOSE</button>
            </div>
        `;

        this.panel.innerHTML = htmlContent;
    }

    createInputRow(context, key, val) {
        return `
            <div class="cfg-row">
                <label>${key}</label>
                <input type="number" step="any" value="${val}" 
                    onchange="window.configManager.updateValue('${context}', '${key}', this.value)">
            </div>
        `;
    }

    updateValue(context, key, val) {
        const numericValue = parseFloat(val);
        if (isNaN(numericValue)) return;

        if (context === 'GAME_SETTINGS') {
            GAME_SETTINGS[key] = numericValue;
        } else if (context === 'EFFECT_CONSTANTS') {
            EFFECT_CONSTANTS[key] = numericValue;
        } else if (context.startsWith('GEMS.')) {
            const gemId = context.split('.')[1];
            const gemKey = Object.keys(GEMS).find(k => GEMS[k].id === gemId);
            if (gemKey && GEMS[gemKey]) GEMS[gemKey][key] = numericValue;
        } else if (context.startsWith('ENEMY_TIERS.')) {
            const tierKey = context.split('.')[1];
            if (ENEMY_TIERS[tierKey]) ENEMY_TIERS[tierKey][key] = numericValue;
        }
    }

    togglePanel() {
        this.isVisible = !this.isVisible;
        this.panel.style.display = this.isVisible ? 'block' : 'none';
        const engineState = window.engineState;

        if (this.isVisible) {
            this.renderContent(); 
            if (engineState) {
                this.isPausedCache = engineState.isPaused;
                engineState.isPaused = true;
            }
        } else {
            if (engineState) {
                // 元の状態に戻す、ただし元々ポーズされてなかった場合のみ解除
                engineState.isPaused = this.isPausedCache || false;
            }
        }
    }
}

// グローバルインスタンスの作成 (互換性維持)
if (window.configManager) delete window.configManager;
window.configManager = new ConfigManager();
▲▲▲ FILE END: config-manager.js ▲▲▲

▼▼▼ FILE START: audio-manager.js ▼▼▼
/**
 * Audio Manager Module
 * Handles SE and BGM playback using Web Audio API.
 */

export class AudioManager {
    constructor() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        
        this.buffers = {};
        this.sources = {}; 
        
        this.isMuted = false;
        this.isBgmMuted = false;
        
        this.masterVolume = 0.5;
        this.seVolume = 0.8;
        this.bgmVolume = 0.03;

        this.currentBgmKey = null;

        this.assetPaths = {
            'SHOOT': 'assets/sounds/SHOOT.wav',
            'CLICK': 'assets/sounds/CLICK.wav',
            'BGM_EARLY': 'assets/sounds/Dance_With_Powder.mp3',
            'BGM_LATE': 'assets/sounds/THUNDER_STORM.mp3',
            'HIT': '', 
            'EXPLOSION': '',
            'SHIELD': '',
            'LEVELUP': '',
            'WARNING': ''
        };
    }

    async load() {
        const promises = Object.entries(this.assetPaths).map(async ([key, path]) => {
            if (!path) return;
            try {
                const response = await fetch(path);
                if (!response.ok) {
                    console.warn(`[AudioManager] Sound not found: ${path}`);
                    return;
                }
                const arrayBuffer = await response.arrayBuffer();
                // 成功時のみバッファを格納
                const decodedData = await this.ctx.decodeAudioData(arrayBuffer).catch(err => {
                    console.warn(`[AudioManager] Decode error: ${key}`, err);
                    return null;
                });
                if (decodedData) this.buffers[key] = decodedData;
            } catch (e) {
                console.warn(`[AudioManager] Fetch error: ${key}`, e);
            }
        });
        await Promise.all(promises);
        console.log("[AudioManager] Loaded.");
    }

    play(key) {
        if (this.isMuted) return;
        this._playSound(key, false);
    }

    playBgm(key) {
        if (this.isBgmMuted) {
            this.currentBgmKey = key;
            return;
        }
        if (this.currentBgmKey === key && this.sources[key]) return;
        this.stopBgm();
        this.currentBgmKey = key;
        this._playSound(key, true);
    }

    stopBgm() {
        if (this.currentBgmKey && this.sources[this.currentBgmKey]) {
            try {
                this.sources[this.currentBgmKey].stop();
            } catch(e) {}
            delete this.sources[this.currentBgmKey];
        }
    }

    toggleBgm() {
        this.isBgmMuted = !this.isBgmMuted;
        if (this.isBgmMuted) {
            this.stopBgm();
        } else {
            if (this.currentBgmKey) {
                const resumeKey = this.currentBgmKey;
                this.currentBgmKey = null;
                this.playBgm(resumeKey);
            }
        }
        return this.isBgmMuted;
    }

    _playSound(key, isLoop) {
        if (!this.buffers[key]) return;
        if (this.ctx.state === 'suspended') {
            this.ctx.resume().catch(e => console.warn(e));
        }

        const source = this.ctx.createBufferSource();
        source.buffer = this.buffers[key];
        source.loop = isLoop;

        const gainNode = this.ctx.createGain();
        const vol = isLoop ? this.bgmVolume : this.seVolume;
        gainNode.gain.value = vol * this.masterVolume;

        source.connect(gainNode);
        gainNode.connect(this.ctx.destination);

        if (!isLoop) {
             source.playbackRate.value = 0.98 + Math.random() * 0.04;
        }

        source.start(0);

        if (isLoop) {
            this.sources[key] = source;
        }
    }
}

export const audioManager = new AudioManager();
▲▲▲ FILE END: audio-manager.js ▲▲▲
